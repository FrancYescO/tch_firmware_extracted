#!/usr/bin/lua

local ubus, uloop, uci = require('ubus'), require('uloop') , require('uci')
local signal = require("signal").signal
local logger = require('tch.logger')
local posix = require("tch.posix")
local log

local monitor = {
	config_file = "datausage",
	ntp_synced = false,
	interfaces = {},
	config = {
		persist = true,
		usage_cycle_update_interval = (60*1000)
	}
}
monitor.__index = monitor

function monitor:cleanup()
	-- Prevent this from being executed twice
	if not self.cleaning_up then
		self.cleaning_up = true
		self.ifstat_timer:cancel()
		self.usage_cycle_timer:cancel()
		self.ubus:close()

		-- Store all counters at exit
		for _, interface in pairs(self.interfaces) do
			interface.has_changes = true
		end
		self:persist()

		uloop.cancel()
	end
end

function monitor:reloadconfig()
	log:info("Reloading config")
	self:load_config()
end

function monitor:get_next_usage_cycle_enddate(usage_cycle_reset_day)
	local month = tonumber(os.date("%m"))+1
	local year = os.date("%Y")
	local ret = string.format("%s-%02d-%02d", year, month, usage_cycle_reset_day)
	log:info("New data usage cycle ends on %s", ret)
	return ret
end

function monitor:validate_interface_config(interface_config)
	if not interface_config.ifname then
		return nil, "No ifname specified"
	end

	if interface_config.usage_limit_unit and
		interface_config.usage_limit_unit ~= "MB" and
		interface_config.usage_limit_unit ~= "GB" then
		return nil, "Invalid data usage limit unit"
	end

	return true
end

function monitor:update_interface_config(interface, interface_config)
	-- Exponentially smoothed average with default alpha of 0.9
	interface.alpha = tonumber(interface_config.alpha) or 0.9
	-- By default write the counters to flash every megabyte
	interface.persist_threshold = tonumber(interface_config.persist_threshold) or (1024*1024)
	if not interface.tx_bytes.total then
		interface.tx_bytes.total = tonumber(interface_config.tx_bytes_total) or 0
	end
	if not interface.rx_bytes.total then
		interface.rx_bytes.total = tonumber(interface_config.rx_bytes_total) or 0
	end

	interface.usage_limit_enabled = interface_config.usage_limit_enabled == '1' or interface_config.usage_limit_enabled == 'true'

	if interface.usage_limit_enabled then
		local old_limit = interface.usage_limit
		local old_limit_unit = interface.usage_limit_unit
		interface.usage_limit = tonumber(interface_config.usage_limit)
		interface.usage_limit_unit = interface_config.usage_limit_unit or "MB"
		if old_limit ~= interface.usage_limit or old_limit_unit ~= interface.usage_limit_unit then
			interface.usage_limit_reached = false
		end
		if interface.usage_limit then
			interface.usage_limit_bytes = interface.usage_limit * (1024*1024)
			if interface_config.usage_limit_unit == "GB" then
				interface.usage_limit_bytes = interface.usage_limit_bytes * 1024
			end
		end
	end

	interface['.name'] = interface_config['.name']

	-- Is a real interface name configured or do we need to parse an alias?
	local alias = interface.ifname_alias
	if string.sub(interface.ifname, 1, 1) == '@' then
		interface.ifname_alias = self:get_ifname_alias(string.gsub(interface.ifname, "@", "", 1))
	end

	-- Check if lower layer interface changed
	if alias and interface.ifname_alias and interface.ifname_alias ~= alias then
		log:info("Lower layer interface changed. Reset counters")
		self:reset_interface(interface)
	end

	-- Generate a new end date in case we don't have one yet or the reset day has changed
	local usage_cycle_reset_day = tonumber(interface_config.usage_cycle_reset_day) or 1

	local config_out_of_sync = false
	if interface_config.usage_cycle_enddate and
		tonumber(string.match(interface_config.usage_cycle_enddate, "%d+-%d+-(%d+)")) ~= usage_cycle_reset_day then
		config_out_of_sync = true
	end

	if not interface_config.usage_cycle_enddate or config_out_of_sync or
			(interface.usage_cycle_reset_day and (interface.usage_cycle_reset_day ~= usage_cycle_reset_day)) then
		log:info("Data usage reset day changed")
		interface_config.usage_cycle_enddate = self:get_next_usage_cycle_enddate(usage_cycle_reset_day)
		interface.has_changes = true
	end

	interface.usage_cycle_reset_day = usage_cycle_reset_day
	interface.usage_cycle_enddate = interface_config.usage_cycle_enddate
end

function monitor:load_config()
	local cursor = uci.cursor()
	local c = cursor:get(self.config_file, "global", "tracelevel")
	self.config.tracelevel = tonumber(c) or 6

	if not log then
		logger.init("datausage", tonumber(self.config.tracelevel), posix.LOG_PID)
		log = logger.new("datausage")
	else
		log:set_log_level(self.config.tracelevel)
	end

	c = cursor:get(self.config_file, "global", "persist")
	self.config.persist = c ~= '0' and c ~= 'false'

	for _, interface in pairs(self.interfaces) do
		interface.remove = true
	end
	cursor:foreach(self.config_file, "interface", function(interface_config)
		if interface_config.enabled ~= '0' and interface_config.enabled ~= 'false' then
			local ret, errMsg = self:validate_interface_config(interface_config)
			if ret then
				if not self.interfaces[interface_config.ifname] then
					log:info("Start data usage monitoring on %s", interface_config.ifname)
					local interface = {
						ifname = interface_config.ifname,
						tx_bytes = {
							average = 0,
							per_second = 0
						},
						rx_bytes = {
							average = 0,
							per_second = 0
						},
						usage_limit_reached = false
					}
					self.interfaces[interface_config.ifname] = interface
				end
				self:update_interface_config(self.interfaces[interface_config.ifname], interface_config)
				self.interfaces[interface_config.ifname].remove = nil
			else
				log:error("[%s] Invalid interface configuration (%s)", interface_config['.name'], errMsg)
			end
		end
	end)
	for _, interface in pairs(self.interfaces) do
		if interface.remove then
			self.interfaces[interface.ifname] = nil
		end
	end
	-- Write new usage cycle end date to UCI
	self:persist()
end

function monitor:persist()
	local changes = false
	local cursor = uci.cursor()
	for _, interface in pairs(self.interfaces) do
		if interface.has_changes then
			if self.config.persist then
				cursor:set(self.config_file, interface['.name'], "tx_bytes_total", interface.tx_bytes.total)
				cursor:set(self.config_file, interface['.name'], "rx_bytes_total", interface.rx_bytes.total)
				cursor:set(self.config_file, interface['.name'], "usage_cycle_enddate", interface.usage_cycle_enddate)
			end
			interface.tx_bytes.last_total = interface.tx_bytes.total
			interface.rx_bytes.last_total = interface.rx_bytes.total
			interface.has_changes = nil
			changes = true
		end
	end
	if changes and self.config.persist then
		log:debug("Writing data usage config")
		cursor:commit(self.config_file)
	end
end

function monitor:usage_cycle_update()
	if not self.ntp_synced then
		log:info("NTP not synced. Skipping usage cycle update")
		return
	end

	for _, interface in pairs(self.interfaces) do
		local end_year, end_month, end_day = string.match(interface.usage_cycle_enddate, "(%d+)-(%d+)-(%d+)")
		local end_time = math.min(os.time({day = 1, year = end_year, month = end_month + 1}), os.time({day = end_day, year = end_year, month = end_month}))
		local diff_time = os.difftime(os.time(), end_time)
		if diff_time > 0 then
			self:reset_interface_usage_cycle(interface)
		end
	end
	self:persist()
	self.usage_cycle_timer:set(self.config.usage_cycle_update_interval)
end

function monitor:read_file(file)
	local f = io.open(file, "rb")
	if f then
		local content = f:read("*all")
		f:close()
		return content
	end
	return nil
end

function monitor:update_stats(byte_stats, bytes, alpha)
	if bytes then
		if byte_stats.last and byte_stats.last <= bytes then
			byte_stats.per_second = (bytes - byte_stats.last)
			byte_stats.average = (alpha * byte_stats.per_second) + (1.0 - alpha) * byte_stats.average;
			byte_stats.total = byte_stats.total + byte_stats.per_second
		else
			byte_stats.per_second = 0
		end
		byte_stats.last = bytes
	end
	if not byte_stats.last_total then
		 byte_stats.last_total = byte_stats.total
	end
end

function monitor:get_stats(ifname)
	local path = string.format("/sys/class/net/%s/statistics/tx_bytes", ifname)
	local tx_bytes = tonumber(self:read_file(path))
	path = string.format("/sys/class/net/%s/statistics/rx_bytes", ifname)
	local rx_bytes = tonumber(self:read_file(path))
	return { tx_bytes = tx_bytes, rx_bytes = rx_bytes }
end

function monitor:ifstat_update()
	for _, interface in pairs(self.interfaces) do
		local ifname = interface.ifname
		if string.sub(ifname, 1, 1) == '@' then
			ifname = interface.ifname_alias
		end
		if ifname then
			local stats = self:get_stats(ifname)
			self:update_stats(interface.tx_bytes, stats.tx_bytes, interface.alpha)
			self:update_stats(interface.rx_bytes, stats.rx_bytes, interface.alpha)
			if interface.tx_bytes.total - interface.tx_bytes.last_total > interface.persist_threshold or
				interface.rx_bytes.total - interface.rx_bytes.last_total > interface.persist_threshold then
				log:debug("Counter threshold exeeded")
				interface.has_changes = true
			end
			if interface.usage_limit_bytes and
				interface.tx_bytes.total+interface.rx_bytes.total > interface.usage_limit_bytes and
				not interface.usage_limit_reached then
				interface.usage_limit_reached = true
				self.ubus:send("datausage.limit_reached", {interface = interface.ifname})
			end
		end
	end
	self:persist()
	self.ifstat_timer:set(1000)
end

function monitor:get_data(interface)
	local data = {
		rx_bytes_per_second = interface.rx_bytes.per_second,
		tx_bytes_per_second = interface.tx_bytes.per_second,
		rx_bytes_average = math.floor(interface.rx_bytes.average),
		tx_bytes_average = math.floor(interface.tx_bytes.average),
		rx_bytes_total = tostring(interface.rx_bytes.total),
		tx_bytes_total = tostring(interface.tx_bytes.total),
		interface_alias = interface.ifname_alias,
		usage_limit_reached = interface.usage_limit_reached
	}
	return data
end

function monitor:get_ifstat(req, msg)
	if msg.interface and self.interfaces[msg.interface] then
		self.ubus:reply(req, self:get_data(self.interfaces[msg.interface]))
		return
	end

	local data = { interfaces = {} }
	for _, interface in pairs(self.interfaces) do
		local ifdata = self:get_data(interface)
		ifdata.interface = interface.ifname
		table.insert(data.interfaces, ifdata)
	end
	self.ubus:reply(req, data)
end

function monitor:reset_interface(interface)
	log:debug("Reset data usage for %s", interface.ifname)
	interface.tx_bytes.total = 0
	interface.rx_bytes.total = 0
	interface.usage_limit_reached = false
	interface.has_changes = true
end

function monitor:reset_interface_usage_cycle(interface)
	self:reset_interface(interface)
	interface.usage_cycle_enddate = self:get_next_usage_cycle_enddate(interface.usage_cycle_reset_day)
end

function monitor:reset_ifstat(req, msg)
	if msg.interface and self.interfaces[msg.interface] then
		self:reset_interface_usage_cycle(self.interfaces[msg.interface])
	else
		for _, interface in pairs(self.interfaces) do
			self:reset_interface_usage_cycle(interface)
		end
	end
	self:persist()
end

function monitor:ntp_update()
	log:info("Checking NTP sync")
	local ret = uci.cursor(nil, "/var/state"):get("system", "ntp", "synced")
	self.ntp_synced = ret == '1' or ret == 'true'
end

function monitor:get_ifname_alias(ifname)
	local data = self.ubus:call("network.interface." .. ifname, "status", {})
	if data then
		return data.l3_device or data.device
	end
end

function monitor:ifupdate(event)
	if event.action == "ifup" and event.interface then
		for _, interface in pairs(self.interfaces) do
			if interface.ifname == "@" .. event.interface then
				local alias = interface.ifname_alias
				interface.ifname_alias = self:get_ifname_alias(event.interface)
				-- Check if lower layer interface changed
				if alias and interface.ifname_alias and interface.ifname_alias ~= alias then
					log:info("Lower layer interface changed. Reset counters")
					self:reset_interface(interface)
				end
				break
			end
		end
		self:persist()
	end
end

local UbusConn = {}
UbusConn.__index = UbusConn

function UbusConn:reply(req, data)
	if self._ubus then
		self._ubus:reply(req, data)
	end
end

function UbusConn:add(method)
	if self._ubus then
		self._ubus:add(method)
	end
end

function UbusConn:call(facility, func, params)
	if self._ubus then
		return self._ubus:call(facility, func, params)
	end
end

function UbusConn:send(facility, data)
	if self._ubus then
		self._ubus:send(facility, data)
	end
end

function UbusConn:listen(events)
	if self._ubus then
		self._ubus:listen(events)
	end
end

function UbusConn:close()
	self._ubus = nil
end

function monitor:init()
	uloop.init()

	self.ubus = {}
	self.ubus._ubus = ubus.connect()
	if not self.ubus._ubus then
		return nil, "Failed to connect to UBUS"
	end
	setmetatable(self.ubus, UbusConn)


	self:load_config()

	signal("SIGTERM", function() self:cleanup() end)
	signal("SIGINT", function() self:cleanup() end)
	signal("SIGHUP", function() self:reloadconfig(); return true end)

	local events = {}
	events['ntp.connected'] = function(...) self:ntp_update(...) end
	events['network.interface'] = function(...) self:ifupdate(...) end
	self.ubus:listen(events)

	local ubus_methods = {
		['datausage'] = {
			get = {
				function(...) self:get_ifstat(...) end, {interface = ubus.STRING}
			},
			reset = {
				function(...) self:reset_ifstat(...) end, {interface = ubus.STRING}
			}
		}
	}
	self.ubus:add(ubus_methods)

	self.ifstat_timer = uloop.timer(function() self:ifstat_update() end, 1000)
	self.usage_cycle_timer = uloop.timer(function() self:usage_cycle_update() end, self.config.usage_cycle_update_interval)
end

local function start()
	monitor:init()
	monitor:ntp_update()
	uloop.run()
end

start()
