#!/bin/sh

. /usr/share/libubox/jshn.sh
. /lib/functions.sh

map_ucitojson_acl_mode()
{
	case "$1" in
	disabled)
		echo "disable"
		;;
	unlock)
		echo "deny"
		;;
	lock|register)
		echo "allow"
		;;
	*)
		echo "disable"
		;;
	esac
}

json_add_string_list()
{
	while [ $# -gt 0 ]; do
		json_add_string "" "$1"
		shift
	done
}

get_nodeinfo()
{
	config_load "env"
	config_get manufacturer var company_name "Technicolor"
	config_get model var prod_friendly_name ""
	config_get serial var serial ""
	json_init
	json_add_string manufacturer "${manufacturer}"
	json_add_string model "${model}"
	json_add_string serial "${serial}"
	json_dump
}

get_nodeconfig()
{
	config_load "fhcd"
	config_get publish_wifi_mac_acl TLV_NodeConfig publish_wifi_mac_acl "1"

	config_load "wireless"

	json_add_state()
	{
		if [ "$1" = "1" ]; then
			json_add_boolean "disabled" 0
		else
			json_add_boolean "disabled" 1
		fi
	}


	json_add_wireless_object()
	{
		local wifi_ap=$1

		config_get wpa_psk_key "$wifi_ap" wpa_psk_key
		config_get security_mode "$wifi_ap" security_mode
		if [ "$publish_wifi_mac_acl" = "1" ]; then
			config_get acl_mode "$wifi_ap" acl_mode "disabled"
			config_get acl_accept_list "$wifi_ap" acl_accept_list
			config_get acl_deny_list "$wifi_ap" acl_deny_list
			json_add_string "macfilter" $(map_ucitojson_acl_mode "$acl_mode")
			json_add_array "maclist"
			case "$acl_mode" in
			unlock)
				json_add_string_list $acl_deny_list
				;;
			lock|register)
				json_add_string_list $acl_accept_list
				;;
			*)
				;;
			esac
			json_close_array
		fi
		json_add_object "encryption"
		json_add_string "key" "$wpa_psk_key"
		json_add_string "protocol" "${security_mode}"
		json_close_object
	}

	check_ap()
	{
		local ap_section_name_in=$1
		local iface_section_name=$2
		local ap_section_name_out=$3

		config_get iface "$ap_section_name_in" iface
		if [ "$iface" = "$iface_section_name" ]; then
			#found the ap section linked with the requested interface
			eval "$ap_section_name_out=\${ap_section_name_in}"
		fi
	}

	load_devices()
	{
		local devname=$1
		config_get channel "$devname" channel
		config_get state "$devname" state
		json_add_object
		json_add_string "name" "$devname"
		json_add_state $state
		json_add_string "channel" "$channel"
		json_close_object
	}

	load_interfaces()
	{
		get_wifi_ap_name()
		{
			local ap_name
			config_foreach check_ap "wifi-ap" "$1" ap_name
			echo $ap_name
		}

		local wifi_iface_name=$1
		local wifi_ap_name
		if [ "${wifi_iface_name}" = "wl0" ] || [ "${wifi_iface_name}" = "wl1" ] || [ "${wifi_iface_name}" = "wl0_1" ] || [ "${wifi_iface_name}" = "wl1_1" ] || [ "${wifi_iface_name}" = "wl1_2" ]; then
			wifi_ap_name=$(get_wifi_ap_name "${wifi_iface_name}")
			config_get state "${wifi_ap_name}" state
			if [ "$state" = 1 ]; then
				config_get mode "${wifi_iface_name}" mode
				config_get ssid "${wifi_iface_name}" ssid
				config_get radio "${wifi_iface_name}" device
				json_add_object
				json_add_string "name" "${wifi_iface_name}"
				json_add_string "type" "wireless"
				json_add_object "wireless"
				json_add_wireless_object ${wifi_ap_name}
				json_add_string "mode" "$mode"
				json_add_string "ssid" "$ssid"
				json_add_string "radio" "$radio"
				json_close_object
				json_close_object
			fi
		fi
	}

	json_init
	json_add_array "radios"
	config_foreach load_devices "wifi-device"
	json_close_array
	json_add_array "interfaces"
	config_foreach load_interfaces "wifi-iface"
	json_close_array
	json_dump
}

check_wifi_iface()
{
	local type=""
	local sectionname="$1"
	local ifname="$2"
	local mode=$(config_get "$sectionname" mode)
	local radio=$(config_get "$sectionname" device)
	local band=${radio##radio_}
	local mac
	if [ "$sectionname" = "$ifname" ]; then
		type="wifi"
		mac=$(ip link show $ifname | awk '/ether/ { print $2 }')
	else
		local _json_no_warning=1
		local radio_ifname
		local ubus_output=$(ubus -S call wireless.radio.remote get '{"name":"'"$radio"'"}')
		[ -z "$ubus_output" ] && return
		# make sure the parsing is separate from output
		json_set_namespace "input"
		json_load "$ubus_output"
		json_select "$radio"
		[ $? -eq 0 ] || return
		json_get_var radio_ifname ifname
		[ "$ifname" = "$radio_ifname" ] || return
		type="wifi"
		json_get_var mac macaddr # this is the remote side's MAC!
	fi
	[ -n "$type" ] && {
		json_set_namespace "output"
		json_add_string name "$ifname"
		json_add_string type "$type"
		json_add_string mode "$mode"
		json_add_string band "$band"
		json_add_string mac  "$mac"
		json_dump
		exit 0
	}
}

get_endpointinfo()
{
	local ifname="$1"
	local type=""
	local mac
	local speed

	json_set_namespace "output"
	json_init
	config_load wireless
	config_foreach check_wifi_iface wifi-iface "$ifname"
	# if we get here it's not a wifi interface; perhaps it's eth?
	# ensure we're in the right JSON namespace; might have
	# changed in the config_foreach
	json_set_namespace "output"
	json_add_string name "$ifname"
	if [ -n "$(uci -q get ethernet.${ifname})" ]; then
		type="eth"
		mac=$(ip link show $ifname | awk '/ether/ { print $2 }')
		speed=$(cat /sys/class/net/${ifname}/speed 2>/dev/null)
		json_add_string type "$type"
		json_add_string mac  "$mac"
		[ -n "$speed" ] && { json_add_string speed "$speed"; }
	# No ethernet either, perhaps dynamically created wds ?
	elif [ "${ifname:0:3}" = "wds" ] && [ -d /sys/class/net/${ifname} ]; then
		mac=$(cat /sys/class/net/${ifname}/address 2>/dev/null)
		type="wifi"
		mode="ap"
		band=$(wl -i $ifname band 2>/dev/null)
		case "$band" in
			"a") band="5G";;
			"b") band="2G";;
		esac
		json_add_string type "$type"
		json_add_string mode "$mode"
		json_add_string band "$band"
		json_add_string mac  "$mac"
	fi
	json_dump
}

case "$1" in
	"NodeInfo")
		get_nodeinfo
		;;
	"NodeConfig")
		get_nodeconfig
		;;
	"EndpointInfo")
		get_endpointinfo "$2"
		;;
esac
