-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_DeviceInfo_ProcessStatus_ = {
  objectType = {
    name = "Device.DeviceInfo.ProcessStatus.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      CPUUsage = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
        range = {
          {
            max = "100",
          },
        },
      },
      -- ProcessNumberOfEntries
      -- automatically created when Device.DeviceInfo.ProcessStatus.Process.{i}. is loaded
    }
  }
}

local register, io, string = register, io, string
local tonumber, match = tonumber, string.match

local function getCpuUSage()
  local words = {}
  local usageValue
  local getData = io.popen("top -b -n1")
  for line in getData:lines() do
    usageValue =  line:match("^CPU:%s*(%d+)%%")
    if usageValue then
      break
    end
  end
  getData:close()
  return usageValue or "0"
end

Device_DeviceInfo_ProcessStatus_.get = {
  CPUUsage = getCpuUSage(),
}

register(Device_DeviceInfo_ProcessStatus_)

local Device_DeviceInfo_ProcessStatus_Process_i_ = {
  objectType = {
    name = "Device.DeviceInfo.ProcessStatus.Process.{i}.",
    access = "readOnly",
    numEntriesParameter = "ProcessNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      PID = {
        access = "readOnly",
        type = "unsignedInt",
      },
      Command = {
        access = "readOnly",
        type = "string",
        max = "256",
      },
      Size = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      Priority = {
        access = "readOnly",
        type = "unsignedInt",
        range = {
          {
            max = "99",
          },
        },
      },
      CPUTime = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      State = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "string",
        enumeration = {
          "Running",
          "Sleeping",
          "Stopped",
          "Idle",
          "Uninterruptible",
          "Zombie",
        },
      },
    }
  }
}

local lfs = require("lfs")
local dir = lfs.dir
local gsub, sub, byte = string.gsub, string.sub, string.byte
local stateMap = { R = 'Running', S = 'Sleeping', D = 'Uninterruptible',
      Z = 'Zombie', T = 'Stopped', W = 'Running' }

local posix = require("tch.posix")

-- reference http://man7.org/linux/man-pages/man5/proc.5.html
local nameMap = {
  ["comm"] = 2,
  ["state"] = 3,
  ["utime"] = 14,
  ["stime"] = 15,
  ["priority"] = 18,
  ["vsize"] = 23,
}

local function readFile(filename)
  local fd, msg = io.open(filename)
  if not fd then
    return fd, msg
  end
  local result = fd:read("*a")
  fd:close()
  return result
end

local function getProcData(PID)
  local procStat = {}
  local index = 1
  local pidStat = readFile("/proc/" .. PID .. "/stat")
  if not pidStat then
    return {}
  end
  for val in pidStat:gmatch("%S+") do
    procStat[index] = val
    index = index + 1
  end
  return procStat
end

local function getProcessStatus(mapping, param, key)
  local PID = key

  if param == "PID" then
    return PID
  end

  if param == "Command" then
    local cmdline = readFile("/proc/" .. PID .. "/cmdline")
    if not cmdline then
      return ""
    end
    -- If we have a cmdline string we use it.
    if #cmdline > 0 then
      -- The cmdline string uses null bytes as separators; replace them by spaces.
      local cmd = gsub(cmdline, "%z", " ")
      -- Beautification: if there was a trailing null byte it was replaced by a
      -- space. In that case strip it off.
      if byte(cmd, #cmd) == 0x20 then
        cmd = sub(cmd, 1, #cmd - 1)
      end
      return cmd
    else
      -- In some circumstances the 'cmdline' file is empty: kernel threads,
      -- zombie processes, paged out processes, ... In that case read the
      -- 'stat' file.
      local procStat = getProcData(key)
      return procStat and procStat[nameMap["comm"]] or ""
    end
  end

  if param == "State" then
    local procStat = getProcData(key)
    if not procStat then
      return "Dead"
    end
    local state = procStat[nameMap["state"]]
    if not state then
      return "Dead"
    end
    return stateMap[state]
  end

  if param == "Size" then
    local procStat = getProcData(key)
    return procStat and procStat[nameMap["vsize"]] or "0"
  end

  if param == "Priority" then
    local procStat = getProcData(key)
    return procStat and procStat[nameMap["priority"]] or ""
  end

  if param == "CPUTime" then
    local procStat = getProcData(key)
    if procStat then
      local clockTicks = posix.sysconf(posix._SC_CLK_TCK)
      local userCodeTime = procStat[nameMap["utime"]] and tonumber(procStat[nameMap["utime"]])
      local kernelCodeTime = procStat[nameMap["stime"]] and tonumber(procStat[nameMap["stime"]])
      if userCodeTime and kernelCodeTime then
        local cpuTime = ((userCodeTime + kernelCodeTime)/clockTicks)*1000
        cpuTime = string.format("%0.0f",cpuTime) -- rounding off
        return cpuTime or "0"
      end
    end
    return "0"
  end
end

local function entriesProcessStatus(mapping)
  local result = {}
  for file in dir('/proc/') do
    -- we're only interested in PIDs
    if tonumber(file) then
      result[#result+1] = file  -- the PID is our key
    end
  end
  return result
end

Device_DeviceInfo_ProcessStatus_Process_i_.get=getProcessStatus
Device_DeviceInfo_ProcessStatus_Process_i_.entries=entriesProcessStatus

register(Device_DeviceInfo_ProcessStatus_Process_i_)
