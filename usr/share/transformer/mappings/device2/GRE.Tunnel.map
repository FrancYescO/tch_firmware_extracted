-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_GRE_Tunnel_i_ = {
  objectType = {
    name = "Device.GRE.Tunnel.{i}.",
    access = "readOnly", -- currently readWrite not supported
    numEntriesParameter = "TunnelNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Disabled",
          "Enabled",
          "Error",
        },
      },
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
      },
      RemoteEndpoints = {
        access = "readWrite",
        list = true,
        maxItems = "4",
        type = "string",
        max = "256",
      },
      KeepAlivePolicy = {
        access = "readOnly", -- readWrite currently not supported
        type = "string",
        enumeration = {
          "ICMP",
          "None",
        },
        default = "None",
      },
      KeepAliveTimeout = {
        access = "readOnly", -- readWrite currently not supported
        type = "unsignedInt",
        default = "10",
      },
      KeepAliveThreshold = {
        access = "readOnly", -- readWrite currently not supported
        type = "unsignedInt",
        default = "3",
      },
      DeliveryHeaderProtocol = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "IPv4",
          "IPv6",
        },
      },
      DefaultDSCPMark = {
        access = "readOnly", -- readWrite currently not supported
        type = "unsignedInt",
        default = "0",
      },
      ConnectedRemoteEndpoint = {
        access = "readOnly",
        type = "string",
        max = "256",
      },
      -- InterfaceNumberOfEntries
      -- automatically created when Device.GRE.Tunnel.{i}.Interface.{i}. is loaded
    }
  }
}

local nwmodel = require 'transformer.shared.models.device2.network'
local model

local posix = require 'tch.posix'
local AF_INET = posix.AF_INET
local AF_INET6 = posix.AF_INET6


local pairs = pairs
local ubus = mapper("ubus").connect()
local uciHelper = mapper("ucihelper")
local network = { config = "network" }

local getUciValue, setUciValue, getSection, commit, revert
do
  local configChanged = false

  function getUciValue(name, option, default, section_data)
    if section_data then
      return section_data[option] or default
    else
      network.sectionname = name
      network.option = option
      network.default = default
      return uciHelper.get_from_uci(network)
    end
  end

  function setUciValue(name, option, value)
    network.sectionname = name
    network.option = option
    uciHelper.set_on_uci(network, value, commitapply)
    configChanged = true
  end

  function getSection(name)
    network.sectionname = name
    return uciHelper.getall_from_uci(network) or {}
  end

  function commit()
    if configChanged then
      uciHelper.commit(network)
    end
    configChanged = false
  end

  function revert()
    if configChanged then
      uciHelper.revert(network)
    end
    configChanged = false
  end
end

Device_GRE_Tunnel_i_.entries = function()
  model = nwmodel.load()
  return model:getKeys("GRE")
end

local protocol_to_addressType = {
  gre = AF_INET,
  gretap = AF_INET,
  grev6 = AF_INET6,
  grev6tap = AF_INET6
}

local function getAddrType(key, uci_data)
  local proto = getUciValue(model:getUciKey(key), "proto", "gre", uci_data)
  return protocol_to_addressType[proto] or AF_INET
end

local function getPeerField(key, uci_values)
  local addrType = getAddrType(key, uci_values)
  return addrType == AF_INET6 and "peer6addr"or "peeraddr"
end

local function getRemoteEndpoint(key, uci_values)
  local peerfield = getPeerField(key, uci_values)
  return getUciValue(model:getUciKey(key), peerfield, "", uci_values)
end

local getter = {
  Enable = function(key, uci_values)
    local enable = getUciValue(model:getUciKey(key), "auto", "1", uci_values)
    return enable == "0" and "0" or "1"
  end,
  Status = function(key, _, intfData)
    intfData = intfData or ubus:call("network.interface." .. model:getUciKey(key), "status", {}) or {}
    return intfData.up and "Enabled" or "Disabled"
  end,
  RemoteEndpoints = function(key, uci_values)
    return getRemoteEndpoint(key, uci_values)
  end,
  KeepAlivePolicy = function()
    return "None"
  end,
  KeepAliveTimeout = function()
    return "10"
  end,
  KeepAliveThreshold = function()
    return "3"
  end,
  DeliveryHeaderProtocol = function(key, uci_values)
    local addressType = getAddrType(key, uci_values)
    return addressType == AF_INET and "IPv4" or "IPv6"
  end,
  DefaultDSCPMark = function()
    return "0"
  end,
  ConnectedRemoteEndpoint = function(key, uci_values)
    return getRemoteEndpoint(key, uci_values)
  end,
}

Device_GRE_Tunnel_i_.get = function(mapping, param, key)
  return getter[param](key)
end

Device_GRE_Tunnel_i_.getall = function(mapping, key)
  local uciValues = getSection(model:getUciKey(key))
  local intfData = ubus:call("network.interface." .. model:getUciKey(key), "status", {})
  local all = {}
  for param, fn in pairs(getter) do
    all[param] = fn(key, uciValues, intfData)
  end
  return all
end

local function normalize_ip(family, ip_str)
  local ip, err = posix.inet_pton(family, ip_str)
  if not ip then
    return nil, err
  end
  return posix.inet_ntop(family, ip)
end

local function ipIsUnassigned(family, ip)
  if family == AF_INET then
    return ip=="0.0.0.0"
  elseif family == AF_INET6 then
    return ip=="::"
  end
  return false
end

local function makeIPlist(family, value)
  local addresses = {}
  for ip_str in value:gmatch("([^,]+)") do
    local ip, err = normalize_ip(family, ip_str)
    if not ip then
      return nil, err
    end
    if not ipIsUnassigned(family, ip) then
      addresses[#addresses + 1] = ip
    end
  end
  return addresses
end

local function setPeer(key, family, new_peer)
  local peer = family==AF_INET and new_peer or ""
  local peer6 = family==AF_INET6 and new_peer or ""
  local uci_key = model:getUciKey(key)
  setUciValue(uci_key, "peeraddr", peer)
  setUciValue(uci_key, "peer6addr", peer6)
end

Device_GRE_Tunnel_i_.set = {
  Enable = function(mapping, param, value, key)
    setUciValue(model:getUciKey(key), "auto", value)
    commitapply:newset("gre_hotspotd")
  end,
  RemoteEndpoints = function(mapping, param, value, key)
    local addrType = getAddrType(key)
    local addresses, err = makeIPlist(addrType, value)
    if not addresses then
      return nil, err
    end
    if #addresses > 1 then
      return nil, "multiple remote endpoints are not supported"
    end
    setPeer(key, addrType, addresses[1] or "")
    commitapply:newset("gre_hotspotd")
  end,
  DeliveryHeaderProtocol = function(_, _, value, key)
    local current = getAddrType(key)
    local requested = (value=="IPv4") and AF_INET or AF_INET6
    if requested ~= current then
      setPeer(key, current, "")
      local tap = getUciValue(model:getUciKey(key), "proto", "gre"):match("tap$") and "tap" or ""
      local proto = (requested==AF_INET) and ("gre"..tap) or ("grev6"..tap)
      setUciValue(model:getUciKey(key), "proto", proto)
      commitapply:newset("gre_hotspotd")
    end
  end,
}

Device_GRE_Tunnel_i_.commit = commit
Device_GRE_Tunnel_i_.revert = revert

register(Device_GRE_Tunnel_i_)
