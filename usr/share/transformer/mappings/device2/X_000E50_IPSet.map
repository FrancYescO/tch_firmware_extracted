-- Manually generated
local Device_Multi_i_ = {
  objectType = {
    name = "Device.#ROOT.{i}.",
    access = "readWrite",
    minEntries = 0,
    maxEntries = math.huge,
    description = "Parameters to get or set IPSet entries",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
	default = "true",
        description = "Enables or Disables an ipset rule",
      },
      Name = {
        access = "readOnly",
        type = "string",
        description = "Name of an ipset rule",
      },
      ProtocolFamily = {
        access = "readWrite",
        type = "string",
	enumeration = {
	  "ipv4",
	  "ipv6",
        },
	default = "ipv4",
        description = "Protocol family to which the ipset belongs to",
      },
      Storage = {
        access = "readWrite",
        type = "string",
        description = "Storage method used for an ipset rule",
      },
      Match = {
        access = "readWrite",
        type = "string",
        description = "Comma separated list of matching values like Source IP, Destination IP, etc",
      },
      IPRange = {
        access = "readWrite",
        type = "string",
        description = "IP Range defined for this ipset rule",
      },
      PortRange = {
        access = "readWrite",
        type = "string",
        description = "Port Range defined for this ipset rule",
      },
      NetMask = {
        access = "readWrite",
        type = "unsignedInt",
	default = "32",
        description = "Netmask used by IPAddress defined for ipset rule",
      },
      MaxElements = {
        access = "readWrite",
        type = "unsignedInt",
	default = "65536",
        description = "Maximum elements that can be stored",
      },
      HashSize = {
        access = "readWrite",
        type = "unsignedInt",
	default = "1024",
        description = "Length of the Hash defined",
      },
      Timeout = {
        access = "readWrite",
        type = "unsignedInt",
	default = "0",
        description = "Timeout defined for this ipset rule",
      },
    }
  }
}

local commitapply, mapper, register = commitapply, mapper, register
local uciHelper = mapper("ucihelper")
local getFromUci = uciHelper.get_from_uci
local setOnUci = uciHelper.set_on_uci
local forEachOnUci = uciHelper.foreach_on_uci
local configChanged
local ipsetBinding = { config = "ipset" }

local storageMethods = {
  bitmap = true,
  hash = true,
  list = true,
}

local storageDataType = {
  ip = true,
  port = true,
  mac = true,
  net = true,
  set = true,
}

Device_Multi_i_.entries = function()
  local ipsetEntries = {}
  ipsetBinding.sectionname = "ipset"
  forEachOnUci(ipsetBinding, function(s)
    ipsetEntries[#ipsetEntries + 1] = s[".name"]
  end)
  return ipsetEntries
end

local function getUciValue(key, option, default)
  ipsetBinding.sectionname = key
  ipsetBinding.option = option
  ipsetBinding.default = default
  return getFromUci(ipsetBinding)
end

local function setUciValue(key, option, value)
  ipsetBinding.sectionname = key
  ipsetBinding.option = option
  setOnUci(ipsetBinding, value, commitapply)
  configChanged = true
end

local function getIPPortHash(key, bitmap, option, default)
  if getUciValue(key, "storage") == bitmap then
    return getUciValue(key, option, default)
  end
  return default or ""
end

local function getMaskMaxElements(key, option, default, storage1, storage2)
  if getUciValue(key, "storage") == storage1 or getUciValue(key, "storage") == storage2 then
    return getUciValue(key, option, default)
  end
  return default
end

Device_Multi_i_.get = {
  Enable = function(mapping, param, key)
    return getUciValue(key, "enabled", "1")
  end,
  Name = function(mapping, param, key)
    return key
  end,
  ProtocolFamily = function(mapping, param, key)
    return getUciValue(key, "family", "ipv4")
  end,
  Storage = function(mapping, param, key)
    return getUciValue(key, "storage")
  end,
  Match = function(mapping, param, key)
    local value = getUciValue(key, "match", {})
    return type(value) == "string" and value or table.concat(value, ",")
  end,
  IPRange = function(mapping, param, key)
    return getIPPortHash(key, "bitmap:ip", "iprange")
  end,
  PortRange = function(mapping, param, key)
    return getIPPortHash(key, "bitmap:port", "portrange")
  end,
  NetMask = function(mapping, param, key)
    return getMaskMaxElements(key, "netmask", "32", "bitmap:ip", "hash:ip")
  end,
  MaxElements = function(mapping, param, key)
    return getMaskMaxElements(key, "maxelem", "65536", "hash", "list")
  end,
  HashSize = function(mapping, param, key)
    return getIPPortHash(key, "hash", "hashsize", "1024")
  end,
  Timeout = function(mapping, param, key)
    return getUciValue(key, "timeout", "0")
  end,
}

Device_Multi_i_.getall = function(mapping, key)
  ipsetBinding.sectionname = key
  local allValues = uciHelper.getall_from_uci(ipsetBinding)
  return {
    Enable = allValues.enabled or "1",
    Name = key,
    ProtocolFamily = allValues.family or "ipv4",
    Storage = allValues.storage or "",
    Match = allValues.match and type(allValues.match) == "string" and allValues.match or table.concat(allValues.match or {}, ",") or "",
    IPRange = getIPPortHash(key, "bitmap:ip", "iprange"),
    PortRange = getIPPortHash(key, "bitmap:port", "portrange"),
    NetMask = getMaskMaxElements(key, "netmask", "32", "bitmap:ip", "hash:ip"),
    MaxElements = getMaskMaxElements(key, "maxelem", "65536", "hash", "list"),
    HashSize = getIPPortHash(key, "hash", "hashsize", "1024"),
    Timeout = allValues.timeout or "0",
  }
end

Device_Multi_i_.set = {
  Enable = function(mapping, param, value, key)
    setUciValue(key, "enabled", value)
  end,
  ProtocolFamily = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "bitmap" then
      value = "ipv4"
    end
    setUciValue(key, "family", value)
  end,
  Storage = function(mapping, param, value, key)
    if storageMethods[value] then
      setUciValue(key, "storage", value)
    else
      local method, datatype = value:match("(%S+):(%S+)")
      if storageMethods[method]  and storageDataType[datatype] then
        setUciValue(key, "storage", value)
      else
        return nil, "Invalid value"
      end
    end
  end,
  Match = function(mapping, param, value, key)
    local direction, datatype = value:match("(%S+)_(%S+)")
    if direction and datatype then
      if (direction == "src" or "dest") and storageDataType[datatype] then
        setUciValue(key, "match", {value})
      else
        return nil, "Invalid value"
      end
    end
  end,
  IPRange = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "bitmap:ip" then
      setUciValue(key, "iprange", value)
    end
  end,
  PortRange = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "bitmap:port" then
      setUciValue(key, "portrange", value)
    end
  end,
  NetMask = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "hash:ip" or getUciValue(key, "storage") == "bitmap:ip" then
      setUciValue(key, "netmask", value)
    end
  end,
  MaxElements = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "hash" or getUciValue(key, "storage") == "list" then
      setUciValue(key, "maxelem", value)
    end
  end,
  HashSize = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "hash" then
      setUciValue(key, "hashsize", value)
    end
  end,
  Timeout = function(mapping, param, value, key)
    setUciValue(key, "timeout", value)
  end,
}

local function newIPsetName()
  local ipsetName = uciHelper.generate_key()
  -- IPset name should be at most 31 chars long
  return ipsetName:sub(1,31)
end

Device_Multi_i_.add = function(mapping)
  local key = newIPsetName()
  ipsetBinding.sectionname = key
  ipsetBinding.option = nil
  uciHelper.set_on_uci(ipsetBinding, "ipset", commitapply)
  configChanged = true
  return key
end

Device_Multi_i_.delete = function(mapping, key)
  ipsetBinding.sectionname = key
  ipsetBinding.option = nil
  uciHelper.delete_on_uci(ipsetBinding, commitapply)
  configChanged = true
  return true
end

Device_Multi_i_.commit = function()
  if configChanged then
    uciHelper.commit(ipsetBinding)
    configChanged = false
  end
end

Device_Multi_i_.revert = function()
  if configChanged then
    uciHelper.revert(ipsetBinding)
    configChanged = false
  end
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Device_Multi_i_, "#ROOT", { "X_000E50_IPSet", "X_BELGACOM_IPSet" })
for _, dupli in ipairs(duplicates) do
  register (dupli)
end
