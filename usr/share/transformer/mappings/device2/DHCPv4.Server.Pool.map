-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_DHCPv4_Server_Pool_i_ = {
  objectType = {
    name = "Device.DHCPv4.Server.Pool.{i}.",
    access = "readOnly",
    numEntriesParameter = "PoolNumberOfEntries",
    enableParameter = "Enable",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Disabled",
          "Enabled",
          "Error_Misconfigured",
          "Error",
        },
        default = "Disabled",
      },
      Interface = {
        access = "readWrite",
        type = "string",
        max = "256",
        pathRef = true,
        targetParent = "Device.IP.Interface.{i}.",
        default = "",
      },
      MinAddress = {
        access = "readWrite",
        type = "string",
      },
      MaxAddress = {
        access = "readWrite",
        type = "string",
      },
      SubnetMask = {
        access = "readWrite",
        type = "string",
      },
      DomainName = {
        access = "readWrite",
        type = "string",
        max = "64",
      },
      IPRouters = {
        access = "readWrite",
        list = true,
        maxItems = "4",
        type = "string",
      },
      LeaseTime = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
          },
        },
        default = "86400",
      },
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
        max  = "64",
      },
--[[ TODO:
      Order = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
      VendorClassID = {
        access = "readWrite",
        type = "string",
        max = "255",
        default = "",
      },
      VendorClassIDExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      VendorClassIDMode = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "Exact",
          "Prefix",
          "Suffix",
          "Substring",
        },
        default = "Exact",
      },
      ClientID = {
        access = "readWrite",
        type = "hexBinary",
        max = "255",
        default = "",
      },
      ClientIDExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      UserClassID = {
        access = "readWrite",
        type = "hexBinary",
        max = "255",
        default = "",
      },
      UserClassIDExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      Chaddr = {
        access = "readWrite",
        type = "string",
        default = "",
      },
      ChaddrMask = {
        access = "readWrite",
        type = "string",
        default = "",
      },
      ChaddrExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      ReservedAddresses = {
        access = "readWrite",
        list = true,
        maxItems = "32",
        type = "string",
        default = "",
      },
--]]
      DNSServers = {
        access = "readWrite",
        list = true,
        maxItems = "4",
        type = "string",
      },
      -- StaticAddressNumberOfEntries
      -- automatically created when Device.DHCPv4.Server.Pool.{i}.StaticAddress.{i}. is loaded
      -- OptionNumberOfEntries
      -- automatically created when Device.DHCPv4.Server.Pool.{i}.Option.{i}. is loaded
      -- ClientNumberOfEntries
      -- automatically created when Device.DHCPv4.Server.Pool.{i}.Client.{i}. is loaded
    }
  }
}

local mapper, pairs, resolve, string = mapper, pairs, resolve, string
local bit = require("bit")
local min = require("math").min
local uciHelper = mapper("ucihelper")
local getFromUci = uciHelper.get_from_uci
local getAllFromUci = uciHelper.getall_from_uci
local setOnUci = uciHelper.set_on_uci
local forEachOnUci = uciHelper.foreach_on_uci
local nwCommon = mapper("nwcommon")
local commit = uciHelper.commit
local revert = uciHelper.revert
local commitApply = commitapply
local dhcp = require("transformer.shared.dhcp")
local format, tonumber= string.format, tonumber
local INFINITE = 4294967295 -- contains largest possible integer value to achieve infinity. LNUM patch prevents using 0xFFFFFFFF directly.
local binding = {}

local transactions = {}
local networkIntfTable = {}

Device_DHCPv4_Server_Pool_i_.entries = function()
  local interfaces = {}
  local lan = nwCommon.findLanWanInterfaces(false)
  binding.config = "dhcp"
  binding.sectionname = "dhcp"
  forEachOnUci(binding, function(s)
    for _,v in pairs(lan) do
      if s['interface'] == v then
        interfaces[#interfaces + 1] = s['.name']
        networkIntfTable[s['.name']] = s['interface']
      end
    end
  end)
  return interfaces
end

local function getUciParam(config, sectionName, option, default)
  binding.config = config
  binding.sectionname = sectionName
  binding.default = default
  if option then
    binding.option = option
    return getFromUci(binding)
  end
  return getAllFromUci(binding)
end

local function setUciParam(config, sectionName, option, value)
  binding.config = config
  binding.sectionname = sectionName
  binding.option = option
  setOnUci(binding,value,commitApply)
  transactions[config] = true
end

local function getDHCPData(key)
  local networkSection = networkIntfTable[key]
  local networkConfig = getUciParam("network", networkSection)
  local dhcpConfig = getUciParam("dhcp", key)

  local netMask = nwCommon.ipv4ToNum(networkConfig["netmask"])
  local baseIp = nwCommon.ipv4ToNum(networkConfig["ipaddr"])
  local start = tonumber(dhcpConfig["start"] or "100")
  local numIps = tonumber(dhcpConfig["limit"] or "150")

  if baseIp == "" then
    baseIp = 0
  end
  if netMask == "" then
    netMask = 0
  end

  local network = bit.band(baseIp, netMask)
  local ipMin = network + 1
  local ipMax = bit.bor(network, bit.bnot(netMask)) - 1
  local ipStart = bit.bor(network, bit.band(start, bit.bnot(netMask)))
  local ipEnd = min(ipStart + numIps - 1, ipMax)

  return {
    ipStart = ipStart,
    ipEnd = ipEnd,
    network = network,
    ipMin = ipMin,
    ipMax = ipMax,
  }
end

local function getEnable(mapping, param, key, value)
  local check = value or getUciParam("dhcp", key, "ignore")
  return check == "1" and "0" or "1"
end

local function getStatus(mapping, param, key)
  local status = getEnable(mapping, param, key)
  if status == "1" then
    return "Enabled"
  elseif status == "" then
    return "Error_Misconfigured"
  end
  return "Disabled"
end

local function getMinAddress(mapping, param, key)
  local networkSection = networkIntfTable[key]
  local result = getUciParam("network", networkSection, "ipaddr")
  local net = getUciParam("network", networkSection, "netmask")
  if result == "" or net == "" then
    return ""
  end
  local data = getDHCPData(key)
  return nwCommon.numToIPv4(data.ipStart) or ""
end

local function getMaxAddress(mapping, param, key)
  local networkSection = networkIntfTable[key]
  local result = getUciParam("network",networkSection,"ipaddr")
  local net = getUciParam("network",networkSection,"netmask")
  if result == "" or net == "" then
    return ""
  end
  local data = getDHCPData(key)
  return nwCommon.numToIPv4(data.ipEnd) or ""
end

Device_DHCPv4_Server_Pool_i_.get = {
  Enable = getEnable,

  Interface = function(mapping, param, key)
    local intf = getUciParam("dhcp", key, "interface")
    return resolve('Device.IP.Interface.{i}.',intf) or ""
  end,

  Status = getStatus,

  MinAddress = getMinAddress,

  MaxAddress = getMaxAddress,

  SubnetMask = function(mapping, param, key)
    local networkSection = networkIntfTable[key]
    return getUciParam("network", networkSection, "netmask") or ""
  end,

  DomainName = function(mapping, param, key)
    local result = getFromUci({
      extended = 1, config = "dhcp", sectionname = "@dnsmasq[0]", option = "domain"
    })
    return result or ""
  end,

  IPRouters = function(mapping, param, key)
    local dhcpList = getUciParam("dhcp", key, "dhcp_option")
    local routeIP = dhcpList ~= "" and dhcp.getRouteIPAddress(dhcpList)
    if routeIP then
      return routeIP
    end
    local defaultRoute = getUciParam("network", networkIntfTable[key], "defaultroute")
    if defaultRoute == "1" or defaultRoute == "" then
      return getUciParam("network", networkIntfTable[key], "ipaddr")
    end
    return ""
  end,

  DNSServers = function(mapping, param, key)
    local dhcpList = getUciParam("dhcp", key, "dhcp_option")
    local dnsServers = dhcpList ~= "" and dhcp.parseDNSServersFromUCI(dhcpList) or ""
    return dnsServers ~= "" and dnsServers or getUciParam("network", networkIntfTable[key], "ipaddr")
  end,

  LeaseTime = function(mapping, param, key)
    local result = getUciParam("dhcp", key, "leasetime")
    local ret = dhcp.convertTimeStringToSeconds(result)
    return ret
  end,
}

Device_DHCPv4_Server_Pool_i_.getall = function(mapping, key)
  local networkSection = networkIntfTable[key]
  local dhcpConfig = getUciParam("dhcp", key)
  local networkConfig = getUciParam("network", networkSection)
  local routeIP = dhcpConfig["dhcp_option"] and dhcp.getRouteIPAddress(dhcpConfig["dhcp_option"])
  local dnsServers = dhcpConfig["dhcp_option"] and dhcp.parseDNSServersFromUCI(dhcpConfig["dhcp_option"]) or ""
  return {
    Enable = getEnable(mapping, nil, key, dhcpConfig["ignore"]),
    Status = getStatus(mapping, nil, key),
    Interface = resolve('Device.IP.Interface.{i}.',dhcpConfig["interface"]) or "",
    SubnetMask = networkConfig["netmask"] or "",
    DomainName = getFromUci({extended = 1, config = "dhcp", sectionname = "@dnsmasq[0]", option = "domain"}) or "",
    IPRouters = routeIP or (networkConfig["defaultroute"] == "1" or not networkConfig["defaultroute"]) and networkConfig["ipaddr"] or "",
    DNSServers = dnsServers ~= "" and dnsServers or networkConfig["ipaddr"] or "",
    MinAddress = getMinAddress(mapping, nil, key) or "",
    MaxAddress = getMaxAddress(mapping, nil, key) or "",
    LeaseTime = dhcp.convertTimeStringToSeconds(dhcpConfig["leasetime"]),
  }
end

Device_DHCPv4_Server_Pool_i_.set = {
  Enable = function(mapping, param, value, key)
    value = (value == "1") and "0" or "1"
    setUciParam("dhcp", key, "ignore", value)
  end,

  Interface = function(mapping, param, value, key)
    if value ~= "" then
      local rc
      rc,value = pcall(tokey, value, "Device.IP.Interface.{i}.")
      if not rc then
        return nil ,"invalid value"
      end
    end
    setUciParam("dhcp", key, "interface", value)
  end,

  MinAddress = function(mapping, param, value, key)
    local check = nwCommon.isIPv4(value)
    if check then
      local data = getDHCPData(key)
      local start = nwCommon.ipv4ToNum(value)
      local newStart = start - data.network
      local newEnd  = data.ipEnd - start + 1
        if start < data.ipMin or start >= data.ipEnd then
          return nil, "Invalid start address"
        end
      setUciParam("dhcp", key, "start", newStart)
      setUciParam("dhcp", key, "limit", newEnd)
    else
      return nil,format("%s is not a valid IP Address",value or "nil")
    end
  end,

  MaxAddress = function(mapping, param, value, key)
    local check = nwCommon.isIPv4(value)
    if check then
      local data = getDHCPData(key)
      local newEnd = nwCommon.ipv4ToNum(value)
      if newEnd < data.ipStart or newEnd > data.ipMax + 1 then
        return nil, "Invalid end address"
      end
      local val = newEnd-data.ipStart+1
      setUciParam("dhcp", key, "limit", val)
    else
      return nil,format("%s is not a valid IP Address",value or "nil")
    end
  end,

  SubnetMask = function(mapping, param, value, key)
    local networkSection = networkIntfTable[key]
    local check = nwCommon.isIPv4(value)
    if check then
      setUciParam("network", networkSection, "netmask", value)
    else
      return nil,format("%s is not a valid Subnet mask",value or "nil")
    end
  end,

  DomainName = function(mapping, param, value, key)
    setOnUci({extended = 1, config = "dhcp", sectionname = "@dnsmasq[0]", option = "domain"}, value, commitApply)
    binding.config = "dhcp"
    transactions[binding.config]= true
  end,

  LeaseTime = function(mapping, param, value, key)
    if value == '-1' then
      value = INFINITE -- set infinite lease time.
    end
    setUciParam("dhcp", key, "leasetime", value)
  end,

  IPRouters = function(mapping, param, value, key)
    if nwCommon.isIPv4(value) then
      dhcp.setDefaultRoute(value, key)
      binding.config = "dhcp"
      transactions[binding.config]= true
    else
      return nil,format("%s is not a valid IPv4 Address",value)
    end
  end,

  DNSServers = function(mapping, param, value, key)
    local dnsServers, msg = dhcp.parseDNSServersFromDatamodel(value, key)
    if dnsServers then
      setOnUci({ config = "dhcp", sectionname = key, option = "dhcp_option" }, dnsServers, commitApply)
      binding.config = "dhcp"
      transactions[binding.config]= true
    else
      return nil, msg
    end
  end
}

Device_DHCPv4_Server_Pool_i_.commit = function()
  for config,_ in pairs(transactions) do
    commit({config = config})
  end
  transactions = {}
end

Device_DHCPv4_Server_Pool_i_.revert = function()
  for config,_ in pairs(transactions) do
    revert({config =  config})
  end
  transactions = {}
end

register(Device_DHCPv4_Server_Pool_i_)
