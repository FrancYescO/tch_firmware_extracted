-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_DHCPv4_Server_Pool_i_ = {
  objectType = {
    name = "Device.DHCPv4.Server.Pool.{i}.",
    access = "readOnly",
    numEntriesParameter = "PoolNumberOfEntries",
    enableParameter = "Enable",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Disabled",
          "Enabled",
          "Error_Misconfigured",
          "Error",
        },
        default = "Disabled",
      },
      Interface = {
        access = "readWrite",
        type = "string",
        max = "256",
        pathRef = true,
        targetParent = "Device.IP.Interface.{i}.",
        default = "",
      },
      MinAddress = {
        access = "readWrite",
        type = "string",
      },
      MaxAddress = {
        access = "readWrite",
        type = "string",
      },
      SubnetMask = {
        access = "readWrite",
        type = "string",
      },
      DomainName = {
        access = "readWrite",
        type = "string",
        max = "64",
      },
      IPRouters = {
        access = "readWrite",
        list = true,
        maxItems = "4",
        type = "string",
      },
      LeaseTime = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
          },
        },
        default = "86400",
      },
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
        max  = "64",
      },
--[[ TODO:
      Order = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
      VendorClassID = {
        access = "readWrite",
        type = "string",
        max = "255",
        default = "",
      },
      VendorClassIDExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      VendorClassIDMode = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "Exact",
          "Prefix",
          "Suffix",
          "Substring",
        },
        default = "Exact",
      },
      ClientID = {
        access = "readWrite",
        type = "hexBinary",
        max = "255",
        default = "",
      },
      ClientIDExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      UserClassID = {
        access = "readWrite",
        type = "hexBinary",
        max = "255",
        default = "",
      },
      UserClassIDExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      Chaddr = {
        access = "readWrite",
        type = "string",
        default = "",
      },
      ChaddrMask = {
        access = "readWrite",
        type = "string",
        default = "",
      },
      ChaddrExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      ReservedAddresses = {
        access = "readWrite",
        list = true,
        maxItems = "32",
        type = "string",
        default = "",
      },
      DNSServers = {
        access = "readWrite",
        list = true,
        maxItems = "4",
        type = "string",
      },
--]]
      -- StaticAddressNumberOfEntries
      -- automatically created when Device.DHCPv4.Server.Pool.{i}.StaticAddress.{i}. is loaded
      -- OptionNumberOfEntries
      -- automatically created when Device.DHCPv4.Server.Pool.{i}.Option.{i}. is loaded
      -- ClientNumberOfEntries
      -- automatically created when Device.DHCPv4.Server.Pool.{i}.Client.{i}. is loaded
    }
  }
}

local mapper, pairs, resolve, string = mapper, pairs, resolve, string
local bit = require("bit")
local min = require("math").min
local uciHelper = mapper("ucihelper")
local getFromUci = uciHelper.get_from_uci
local getAllFromUci = uciHelper.getall_from_uci
local setOnUci = uciHelper.set_on_uci
local forEachOnUci = uciHelper.foreach_on_uci
local nwCommon = mapper("nwcommon")
local commit = uciHelper.commit
local revert = uciHelper.revert
local commitApply = commitapply

local format, sub = string.format, string.sub
local toString, toNumber = tostring, tonumber

local binding = {}

local transactions = {}
local networkIntfTable = {}

Device_DHCPv4_Server_Pool_i_.entries = function()
  local interfaces = {}
  local lan = nwCommon.findLanWanInterfaces(false)
  binding.config = "dhcp"
  binding.sectionname = "dhcp"
  forEachOnUci(binding, function(s)
    for _,v in pairs(lan) do
      if s['interface'] == v then
        interfaces[#interfaces + 1] = s['.name']
	networkIntfTable[s['.name']] = s['interface']
      end
    end
  end)
  return interfaces
end

local function getUciParam(config,sectionName,option,default)
  binding.config = config
  binding.sectionname = sectionName
  binding.default = default
  if option then
    binding.option = option
    return getFromUci(binding)
  end
  return getAllFromUci(binding)
end

local function setUciParam(config,sectionName,option,value)
  binding.config = config
  binding.sectionname = sectionName
  binding.option = option
  setOnUci(binding,value,commitApply)
  transactions[config] = true
end

local function getDHCPData(key)
  local networkSection = networkIntfTable[key]
  local networkConfig = getUciParam("network",networkSection)
  local dhcpConfig = getUciParam("dhcp",key)

  local netMask = nwCommon.ipv4ToNum(networkConfig["netmask"])
  local baseIp = nwCommon.ipv4ToNum(networkConfig["ipaddr"])
  local start = toNumber(dhcpConfig["start"] or "100")
  local numIps = toNumber(dhcpConfig["limit"] or "150")

  if baseIp == "" then
    baseIp = 0
  end
  if netMask == "" then
    netMask = 0
  end

  local network = bit.band(baseIp, netMask)
  local ipMin = network + 1
  local ipMax = bit.bor(network, bit.bnot(netMask)) - 1
  local ipStart = bit.bor(network, bit.band(start, bit.bnot(netMask)))
  local ipEnd = min(ipStart + numIps - 1, ipMax)

  return {
    ipStart = ipStart,
    ipEnd = ipEnd,
    network = network,
    ipMin = ipMin,
    ipMax = ipMax,
  }
end

local function convertTimeStringToInt(time)
  local s = time
  local factor = 1
  local endString = -2
  local unit = sub(s,-1,-1)
  local duration

  if unit == "m" then
    factor = 60
  elseif unit == "h" then
    factor = 3600
  elseif unit == "d" then
    factor = 86400
  elseif unit == "w" then
    factor = 604800
  else
    endString = -1
  end
  duration = toNumber(sub(s,1,endString)) or "86400"
  return (factor * duration)
end

local function getEnable(mapping,param,key,value)
  local check = value or getUciParam("dhcp",key,"enable")
  if check ~= "0" then
    return "1"
  end
  return "0"
end

local function getStatus(mapping,param,key)
  local status = getEnable(mapping,param,key)
  if status == "1" then
    return "Enabled"
  elseif status == "" then
    return "Error_Misconfigured"
  end
  return "Disabled"
end

local function getMinAddress(mapping, param, key)
  local networkSection = networkIntfTable[key]
  local result = getUciParam("network", networkSection, "ipaddr")
  local net = getUciParam("network", networkSection, "netmask")
  if result == "" or net == "" then
    return ""
  end
  local data = getDHCPData(key)
  return nwCommon.numToIPv4(data.ipStart) or ""
end

local function getMaxAddress(mapping,param,key)
  local networkSection = networkIntfTable[key]
  local result = getUciParam("network",networkSection,"ipaddr")
  local net = getUciParam("network",networkSection,"netmask")
  if result == "" or net == "" then
    return ""
  end
  local data = getDHCPData(key)
  return nwCommon.numToIPv4(data.ipEnd) or ""
end

Device_DHCPv4_Server_Pool_i_.get  = {
  Enable = getEnable,

  Interface = function(mapping,param,key)
    local intf = getUciParam("dhcp",key,"interface")
    return resolve('Device.IP.Interface.{i}.',intf) or ""
  end,

  Status = getStatus,

  MinAddress = getMinAddress,

  MaxAddress = getMaxAddress,

  SubnetMask = function(mapping,param,key)
    local networkSection = networkIntfTable[key]
    return getUciParam("network",networkSection,"netmask") or ""
  end,

  DomainName = function(mapping,param,key)
    local result = getFromUci({
      extended = 1, config = "dhcp" , sectionname = "@dnsmasq[0]" ,option = "domain"
    })
    return result or ""
  end,

  IPRouters = function(mapping,param,key)
    local networkSection = networkIntfTable[key]
    return getUciParam("network",networkSection,"ipaddr") or ""
  end,

  LeaseTime = function(mapping,param,key)
    local result = getUciParam("dhcp",key,"leasetime") or "12h"
    local ret = toString(convertTimeStringToInt(result))
    return ret
  end,
}

Device_DHCPv4_Server_Pool_i_.getall = function(mapping,key)
  local networkSection = networkIntfTable[key]
  local dhcpConfig = getUciParam("dhcp",key)
  local networkConfig = getUciParam("network",networkSection)

  return {
    Enable = getEnable(mapping,nil,key,dhcpConfig["enable"]),
    Status = getStatus(mapping,nil,key),
    Interface = resolve('Device.IP.Interface.{i}.',dhcpConfig["interface"]) or "",
    SubnetMask = networkConfig["netmask"] or "",
    DomainName = getFromUci({extended = 1, config = "dhcp" , sectionname = "@dnsmasq[0]" ,option = "domain"}) or "",
    IPRouters = networkConfig["ipaddr"] or "",
    MinAddress = getMinAddress(mapping,nil,key) or "",
    MaxAddress = getMaxAddress(mapping,nil,key) or "",
    LeaseTime = toString(convertTimeStringToInt(dhcpConfig["leasetime"] or "12h")) or "86400",
  }
end

Device_DHCPv4_Server_Pool_i_.set = {
  Enable = function(mapping, param, value, key)
    setUciParam("dhcp",key,"enable",value)
  end,

  Interface = function(mapping, param, value, key)
    if value ~= "" then
      local rc
      rc,value = pcall(tokey,value,"Device.IP.Interface.{i}.")
      if not rc then
        return nil ,"invalid value"
      end
    end
    setUciParam("dhcp",key,"interface",value)
  end,

  MinAddress = function(mapping, param, value, key)
    local check = nwCommon.isIPv4(value)
    if check then
      local data = getDHCPData(key)
      local start = nwCommon.ipv4ToNum(value)
      local newStart = start - data.network
      local newEnd  = data.ipEnd - start + 1
        if start < data.ipMin or start >= data.ipEnd then
          return nil, "Invalid start address"
        end
      setUciParam("dhcp",key,"start",newStart)
      setUciParam("dhcp",key,"limit",newEnd)
    else
      return nil,format("%s is not a valid IP Address",value or "nil")
    end
  end,

  MaxAddress = function(mapping, param, value, key)
    local check = nwCommon.isIPv4(value)
    if check then
      local data = getDHCPData(key)
      local newEnd = nwCommon.ipv4ToNum(value)
      if newEnd < data.ipStart or newEnd > data.ipMax + 1 then
        return nil, "Invalid end address"
      end
      local val = newEnd-data.ipStart+1
      setUciParam("dhcp",key,"limit",val)
    else
      return nil,format("%s is not a valid IP Address",value or "nil")
    end
  end,

  SubnetMask = function(mapping,param,value,key)
    local networkSection = networkIntfTable[key]
    local check = nwCommon.isIPv4(value)
    if check then
      setUciParam("network",networkSection,"netmask",value)
    else
      return nil,format("%s is not a valid Subnet mask",value or "nil")
    end
  end,

  DomainName = function(mapping,param,value,key)
    setOnUci({extended = 1, config = "dhcp" , sectionname = "@dnsmasq[0]" ,option = "domain"},value,commitApply)
    binding.config = "dhcp"
    transactions[binding.config]= true
  end,

  LeaseTime = function(mapping,param,value,key)
    setUciParam("dhcp",key,"leasetime",value)
  end,

  IPRouters = function(mapping,param,value,key)
    local networkSection = networkIntfTable[key]
    local check = nwCommon.isIPv4(value)
    if check then
      setUciParam("network",networkSection,"ipaddr",value)
    else
      return nil,format("%s is not a valid IP address",value or "nil")
    end
  end,
}

Device_DHCPv4_Server_Pool_i_.commit = function()
  for config,_ in pairs(transactions) do
    commit({config = config})
  end
  transactions = {}
end

Device_DHCPv4_Server_Pool_i_.revert = function()
  for config,_ in pairs(transactions) do
    revert({config =  config})
  end
  transactions = {}
end

register(Device_DHCPv4_Server_Pool_i_)
