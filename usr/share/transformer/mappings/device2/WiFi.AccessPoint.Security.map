-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_WiFi_AccessPoint_i_Security_ = {
  objectType = {
    name = "Device.WiFi.AccessPoint.{i}.Security.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      Reset = {
        access = "readWrite",
        command = "true",
        type = "boolean",
      },
      ModesSupported = {
        access = "readOnly",
        list = true,
        type = "string",
        enumeration = {
          "None",
          -- "WEP-64",  -- "wep" mode is not supported
          -- "WEP-128",
          "WPA-Personal",
          "WPA2-Personal",
          "WPA-WPA2-Personal",
          "WPA-Enterprise",
          "WPA2-Enterprise",
          "WPA-WPA2-Enterprise",
	  "WPA3-Personal",
	  "WPA3-Personal-Transition",
	  "WPA3-Enterprise",
        },
      },
      ModeEnabled = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "None",
          -- "WEP-64",  -- "wep" mode is not supported
          -- "WEP-128",
          "WPA-Personal",
          "WPA2-Personal",
          "WPA-WPA2-Personal",
          "WPA-Enterprise",
          "WPA2-Enterprise",
          "WPA-WPA2-Enterprise",
	  "WPA3-Personal",
          "WPA3-Personal-Transition",
          "WPA3-Enterprise",
        },
      },
--[[  "wep" mode is not supported
      WEPKey = {
        access = "readWrite",
        hidden = "true",
        type = "string", -- Both ASCII(5 and 13 CS) and Hex(10 and 26 CS) is supported
        min = "5",
        max = "26",
      },
--]]
      PreSharedKey = {
        access = "readWrite",
        hidden = "true",
        type = "hexBinary",
        max = "32",
      },
      SAEPassphrase = {
	access = "readWrite",
        type = "string",
        min = "8",
        max = "63",
      },
      KeyPassphrase = {
        access = "readWrite",
        hidden = "true",
        type = "string",
        min = "8",
        max = "63",
      },
      RekeyingInterval = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "80",
            max = "846000",
          },
        },
        default = "3600",
      },
      RadiusServerIPAddr = {
        access = "readWrite",
        type = "string",
      },
      SecondaryRadiusServerIPAddr  = {
        access = "readWrite",
        type = "string",
      },
      RadiusServerPort = {
        access = "readWrite",
        type = "unsignedInt",
        default = "1812",
      },
      SecondaryRadiusServerPort = {
        access = "readWrite",
        type = "unsignedInt",
        default = "1812",
      },
      RadiusSecret = {
        access = "readWrite",
        hidden = "true",
        type = "string",
      },
      SecondaryRadiusSecret = {
        access = "readWrite",
        hidden = "true",
        type = "string",
      },
      X_TELUS_DefaultKeyPassphrase = {
        access = "readOnly",
        type = "boolean",
        description = "Indicates whether the WiFi radio is set to the factory default passphrase, 1 indicates passphrase is set to default value",
      },
      X_DT_EncryptedKeyPassphrase = {
        access = "readOnly",
        type = "string",
        description = "The Wifi WPA KeyPassphrase in encrypted format",
      },
      X_TELSTRA_AuthSuccess = {
        access = "readOnly",
        type = "unsignedInt",
        description = "To display the count of successful Wifi authentication",
      },
      X_TELSTRA_AuthFail = {
        access = "readOnly",
        type = "unsignedInt",
        description = "To display the count of failure Wifi authentication",
      },
      X_TELSTRA_AuthFailMACAddress = {
        access = "readOnly",
        type = "string",
        description = "To list the failure Wifi authentication macaddresses",
      },
    }
  }
}

local inet = require 'tch.inet'
local wifisecurity = require 'transformer.shared.custo.wifisecurity'
local mapper, string, next, register = mapper, string, next, register
local uciHelper = mapper("ucihelper")
local getFromUci = uciHelper.get_from_uci
local getAllFromUci = uciHelper.getall_from_uci
local setOnUci = uciHelper.set_on_uci
local conn = mapper("ubus").connect()
local wirelessBinding = {config = "wireless"}
local gmatch, match = string.gmatch, string.match
local concat, commitApply = table.concat, commitapply
local bandSteerHelper = require("transformer.shared.bandsteerhelper")
local setSecurityOption = bandSteerHelper.setSecurityOption
local envBinding = {config = "env"}
local process = require("tch.process")
local multiapControllerBinding = {config='multiap', sectionname='controller', option='enabled'}
local multiapAgentBinding = {config='multiap', sectionname='agent', option='enabled'}
local lcrypto = require("lcrypto")
local crypto = require("tch.crypto")
local BASE64_DIGITS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

local function encode_base64(text)
  local result = ""
  for in_1, in_2, in_3 in text:gmatch("(.)(.?)(.?)") do
    local value = in_1:byte() * 65536 + (in_2:byte() or 0) * 256 + (in_3:byte() or 0)
    local out_1 = math.floor(value / 262144) % 64 + 1
    local out_2 = math.floor(value / 4096) % 64 + 1
    result = result .. BASE64_DIGITS:sub(out_1, out_1) .. BASE64_DIGITS:sub(out_2, out_2)
    if in_2 ~= "" then
      local out_3 = math.floor(value / 64) % 64 + 1
      result = result .. BASE64_DIGITS:sub(out_3, out_3)
      if in_3 ~= "" then
        local out_4 = value % 64 + 1
        result = result .. BASE64_DIGITS:sub(out_4, out_4)
      else
        result = result .. "="
      end
    else
      result = result .. "=="
    end
  end
  return result
end

local transactions = {}

local supportedModesMap = {
  ["none"]          = "None",
  ["wep"]           = "None",  -- "wep" mode is not supported
  ["wpa2-psk"]      = "WPA2-Personal",
  ["wpa-wpa2-psk"]  = "WPA-WPA2-Personal",
  ["wpa2"]          = "WPA2-Enterprise",
  ["wpa-wpa2"]      = "WPA-WPA2-Enterprise",
  ["wpa3-psk"]      = "WPA3-Personal",
  ["wpa2-wpa3-psk"] = "WPA3-Personal-Transition",
  ["wpa3"]          = "WPA3-Enterprise"
}

local accessSecurityUciMap = {
  ["None"] = "none",
  -- ["WEP-64"] = "wep",  -- "wep" mode is not supported
  ["WPA2-Personal"] = "wpa2-psk",
  ["WPA-WPA2-Personal"] = "wpa-wpa2-psk",
  ["WPA2-Enterprise"] = "wpa2",
  ["WPA-WPA2-Enterprise"] = "wpa-wpa2",
  ["WPA3-Personal"] = "wpa3-psk",
  ["WPA3-Personal-Transition"] = "wpa2-wpa3-psk",
  ["WPA3-Enterprise"] = "wpa3",
}

local accessSecurityMap = {
  ["ModeEnabled"] = "security_mode",
  -- ["WEPKey"] = "wep_key",  -- "wep" mode is not supported
  ["PreSharedKey"] = "wpa_psk_key",
  ["KeyPassphrase"] = "wpa_psk_key",
}

-- Map table to set server(Y = 0/1)
--   0 primary
--   1 secondary
local enterpriseMap = {
  ["RadiusServerIPAddr"] = "0",
  ["RadiusServerPort"] = "0",
  ["RadiusSecret"] = "0",
  ["SecondaryRadiusServerIPAddr"] = "1",
  ["SecondaryRadiusServerPort"] = "1",
  ["SecondaryRadiusSecret"] = "1",
}

local function getEnvUciValue(sectionName, paramName)
  envBinding.sectionname = sectionName
  envBinding.option = paramName
  return getFromUci(envBinding)
end

local function getSupportedModesFromUbus(key)
  local data = conn:call("wireless.accesspoint.security", "get", { name = key }) or {}
  return data[key] and data[key].supported_modes or ""
end

local function getModesSupported(supportedModes, key)
  if not supportedModes then
    supportedModes = getSupportedModesFromUbus(key)
  end
  if supportedModes ~= "" then
    local modes = {}
    for mode in gmatch(supportedModes, "%S+") do
      if mode ~= "wep" then  -- "wep" mode is not supported, so skipping if it is populated from UCI
        if (not string.match(supportedModesMap[mode] ,"Enterprise") and getFromUci(multiapAgentBinding) == "1" and getFromUci(multiapControllerBinding) == "1") or (getFromUci(multiapAgentBinding) == "0" or getFromUci(multiapControllerBinding) == "0") then
          modes[#modes + 1] = supportedModesMap[mode]
        end
      end
    end
    return concat(modes, ",")
  end
  return ""
end

local function getDNS(fqdn)
  local addr
  local pipe = process.popen("dnsget", {fqdn})
  for line in pipe:lines() do
    addr = match(line,"%s+(%d+%.%d+%.%d+%.%d+)")
  end
  pipe:close()
  return addr
end

local function getUciValue(sectionName, paramName)
  wirelessBinding.sectionname = sectionName
  if paramName then
    wirelessBinding.option = paramName
    return getFromUci(wirelessBinding)
  end
  return getAllFromUci(wirelessBinding)
end

local function getEnterpriseValues(key, param, server)
  local value
  local sectionName = key.."_".."auth"..server
  if param == "RadiusServerIPAddr" or param == "SecondaryRadiusServerIPAddr" then
    local fqdn = getUciValue(sectionName, "fqdn")
    if fqdn ~= "" then
      value = getDNS(fqdn)
    else
      value = getUciValue(sectionName,"ip")
    end
  elseif param == "RadiusServerPort" or param == "SecondaryRadiusServerPort" then
    value = getUciValue(sectionName, "port") or "1812"
  elseif param == "RadiusSecret" or param == "SecondaryRadiusSecret" then
    value = getUciValue(sectionName, "secret")
  end
  return value
end

local function defaultPassphrase(key)
  local wpaPskKey = getUciValue(key, "wpa_psk_key")
  local defaultKey
  if key == "ap0" or key == "ap2" or key == "ap5" then
    defaultKey = getEnvUciValue("var", "default_key_r0_s0")
  elseif key == "ap1" or key == "ap3" or key == "ap6" then
    defaultKey = getEnvUciValue("var", "default_key_r0_s1")
  elseif key == "ap4" then
    defaultKey = getEnvUciValue("var", "default_key_r0_s3")
  elseif key == "ap7" then
    defaultKey = getEnvUciValue("var", "default_key_r0_s2")
  end
  return (defaultKey == wpaPskKey) and "1" or "0"
end

local function hexToByte(shaValue)
  return (shaValue:gsub('..', function (data)
    return string.char(tonumber(data, 16))
  end))
end

local function keyEncrypt(password)
  local encryptionKey = getUciValue("global", "provisioned_key")
  if encryptionKey ~= "" then
    local shaResult = crypto.sha256(encryptionKey)
    local decodeHex = hexToByte(shaResult)
    decodeHex = decodeHex:sub(1, 32)
    local result, err = lcrypto.encrypt("AES-256-ECB", decodeHex, NULL, password)
    if not result then
      return nil, err
    end
    return result and encode_base64(result) or ""
  end
  return ""
end

local function createSection(sectionType, sectionName)
  wirelessBinding.sectionname = sectionName
  wirelessBinding.option = nil
  setOnUci(wirelessBinding, sectionType, commitApply)
  transactions[wirelessBinding.config] = true
end

local function setUciParam(sectionName, paramName, value)
  wirelessBinding.sectionname = sectionName
  wirelessBinding.option = paramName
  setOnUci(wirelessBinding, value, commitApply)
  transactions[wirelessBinding.config] = true
end

local function getIntervalValue(key, modeEnabled)
  local value = ""
  if modeEnabled ~= "none" and modeEnabled ~= "wep" then
    value = getUciValue(key, "eap_reauth_period")
  end
  if value == "" then
    local data = conn:call("wireless.accesspoint.security", "get",  { }) or {}
    if data[key] and data[key]["eap_reauth_period"] then
      value = data[key]["eap_reauth_period"]
    end
  end
  return value ~= "" and tostring(value) or "3600"
end

--- @function setIntervalvalue will set the value for RekeyingInterval
--- @if condition will check the security_mode and will not allow to set when mode is none/wep
local function setIntervalvalue(key, option, value)
  local uciValues = getUciValue(key)
  if  uciValues["security_mode"] ~= "none" and  uciValues["security_mode"] ~= "wep" then
    return setUciParam(key, "eap_reauth_period", value)
  end
  return nil, "Cannot set RekeyingInterval when securityMode is none"
end

local function getCountAndMAC(state, key)
  local result = conn:call("wireless.accesspoint.station", "get", { name = key })
  local macAddresses = {}
  for _, mac in pairs(result) do
    for macAdd, data in pairs(mac) do
      if data["last_wpahandshake_status"] == state then
        macAddresses[#macAddresses + 1] = macAdd
      end
    end
  end
  return tostring(#macAddresses), table.concat(macAddresses, ",")
end

Device_WiFi_AccessPoint_i_Security_.get = function(mapping, param, key)
  local isEnterpriseMode = false
  local uciSecurityValues = getUciValue(key)
  local modeName = uciSecurityValues["security_mode"] and supportedModesMap[uciSecurityValues["security_mode"]]

  if modeName then
    isEnterpriseMode = match(modeName, "Enterprise") and true or false
  end
  if param == "Reset" then
    return "0"
  elseif param == "ModesSupported" then
    return getModesSupported(uciSecurityValues["supported_security_modes"], key)
  elseif param == "ModeEnabled" then
    return (modeName and modeName or "")
  elseif param == "RekeyingInterval" then
    return getIntervalValue(key, uciSecurityValues["security_mode"])
  elseif accessSecurityMap[param] then
    return uciSecurityValues[accessSecurityMap[param]] or ""
  elseif enterpriseMap[param] then
    return (isEnterpriseMode and getEnterpriseValues(key, param, enterpriseMap[param]) or "" )
  elseif param == "X_TELUS_DefaultKeyPassphrase" then
    return defaultPassphrase(key)
  elseif param == "SAEPassphrase" then
    return ""
  elseif param == "X_DT_EncryptedKeyPassphrase" then
    return keyEncrypt(uciSecurityValues["wpa_psk_key"]) or ""
  elseif param == "X_TELSTRA_AuthSuccess" then
    return getCountAndMAC("Success", key)
  elseif param == "X_TELSTRA_AuthFail" then
    return getCountAndMAC("Failure", key)
  elseif param == "X_TELSTRA_AuthFailMACAddress" then
    local _, mac = getCountAndMAC("Failure", key)
    return mac
  end
end

Device_WiFi_AccessPoint_i_Security_.getall = function(mapping, key)
  local isEnterpriseMode = false
  local primValues,ipAddrPrim,secValues,ipAddrSec
  local uciSecurityValues = getUciValue(key)
  local modeEnabled = uciSecurityValues["security_mode"] and uciSecurityValues["security_mode"]
  local rekeyingInterval = getIntervalValue(key, modeEnabled)
  if modeEnabled and supportedModesMap[modeEnabled] then
    isEnterpriseMode = match(supportedModesMap[modeEnabled],"Enterprise") and true or false
  end

  if isEnterpriseMode then
    local sectionName = key.."_".."auth".."0"
    primValues = getUciValue(sectionName)
    if primValues.fqdn then
      ipAddrPrim = getDNS(primValues["fqdn"])
    else
      ipAddrPrim = primValues["ip"]
    end
    sectionName = key.."_".."auth".."1"
    secValues = getUciValue(sectionName)
    if secValues.fqdn then
      ipAddrSec = getDNS(secValues["fqdn"])
    else
      ipAddrSec = secValues["ip"]
    end
  end

  return {
    Reset = "0",
    ModeEnabled = supportedModesMap[modeEnabled] or "",
    -- WEPKey = uciSecurityValues["wep_key"] or "",  -- "wep" mode is not supported. To be uncommented if "wep" mode support is requested.
    PreSharedKey = uciSecurityValues["wpa_psk_key"] or "",
    KeyPassphrase = uciSecurityValues["wpa_psk_key"] or "",
    ModesSupported = getModesSupported(uciSecurityValues["supported_security_modes"], key),
    RadiusServerIPAddr = isEnterpriseMode and ipAddrPrim or "",
    RekeyingInterval = rekeyingInterval,
    RadiusServerPort = isEnterpriseMode and primValues["port"] or "1812",
    RadiusSecret = isEnterpriseMode and primValues["secret"] or "",
    SecondaryRadiusServerIPAddr = isEnterpriseMode and ipAddrSec or "",
    SecondaryRadiusServerPort = isEnterpriseMode and secValues["port"] or "1812",
    SecondaryRadiusSecret = isEnterpriseMode and secValues["secret"] or "",
    SAEPassPhrase = "",
    X_DT_EncryptedKeyPassphrase = keyEncrypt(uciSecurityValues["wpa_psk_key"]) or "",
  }
end

local function setRadiusValue(ap, server, option, value)
  local sectionName = ap.."_".."auth"..server
  local section = getUciValue(sectionName)
  if not section['.name'] then
    createSection("wifi-radius-server", sectionName)
  end
  setUciParam(sectionName, option, value)
end

local function setRadiusIP(ap, server, ip)
  local kind = inet.isValidIP(ip)
  if kind == "IPv4" then
    if ip == "0.0.0.0" then
      setRadiusValue(ap, server, "state", "0")
    else
      setRadiusValue(ap, server, "state", "1")
    end
    return setRadiusValue(ap, server, "ip", ip)
  elseif kind == "IPv6" then
    return nil, "only IPv4 values supported"
  else
    return nil, "invalid IP address"
  end
end

local function setRadiusPort(ap, server, port)
  if tonumber(port)>65535 then
    return "port number out of range"
  end
  return setRadiusValue(ap, server, "port", port)
end

local function setRadiusSecret(ap, server, secret)
  if #secret>64 then
    return nil, "secret value too long"
  end
  return setRadiusValue(ap, server, "secret", secret)
end

local function setPmfValue(key, modeAsPerUci)
  if modeAsPerUci == "wpa3-psk" then
    setUciParam(key, "pmf", "required")
  elseif modeAsPerUci == "wpa2-wpa3-psk" then
    setUciParam(key, "pmf", "enabled")
  else
    setUciParam(key, "pmf", "disabled")
  end
end

local function setModeEnabled(value, key, commitapply, transactions)
  local supportedModes = getUciValue(key, "supported_security_modes")
  if supportedModes == "" then
    supportedModes = getSupportedModesFromUbus(key)
  end
  local modeAsPerUci = accessSecurityUciMap[value]
  if supportedModes == "" then
    local ret = setSecurityOption(key, "security_mode", modeAsPerUci, commitapply, transactions)
    if ret then
      setPmfValue(key, modeAsPerUci)
    end
    return ret
  else
    for mode in gmatch(supportedModes, "([^%s]+)") do
      if mode == modeAsPerUci then
        local ret = setSecurityOption(key, "security_mode", modeAsPerUci, commitapply, transactions)
        if ret then
          setPmfValue(key, modeAsPerUci)
        end
        return ret
      end
    end
    return nil, value.." Mode is currently not supported"
  end
end

local function setPassPhrase(value, key)
  local uciSecurityValues = getUciValue(key, "security_mode")
  local modeName = supportedModesMap[uciSecurityValues] or ""
  local sectionName =  key.."_".."credential0"
  if modeName == "WPA3-Personal" or modeName == "WPA3-Personal-Transition" then
    setUciParam(sectionName, "passphrase", value)
    setUciParam(key, "wpa_psk_key", value)
    return true
  end
  return nil, "SAEPassphrase will be set only if ModeEnabled is either WPA3-Personal or WPA3-Personal-Transition"
end

Device_WiFi_AccessPoint_i_Security_.set = {
  Reset = function(_, _, value, key)
    if value == '1' then
      if bandSteerHelper.isMultiapEnabled(key) then
        return nil, "Cannot modify the value when easymesh is enabled"
      end
      local result,errmsg = wifisecurity.reset(key, commitApply)
      if result then
        transactions[wirelessBinding.config] = true
      else
        return nil, errmsg
      end
    end
  end,
  ModeEnabled = function(_, _, value, key)
    if getFromUci(multiapControllerBinding) == "1" and getFromUci(multiapAgentBinding) == "1" then
      return nil, "Cannot modify the value when easymesh is enabled"
    end
    return setModeEnabled(value, key, commitapply, transactions)
  end,
  PreSharedKey = function(_, _, value, key)
    if getFromUci(multiapControllerBinding) == "1" and getFromUci(multiapAgentBinding) == "1" then
      return nil, "Cannot modify the value when easymesh is enabled"
    end
    return setSecurityOption(key, "wpa_psk_key", value, commitapply, transactions)
  end,
  KeyPassphrase = function(_, _, value, key)
    if getFromUci(multiapControllerBinding) == "1" and getFromUci(multiapAgentBinding) == "1" then
      return nil, "Cannot modify the value when easymesh is enabled"
    end
    return setSecurityOption(key, "wpa_psk_key", value, commitapply, transactions)
  end,
  SAEPassphrase = function(_, _, value, key)
    return setPassPhrase(value, key)
  end,
  RadiusServerIPAddr = function(_, _, value, key)
    return setRadiusIP(key, "0", value)
  end,
  RekeyingInterval = function(_, _, value, key)
    return setIntervalvalue(key, "eap_reauth_period", value)
  end,
  SecondaryRadiusServerIPAddr = function(_, _, value, key)
    return setRadiusIP(key, "1", value)
  end,
  RadiusServerPort = function(_, _, value, key)
    return setRadiusPort(key, "0", value)
  end,
  SecondaryRadiusServerPort = function(_, _, value, key)
    return setRadiusPort(key, "1", value)
  end,
  RadiusSecret = function(_, _, value, key)
    return setRadiusSecret(key, "0", value)
  end,
  SecondaryRadiusSecret = function(_, _, value, key)
    return setRadiusSecret(key, "1", value)
  end,
}

local function endTransaction(action)
  for config in pairs(transactions) do
    action({config = config})
  end
  transactions = {}
end

Device_WiFi_AccessPoint_i_Security_.commit = function()
  return endTransaction(uciHelper.commit)
end

Device_WiFi_AccessPoint_i_Security_.revert = function()
  return endTransaction(uciHelper.revert)
end

local function setUciEvent(mapping, action, config, sectionType, sectionName, option)
  return { { key = sectionName, paramname = "ModeEnabled" } }
end

Device_WiFi_AccessPoint_i_Security_.add_watchers = function(mapping, param, key)
  local uciEventSource = eventsource("uci")
  uciEventSource.watch(mapping, { set = setUciEvent }, "wireless", "wifi-ap", key, "security_mode")
end

register(Device_WiFi_AccessPoint_i_Security_)
