-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_DNS_Client_Server_i_ = {
  objectType = {
    name = "Device.DNS.Client.Server.{i}.",
    access = "readOnly", -- readWrite not supported
    numEntriesParameter = "ServerNumberOfEntries",
    enableParameter = "Enable",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readOnly", -- no way to enable/disable the DNS server in GW
        type = "boolean",
        default = "false",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Disabled",
          "Enabled",
          "Error",
        },
        default = "Disabled",
      },
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
        max = "64",
      },
      DNSServer = {
        access = "readWrite",
        type = "string",
      },
      Interface = {
        access = "readOnly", --readwrite not supported
        type = "string",
        max = "256",
        pathRef = true,
        targetParent = "Device.IP.Interface.{i}.",
        default = "",
      },
      Type = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "DHCPv4",
          "DHCPv6",
          "RouterAdvertisement",
          "IPCP",
          "Static",
        },
        default = "Static",
      },
    }
  }
}

local mapper = mapper
local resolve = resolve
local pairs = pairs
local nwCommon = mapper('nwcommon')
local uciHelper = mapper("ucihelper")
local ubusConnection = mapper("ubus").connect()
local getFromUci = uciHelper.get_from_uci
local networkBinding = { config = "network" }
local isConfigChanged = false
local keyMap = {}

local typeMap = {
  ["static"] = "Static",
  ["dhcp"] = "DHCPv4",
  ["dhcpv6"] = "DHCPv6",
  ["ppp"] = "IPCP",
  ["pppoe"] = "IPCP",
  ["pppoa"] = "IPCP",
}

local function ifExists(interface, dnsValue)
  for _,v in pairs(keyMap) do
    if v and v.interface == interface and v.dnsServer == dnsValue then
      return true
    end
  end
  return false
end

Device_DNS_Client_Server_i_.entries = function()
  keyMap = {}
  local count = 0
  local dnsClientServerEntries = {}
  local wanInterfaces = nwCommon.findLanWanInterfaces(true)
  for _,v in pairs(wanInterfaces) do
    local ubusStatus = ubusConnection:call("network.interface." .. v, "status", {})
    if ubusStatus and ubusStatus["dns-server"] then
      for _,dnsServerEntry in pairs(ubusStatus["dns-server"]) do
        if not ifExists(v, dnsServerEntry) then
          local keyEntry = v..count
          count = count + 1
          dnsClientServerEntries[#dnsClientServerEntries+1] = keyEntry
          keyMap[keyEntry] = { interface = v, dnsServer = dnsServerEntry }
        end
      end
    end
  end
  return dnsClientServerEntries
end

local function getUciValue(key, option)
  networkBinding.sectionname = key
  networkBinding.option = option
  return getFromUci(networkBinding) or ""
end

Device_DNS_Client_Server_i_.get = {
  Enable = "1",

  Status = "Enabled",

  DNSServer = function(mapping, param, key)
    return keyMap[key].dnsServer
  end,

  Interface = function(mapping, param, key)
    return resolve("Device.IP.Interface.{i}.",keyMap[key].interface) or ""
  end,

  Type = function(mapping, param, key)
    return typeMap[getUciValue(keyMap[key].interface, "proto")] or ""
  end,
}

Device_DNS_Client_Server_i_.getall = function(mapping, key)
  return {
    Enable = "1",
    Status = "Enabled",
    DNSServer = keyMap[key].dnsServer,
    Interface = resolve("Device.IP.Interface.{i}.",keyMap[key].interface) or "",
    Type = typeMap[getUciValue(keyMap[key].interface, "proto")] or "",
  }
end

local function setDNSServer(value, dnsServer, interface, key)
  local isFlag = false
  if nwCommon.isIPv4(value) then
    local result = getUciValue(interface, "dns")
    if result ~= "" then
      local dnsServers = {}
      -- iterating over the list of dns-servers and modifying the DNS Server to the given DNS Server value
      for _,v in pairs(result) do
        if v == value then
          isFlag = true
        elseif v == dnsServer then
          dnsServers[#dnsServers+1] = value
        elseif v ~= dnsServer then
          dnsServers[#dnsServers+1] = v
        end
      end
      if isFlag then
        return false, "The given DNS Server is already present"
      end
      networkBinding.sectionname = interface
      networkBinding.option = "dns"
      uciHelper.set_on_uci(networkBinding,dnsServers,commitapply)
      isConfigChanged = true
      return true
    end
  else
    return false, "Not a valid ip address"
  end
end

Device_DNS_Client_Server_i_.set = {
  DNSServer = function(mapping, param, value, key)
    if (typeMap[getUciValue(keyMap[key].interface, "proto")] == "Static") then
      if value == keyMap[key].dnsServer then
        return nil, "The DNS Server to be modified is same as the existing DNS server"
      else
        local success, error = setDNSServer(value, keyMap[key].dnsServer, keyMap[key].interface, key)
        if not success then
          return nil,error
        end
      end
    else
      return nil,"DNSServer value cannot be modified since the protocol is not Static"
    end
  end
}

Device_DNS_Client_Server_i_.commit = function()
  if isConfigChanged then
    uciHelper.commit(networkBinding)
    isConfigChanged = false
  end
end

Device_DNS_Client_Server_i_.revert = function()
  if isConfigChanged then
    uciHelper.revert(networkBinding)
    isConfigChanged = false
  end
end

register(Device_DNS_Client_Server_i_)
