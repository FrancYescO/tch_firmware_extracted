-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_IP_Interface_i_IPv6Address_i_ = {
  objectType = {
    name = "Device.IP.Interface.{i}.IPv6Address.{i}.",
    access = "readOnly",
    numEntriesParameter = "IPv6AddressNumberOfEntries",
    enableParameter = "Enable",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readOnly",  --readWrite not supported
        type = "boolean",
        default = "false",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Disabled",
          "Enabled",
          "Error_Misconfigured",
          "Error",
        },
        default = "Disabled",
      },
--[[ TODO
      IPAddressStatus = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Preferred",
          "Deprecated",
          "Invalid",
          "Inaccessible",
          "Unknown",
          "Tentative",
          "Duplicate",
          "Optimistic",
        },
        default = "Invalid",
      },
--]]
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
        max = "64",
     },
     IPAddress = {
        access = "readWrite",
        type = "string",
        default = "",
      },
--[[ TODO
      Origin = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "AutoConfigured",
          "DHCPv6",
          "WellKnown",
          "Static",
        },
        default = "Static",
      },
--]]
      Prefix = {
        access = "readOnly", --readWrite not supported
        type = "string",
        pathRef = true,
        targetParent = "Device.IP.Interface.{i}.IPv6Prefix.{i}.",
        default = "",
      },
      PreferredLifetime = {
        access = "readOnly", --readWrite not supported
        type = "dateTime",
        default = "9999-12-31T23:59:59Z",
      },
      ValidLifetime = {
        access = "readOnly", --readWrite not supported
        type = "dateTime",
        default = "9999-12-31T23:59:59Z",
      },
--[[ TODO
      Anycast = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
--]]
    }
  }
}

local ubusConnection = mapper("ubus").connect()
local networkBinding = {config="network"}
local format = string.format
local isConfigChanged = false
local uciHelper = mapper("ucihelper")
local commitApply = commitapply

Device_IP_Interface_i_IPv6Address_i_.entries = function(mapping, parentkey)
  local ubusStatus = ubusConnection:call("network.interface." .. parentkey , "status", {})
  if ubusStatus and (ubusStatus["ipv6-address"] and next(ubusStatus["ipv6-address"])) or (ubusStatus["ipv6-prefix"] and next(ubusStatus["ipv6-prefix"])) or (ubusStatus["ipv6-prefix-assignment"] and next(ubusStatus["ipv6-prefix-assignment"])) then
    return {parentkey}
  end
  return {}
end

local function getStatus(key,ubusStatus)
  ubusStatus = ubusStatus or ubusConnection:call("network.interface." .. key,"status",{})
  return ubusStatus.up and "Enabled" or "Disabled"
end

local function getIPAddress(key,ubusStatus)
  ubusStatus = ubusStatus or ubusConnection:call("network.interface." .. key,"status",{})
  if ubusStatus and ubusStatus["ipv6-address"] and ubusStatus["ipv6-address"][1] then
    return ubusStatus["ipv6-address"][1]["address"] or ""
  end
  return ""
end

local function getPrefix(key)
  return resolve("Device.IP.Interface.{i}.IPv6Prefix.{i}.",key) or ""
end

local function getPreferredLifetime(key,ubusStatus)
  ubusStatus = ubusStatus or ubusConnection:call("network.interface." .. key,"status",{})
  if ubusStatus and ubusStatus["ipv6-address"] and ubusStatus["ipv6-address"][1] then
    if ubusStatus["ipv6-address"][1]["preferred"] then
      return os.date("%Y-%m-%dT%H:%M:%SZ",os.time()+ ubusStatus["ipv6-address"][1]["preferred"])
    end
  end
  return "9999-12-31T23:59:59Z"
end

local function getValidLifetime(key,ubusStatus)
  ubusStatus = ubusStatus or ubusConnection:call("network.interface." .. key,"status",{})
  if ubusStatus and ubusStatus["ipv6-address"] and ubusStatus["ipv6-address"][1] then
    if ubusStatus["ipv6-address"][1]["valid"] then
      return os.date("%Y-%m-%dT%H:%M:%SZ",os.time()+ ubusStatus["ipv6-address"][1]["valid"])
    end
  end
  return "9999-12-31T23:59:59Z"
end

--getterTable is used as suggested in review #18675 to use the same functions to fetch value in both get and getall.
--As parentkey will come after key in function(mapping,param,key) declaration it is difficult to pass ubusStatus after
--key. So, to adapt the functions accordingly this getterTable is needed.

local getterTable = {
  Status = getStatus,
  IPAddress = getIPAddress,
  Prefix = getPrefix,
  PreferredLifetime = getPreferredLifetime,
  ValidLifetime = getValidLifetime
}

Device_IP_Interface_i_IPv6Address_i_.get = function(mapping,param,key)
  if param == "Enable" then
    return "1"
  else
    return getterTable[param](key)
  end
end

Device_IP_Interface_i_IPv6Address_i_.getall = function(mapping,key)
  local ubusStatus = ubusConnection:call("network.interface." .. key,"status",{})
  return {
    Enable = "1",
    Status = getStatus(key,ubusStatus),
    IPAddress = getIPAddress(key,ubusStatus),
    Prefix = getPrefix(key),
    PreferredLifetime = getPreferredLifetime(key,ubusStatus),
    ValidLifetime = getValidLifetime(key,ubusStatus)
  }
end

local function isValidIP6(ip)
  if ip:find(":::") then
    return false
  end
  if ip:match("^:") then
    if not ip:match("^::") then
      return false
    end
  end
  if ip:find('/') then
    local subnet
    ip,subnet = ip:match("^(.*)/(%d+)$")
    if not ip or not subnet or tonumber(subnet) > 128 then
      return false
    end
  end
  if ip:match(":$") then
    return false
  end
  local addr,count = string.gsub(ip , "::",":")
  if count > 1 then
    return false
  end
  if not addr:match("^[a-fA-F0-9:]+$") then
    return false
  end
  local numBlocks = 0
  for i in addr:gmatch("[a-fA-F0-9]+",":") do
    numBlocks = numBlocks +1
    if (not i) or (4 < #i) or (#i < 1) then
      return false
    end
  end
  if count == 0 and numBlocks ~= 8 then
    return false
  end
  if count == 1 and numBlocks > 6 then
    return false
  end
  return true
end

local function setUciParam(paramName, value, key)
  networkBinding.sectionname=key
  networkBinding.option=paramName
  uciHelper.set_on_uci(networkBinding, value, commitApply)
  isConfigChanged = true
end

Device_IP_Interface_i_IPv6Address_i_.set = {
  IPAddress = function(mapping,param,value,key)
    local ubusStatus = ubusConnection:call("network.interface." .. key,"status",{})
    if ubusStatus and ubusStatus.proto == "static" then
      if isValidIP6(value) then
        setUciParam("ip6addr",value,key)
      else
        return nil, "Not a valid IPv6 address"
      end
    else
      return nil, format("setting IPv6 address is not allowed: protocol is not static")
    end
  end
}

Device_IP_Interface_i_IPv6Address_i_.commit = function()
  if isConfigChanged then
    uciHelper.commit(networkBinding)
    isConfigChanged = false
  end
end

Device_IP_Interface_i_IPv6Address_i_.revert = function()
  if isConfigChanged then
    uciHelper.revert(networkBinding)
    isConfigChanged = false
  end
end

local function setUbusEvent(mapping, action, data)
  if data["ipv6-address"] then
    return { { key = data["interface"], paramname = "IPAddress" } }
  end
end

Device_IP_Interface_i_IPv6Address_i_.add_watchers = function(mapping)
  local ubusEventSource = eventsource("ubus")
  ubusEventSource.watch_event(mapping, setUbusEvent, "network.interface")
end

register(Device_IP_Interface_i_IPv6Address_i_)

