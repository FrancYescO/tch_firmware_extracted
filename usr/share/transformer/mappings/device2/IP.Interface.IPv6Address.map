-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_IP_Interface_i_IPv6Address_i_ = {
  objectType = {
    name = "Device.IP.Interface.{i}.IPv6Address.{i}.",
    access = "readOnly",
    numEntriesParameter = "IPv6AddressNumberOfEntries",
    enableParameter = "Enable",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readOnly",  --readWrite not supported
        type = "boolean",
        default = "false",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Disabled",
          "Enabled",
          "Error_Misconfigured",
          "Error",
        },
        default = "Disabled",
      },
--[[ TODO
      IPAddressStatus = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Preferred",
          "Deprecated",
          "Invalid",
          "Inaccessible",
          "Unknown",
          "Tentative",
          "Duplicate",
          "Optimistic",
        },
        default = "Invalid",
      },
--]]
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
        max = "64",
     },
     IPAddress = {
        access = "readWrite",
        type = "string",
        default = "",
      },
--[[ TODO
      Origin = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "AutoConfigured",
          "DHCPv6",
          "WellKnown",
          "Static",
        },
        default = "Static",
      },
--]]
      Prefix = {
        access = "readOnly", --readWrite not supported
        type = "string",
        pathRef = true,
        targetParent = "Device.IP.Interface.{i}.IPv6Prefix.{i}.",
        default = "",
      },
      PreferredLifetime = {
        access = "readOnly", --readWrite not supported
        type = "dateTime",
        default = "9999-12-31T23:59:59Z",
      },
      ValidLifetime = {
        access = "readOnly", --readWrite not supported
        type = "dateTime",
        default = "9999-12-31T23:59:59Z",
      },
--[[ TODO
      Anycast = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
--]]
    }
  }
}

local mapper, os, next, string, tonumber = mapper, os, next, string, tonumber
local ubusConnection = mapper("ubus").connect()
local networkBinding = {config="network"}
local format = string.format
local isConfigChanged = false
local uciHelper = mapper("ucihelper")
local commitApply = commitapply
local addressCache = {}

-- Entries are formed based on the contents of /proc/net/if_inet6 and ubus call

-- 00000000000000000000000000000001 01 80 10 80 lo
-- +------------------------------+ ++ ++ ++ ++ ++
-- |                                |  |  |  |  |
-- 1                                2  3  4  5  6

-- 1. IPv6 address displayed in 32 hexadecimal chars without colons as separator
-- 4. Scope value (0x00 Global, 0x20 Link-Local, and 0x10 Loopback)
-- 6. Device name

local function getLinkLocalAddress(deviceName)
  local linkAddress
  local fd = io.open("/proc/net/if_inet6", "r")
  if fd then
    for line in fd:lines() do
      local ip, scope, interface = line:match("(%S+)%s+%S+%s+%S+%s+(%S+)%s+%S+%s+(%S+)")
      if interface == deviceName and scope == "20" then
        linkAddress = (ip:gsub("(....)", "%1:")):sub(1, -2)
        linkAddress = (linkAddress:gsub("0000?", "")):gsub("::+", "::")
        linkAddress = linkAddress:gsub('(%w+)', function(value) return value:gsub("^0*", "") end)
      end
    end
  fd:close()
  end
  return linkAddress
end

Device_IP_Interface_i_IPv6Address_i_.entries = function(mapping, parentKey)
  local keys = {}
  local addressData = {}
  local ubusStatus = ubusConnection:call("network.interface." .. parentKey , "status", {})
  if ubusStatus then
    if ubusStatus["ipv6-address"] and next(ubusStatus["ipv6-address"]) then
      addressData =  ubusStatus["ipv6-address"]
    elseif ubusStatus['ipv6-prefix-assignment'] and next(ubusStatus['ipv6-prefix-assignment']) then
      addressData =  ubusStatus["ipv6-prefix-assignment"]
    end
  end
  local index = 1
  for _, values in ipairs(addressData) do
    local key
    if values.address and values.address:match("^fe80") == "fe80" then
      key = parentKey
      keys[1] = key
    else
      index = index + 1
      key = parentKey .. '|' .. index
      keys[index] = key
    end
    addressCache[key] = values.address
  end
  if not keys[1] then
    addressCache[parentKey] = getLinkLocalAddress(ubusStatus["device"])
    keys[1] = parentKey
  end
  return keys
end

local function getStatus(key, parentKey)
  networkBinding.sectionname = parentKey
  networkBinding.option = "ipv6"
  return uciHelper.get_from_uci(networkBinding) == "0" and "Disabled" or "Enabled"
end

local function getEnable(key, parentKey)
  networkBinding.sectionname = parentKey
  networkBinding.option = "ipv6"
  return uciHelper.get_from_uci(networkBinding) == "0" and "0" or "1"
end

local function getIPAddress(key, parentKey)
  return addressCache[key] or ""
end

local function getPrefix(key, parentKey)
  return resolve("Device.IP.Interface.{i}.IPv6Prefix.{i}.", parentKey) or ""
end

local function getPreferredLifetime(key, parentKey, ubusStatus)
  ubusStatus = ubusStatus or ubusConnection:call("network.interface." .. parentKey, "status" , {})
  if ubusStatus and ubusStatus["ipv6-address"] then
    for i, v in ipairs(ubusStatus["ipv6-address"]) do
      if v["address"] == addressCache[key] and v["preferred"] then
        return os.date("%Y-%m-%dT%H:%M:%SZ",os.time()+ v["preferred"])
      end
    end
  end
  return "9999-12-31T23:59:59Z"
end

local function getValidLifetime(key, parentKey, ubusStatus)
  ubusStatus = ubusStatus or ubusConnection:call("network.interface." .. parentKey,"status",{})
  if ubusStatus and ubusStatus["ipv6-address"] then
    for i, v in ipairs(ubusStatus["ipv6-address"]) do
      if v["address"] == addressCache[key] and v["valid"] then
        return os.date("%Y-%m-%dT%H:%M:%SZ",os.time()+ v["valid"])
      end
    end
  end
  return "9999-12-31T23:59:59Z"
end

--getterTable is used as suggested in review #18675 to use the same functions to fetch value in both get and getall.
--As parentkey will come after key in function(mapping,param,key) declaration it is difficult to pass ubusStatus after
--key. So, to adapt the functions accordingly this getterTable is needed.

local getterTable = {
  Status = getStatus,
  Enable = getEnable,
  IPAddress = getIPAddress,
  Prefix = getPrefix,
  PreferredLifetime = getPreferredLifetime,
  ValidLifetime = getValidLifetime
}

Device_IP_Interface_i_IPv6Address_i_.get = function(mapping,param,key,parentKey)
  return getterTable[param](key,parentKey)
end

Device_IP_Interface_i_IPv6Address_i_.getall = function(mapping,key,parentKey)
  local ubusStatus = ubusConnection:call("network.interface." .. parentKey,"status",{})
  return {
    Enable = getEnable(key, parentKey),
    Status = getStatus(key, parentKey),
    IPAddress = getIPAddress(key, parentKey),
    Prefix = getPrefix(key, parentKey),
    PreferredLifetime = getPreferredLifetime(key, parentKey, ubusStatus),
    ValidLifetime = getValidLifetime(key, parentKey, ubusStatus)
  }
end

local function isValidIP6(ip)
  if ip:find(":::") then
    return false
  end
  if ip:match("^:") then
    if not ip:match("^::") then
      return false
    end
  end
  if ip:find('/') then
    local subnet
    ip,subnet = ip:match("^(.*)/(%d+)$")
    if not ip or not subnet or tonumber(subnet) > 128 then
      return false
    end
  end
  if ip:match(":$") then
    return false
  end
  local addr,count = string.gsub(ip , "::",":")
  if count > 1 then
    return false
  end
  if not addr:match("^[a-fA-F0-9:]+$") then
    return false
  end
  local numBlocks = 0
  for i in addr:gmatch("[a-fA-F0-9]+",":") do
    numBlocks = numBlocks +1
    if (not i) or (4 < #i) or (#i < 1) then
      return false
    end
  end
  if count == 0 and numBlocks ~= 8 then
    return false
  end
  if count == 1 and numBlocks > 6 then
    return false
  end
  return true
end

local function setUciParam(paramName, value, key)
  networkBinding.sectionname=key
  networkBinding.option=paramName
  uciHelper.set_on_uci(networkBinding, value, commitApply)
  isConfigChanged = true
end

Device_IP_Interface_i_IPv6Address_i_.set = {
  IPAddress = function(mapping,param,value,key,parentKey)
    local ubusStatus = ubusConnection:call("network.interface." .. parentKey, "status", {})
    if addressCache[key]:match("^fe80") then
      return nil, "Link local Address cannot be modified"
    end
    if ubusStatus and ubusStatus.proto == "static" then
      if value:match("^fe80") ~= "fe80" and isValidIP6(value) then
        setUciParam("ip6addr", value, parentKey)
      else
        return nil, "Not a valid IPv6 address"
      end
    else
      return nil, format("setting IPv6 address is not allowed: protocol is not static")
    end
  end
}

Device_IP_Interface_i_IPv6Address_i_.commit = function()
  if isConfigChanged then
    uciHelper.commit(networkBinding)
    isConfigChanged = false
  end
end

Device_IP_Interface_i_IPv6Address_i_.revert = function()
  if isConfigChanged then
    uciHelper.revert(networkBinding)
    isConfigChanged = false
  end
end

local function setUbusEvent(mapping, action, data)
  if data["ipv6-address"] then
    return { { key = data["interface"], paramname = "IPAddress" } }
  end
end

Device_IP_Interface_i_IPv6Address_i_.add_watchers = function(mapping)
  local ubusEventSource = eventsource("ubus")
  ubusEventSource.watch_event(mapping, setUbusEvent, "network.interface")
end

register(Device_IP_Interface_i_IPv6Address_i_)
