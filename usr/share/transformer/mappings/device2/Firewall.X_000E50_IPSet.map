-- Manually generated
local Device_Firewall_Multi_i_ = {
  objectType = {
    name = "Device.Firewall.#ROOT.{i}.",
    access = "readWrite",
    minEntries = 0,
    maxEntries = math.huge,
    description = "Parameters to get or set Firewall IPSet entries",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
	default = "true",
        description = "Enables or Disables an ipset rule",
      },
      Name = {
        access = "readWrite",
        type = "string",
        description = "Name of an ipset rule",
      },
      ProtocolFamily = {
        access = "readWrite",
        type = "string",
	enumeration = {
	  "ipv4",
	  "ipv6",
        },
	default = "ipv4",
        description = "Protocol family to which the ipset belongs to",
      },
      Storage = {
        access = "readWrite",
        type = "string",
        description = "Storage method used for an ipset rule",
      },
      Match = {
        access = "readWrite",
        type = "string",
        description = "Comma separated list of matching values like Source IP, Destination IP, etc",
      },
      IPRange = {
        access = "readWrite",
        type = "string",
        description = "IP Range defined for this ipset rule",
      },
      PortRange = {
        access = "readWrite",
        type = "string",
        description = "Port Range defined for this ipset rule",
      },
      NetMask = {
        access = "readWrite",
        type = "unsignedInt",
	default = "32",
        description = "Netmask used by IPAddress defined for ipset rule",
      },
      MaxElements = {
        access = "readWrite",
        type = "unsignedInt",
	default = "65536",
        description = "Maximum elements that can be stored",
      },
      HashSize = {
        access = "readWrite",
        type = "unsignedInt",
	default = "1024",
        description = "Length of the Hash defined",
      },
      Timeout = {
        access = "readWrite",
        type = "unsignedInt",
	default = "0",
        description = "Timeout defined for this ipset rule",
      },
      External = {
        access = "readWrite",
        type = "string",
        pathRef = true,
        default = "",
      },
    }
  }
}

local commitapply, mapper, register = commitapply, mapper, register
local uciHelper = mapper("ucihelper")
local getFromUci = uciHelper.get_from_uci
local setOnUci = uciHelper.set_on_uci
local forEachOnUci = uciHelper.foreach_on_uci
local configChanged
local firewallBinding = { config = "firewall" }
local resolve = resolve

local storageMethods = {
  bitmap = true,
  hash = true,
  list = true,
}

local storageDataType = {
  ip = true,
  port = true,
  mac = true,
  net = true,
  set = true,
}

Device_Firewall_Multi_i_.entries = function()
  local ipsetEntries = {}
  firewallBinding.sectionname = "ipset"
  forEachOnUci(firewallBinding, function(s)
    ipsetEntries[#ipsetEntries + 1] = s[".name"]
  end)
  return ipsetEntries
end

local function getUciValue(key, option, default)
  firewallBinding.sectionname = key
  firewallBinding.option = option
  firewallBinding.default = default
  return getFromUci(firewallBinding)
end

local function setUciValue(key, option, value)
  firewallBinding.sectionname = key
  firewallBinding.option = option
  setOnUci(firewallBinding, value, commitapply)
  configChanged = true
end

local function getIPPortHash(key, bitmap, option, default)
  if getUciValue(key, "storage") == bitmap then
    return getUciValue(key, option, default)
  end
  return default or ""
end

local function getMaskMaxElements(key, option, default, storage1, storage2)
  if getUciValue(key, "storage") == storage1 or getUciValue(key, "storage") == storage2 then
    return getUciValue(key, option, default)
  end
  return default
end

Device_Firewall_Multi_i_.get = {
  Enable = function(mapping, param, key)
    return getUciValue(key, "enabled", "1")
  end,
  Name = function(mapping, param, key)
    return getUciValue(key, "name")
  end,
  ProtocolFamily = function(mapping, param, key)
    return getUciValue(key, "family", "ipv4")
  end,
  Storage = function(mapping, param, key)
    return getUciValue(key, "storage")
  end,
  Match = function(mapping, param, key)
    return getUciValue(key, "match")
  end,
  IPRange = function(mapping, param, key)
    return getIPPortHash(key, "bitmap:ip", "iprange")
  end,
  PortRange = function(mapping, param, key)
    return getIPPortHash(key, "bitmap:port", "portrange")
  end,
  NetMask = function(mapping, param, key)
    return getMaskMaxElements(key, "netmask", "32", "bitmap:ip", "hash:ip")
  end,
  MaxElements = function(mapping, param, key)
    return getMaskMaxElements(key, "maxelem", "65536", "hash", "list")
  end,
  HashSize = function(mapping, param, key)
    return getIPPortHash(key, "hash", "hashsize", "1024")
  end,
  Timeout = function(mapping, param, key)
    return getUciValue(key, "timeout", "0")
  end,
  External = function(mapping, param, key)
    return resolve(mapping.externalPath, getUciValue(key, "external")) or ""
  end,
}

Device_Firewall_Multi_i_.getall = function(mapping, key)
  firewallBinding.sectionname = key
  local allValues = uciHelper.getall_from_uci(firewallBinding)
  return {
    Enable = allValues.enabled or "1",
    Name = allValues.name or "",
    ProtocolFamily = allValues.family or "ipv4",
    Storage = allValues.storage or "",
    Match = allValues.match or "",
    IPRange = getIPPortHash(key, "bitmap:ip", "iprange"),
    PortRange = getIPPortHash(key, "bitmap:port", "portrange"),
    NetMask = getMaskMaxElements(key, "netmask", "32", "bitmap:ip", "hash:ip"),
    MaxElements = getMaskMaxElements(key, "maxelem", "65536", "hash", "list"),
    HashSize = getIPPortHash(key, "hash", "hashsize", "1024"),
    Timeout = allValues.timeout or "0",
    External = allValues.external and resolve(mapping.externalPath, allValues.external) or ""
  }
end

Device_Firewall_Multi_i_.set = {
  Enable = function(mapping, param, value, key)
    setUciValue(key, "enabled", value)
  end,
  Name = function(mapping, param, value, key)
    setUciValue(key, "name", value)
  end,
  ProtocolFamily = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "bitmap" then
      value = "ipv4"
    end
    setUciValue(key, "family", value)
  end,
  Storage = function(mapping, param, value, key)
    if storageMethods[value] then
      setUciValue(key, "storage", value)
    else
      local method, datatype = value:match("(%S+):(%S+)")
      if storageMethods[method]  and storageDataType[datatype] then
        setUciValue(key, "storage", value)
      else
        return nil, "Invalid value"
      end
    end
  end,
  Match = function(mapping, param, value, key)
    local direction, datatype = value:match("(%S+)_(%S+)")
    if direction and datatype then
      if (direction == "src" or "dest") and storageDataType[datatype] then
        setUciValue(key, "match", {value})
      else
        return nil, "Invalid value"
      end
    end
  end,
  IPRange = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "bitmap:ip" then
      setUciValue(key, "iprange", value)
    end
  end,
  PortRange = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "bitmap:port" then
      setUciValue(key, "portrange", value)
    end
  end,
  NetMask = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "hashmap:ip" or getUciValue(key, "storage") == "bitmap:ip" then
      setUciValue(key, "netmask", value)
    end
  end,
  MaxElements = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "hash" or getUciValue(key, "storage") == "list" then
      setUciValue(key, "maxelem", value)
    end
  end,
  HashSize = function(mapping, param, value, key)
    if getUciValue(key, "storage") == "hash" then
      setUciValue(key, "hashsize", value)
    end
  end,
  Timeout = function(mapping, param, value, key)
    setUciValue(key, "timeout", value)
  end,
  External = function(mapping, param, value, key)
    local rc
    rc, value = pcall(tokey, value, mapping.externalPath)
    if not rc then
      return nil, "Invalid value"
    end
    setUciValue(key, "external", value)
  end,
}

Device_Firewall_Multi_i_.add = function(mapping, key)
  local sname = "ipset"
  firewallBinding.sectionname = sname
  local _key = uciHelper.generate_key(firewallBinding)
  firewallBinding.sectionname = _key
  firewallBinding.option = nil
  uciHelper.set_on_uci(firewallBinding, sname, commitapply)
  configChanged = true
  return _key
end

Device_Firewall_Multi_i_.delete = function(mapping, key)
  firewallBinding.sectionname = key
  firewallBinding.option = nil
  uciHelper.delete_on_uci(firewallBinding, commitapply)
  configChanged = true
  return true
end

Device_Firewall_Multi_i_.commit = function()
  if configChanged then
    uciHelper.commit(firewallBinding)
    configChanged = false
  end
end

Device_Firewall_Multi_i_.revert = function()
  if configChanged then
    uciHelper.revert(firewallBinding)
    configChanged = false
  end
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Device_Firewall_Multi_i_, "#ROOT", { "X_000E50_IPSet", "X_BELGACOM_IPSet" })
for _, dupli in ipairs(duplicates) do
  if dupli.objectType.name:match("^Device.Firewall.X_000E50_IPSet") then
    dupli.objectType.parameters.External.targetParent = "Device.X_000E50_IPSet.{i}."
    dupli.externalPath = "Device.X_000E50_IPSet.{i}."
  else
    dupli.objectType.parameters.External.targetParent = "Device.X_BELGACOM_IPSet.{i}."
    dupli.externalPath = "Device.X_BELGACOM_IPSet.{i}."
  end
  register (dupli)
end
