-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_Firewall_Chain_i_Rule_i_ = {
  objectType = {
    name = "Device.Firewall.Chain.{i}.Rule.{i}.",
    access = "readOnly", --currently readWrite not supported
    numEntriesParameter = "RuleNumberOfEntries",
    enableParameter = "Enable",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
      },
      Description = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      Target = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "Drop",
          "Accept",
          "Reject",
          "Return",
          "TargetChain",
        },
        default = "Drop",
      },
      TargetChain = {
        access = "readOnly", -- currently readWrite not supported since unique keys get affected.
        type = "string",
        pathRef = true,
        targetParent = "Device.Firewall.Chain.{i}.",
        default = "",
      },
      SourceInterface = {
        access = "readOnly", -- currently readWrite not supported
        type = "string",
        max = "256",
        pathRef = true,
        default = "",
      },
      DestInterface = {
        access = "readOnly", -- currently readWrite not supported
        type = "string",
        max = "256",
        pathRef = true,
        default = "",
      },
      IPVersion = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
            max = "15",
          },
        },
        default = "-1",
      },
      DestIP = {
        access = "readWrite",
        type = "string",
        default = "",
      },
--[[ TODO
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Disabled",
          "Enabled",
          "Error_Misconfigured",
          "Error",
        },
        default = "Disabled",
      },
      Order = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
      Log = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      CreationDate = {
        access = "readOnly",
        type = "dateTime",
      },
      ExpiryDate = {
        access = "readWrite",
        type = "dateTime",
        default = "9999-12-31T23:59:59Z",
      },
      SourceInterfaceExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      SourceAllInterfaces = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      DestIPExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      DestAllInterfaces = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      DestMask = {
        access = "readWrite",
        type = "string",
        default = "",
      },
      SourceIP = {
        access = "readWrite",
        type = "string",
        default = "",
      },
      SourceMask = {
        access = "readWrite",
        type = "string",
        default = "",
      },
      SourceIPExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      DestInterfaceExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      Protocol = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
            max = "255",
          },
        },
        default = "-1",
      },
      ProtocolExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      DestPort = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
            max = "65535",
          },
        },
        default = "-1",
      },
      DestPortRangeMax = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
            max = "65535",
          },
        },
        default = "-1",
      },
      DestPortExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      SourcePort = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
            max = "65535",
          },
        },
        default = "-1",
      },
      SourcePortRangeMax = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
            max = "65535",
          },
        },
        default = "-1",
      },
      SourcePortExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      DSCP = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
            max = "63",
          },
        },
        default = "-1",
      },
      DSCPExclude = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
--]]
    }
  }
}

local uciHelper = mapper("ucihelper")
local getFromUci = uciHelper.get_from_uci
local firewallBinding = {config = "firewall"}
local isConfigChanged = false
local keyToSectionName = {}
local resolve, ipairs = resolve, ipairs
local nwCommon = mapper("nwcommon")

local paramMap = {
  ["Enable"]          = "enabled",
  ["Description"]     = "name",
  ["Target"]          = "target",
  ["SourceInterface"] = "src",
  ["DestInterface"]   = "dest",
  ["IPVersion"]       = "family",
  ["DestIP"]          = "dest_ip",
}

local targetMap = {
  ["ACCEPT"] = "Accept",
  ["REJECT"] = "Reject",
  ["DROP"]   = "Drop",
  ["Accept"] = "ACCEPT",
  ["Reject"] = "REJECT",
  ["Drop"]   = "DROP",
}

local function ifNotExists(tableName, tableValue)
  for _, v in ipairs(tableName) do
    if v == tableValue then
      return false
    end
  end
  return true
end

Device_Firewall_Chain_i_Rule_i_.entries = function(mapping, parentKey)
  local chainRuleEntries = {}
  local srcInterfaces = {}
  local destInterfaces = {}
  keyToSectionName = {}
  local isKeyGenerated = false
  local ruleType = getFromUci({ config = "firewall", sectionname = parentKey, option = "type" })
  firewallBinding.sectionname = ruleType
  local result = uciHelper.foreach_on_uci(firewallBinding,function(s)
    local key = s._key
    if not key then
      firewallBinding.sectionname = s[".name"]
      key = uciHelper.generate_key_on_uci(firewallBinding)
      isKeyGenerated = true
    end
    local srcZone = s["src"]
    local destZone = s["dest"]
    firewallBinding.sectionname = "zone"
    uciHelper.foreach_on_uci(firewallBinding,function(ss)
      if ss["name"] == srcZone then
        srcInterfaces = getFromUci({ config = "firewall", sectionname = ss['.name'], option = "network" })
      elseif ss["name"] == destZone then
        destInterfaces = getFromUci({ config = "firewall", sectionname = ss['.name'], option = "network" })
      end
    end)
    local entryValue
    for _, srcIntf in ipairs(srcInterfaces) do
      for _, destIntf in ipairs(destInterfaces) do
        entryValue = parentKey .. "|" .. key .. "|" .. srcIntf .. "|" .. destIntf
        if ifNotExists(chainRuleEntries, entryValue) then
          chainRuleEntries[#chainRuleEntries+1] = entryValue
        end
      end
    end
    keyToSectionName[key] = s[".name"]
  end)
  if isKeyGenerated then
    if result then
      uciHelper.commit_keys(firewallBinding)
    else
      uciHelper.revert_keys(firewallBinding)
    end
  end
  return chainRuleEntries
end

local function getParamValue(param, key, default)
  firewallBinding.sectionname = keyToSectionName[key]
  firewallBinding.option = paramMap[param]
  firewallBinding.default = default
  return getFromUci(firewallBinding)
end

Device_Firewall_Chain_i_Rule_i_.get = function(mapping, param, key)
  local target, section, srcIntf, destIntf = key:match("^(.*)|(.*)|(.*)|(.*)")
  if param == "Enable" then
    return getParamValue(param, section, "1")
  elseif param == "Target" then
    return targetMap[getParamValue(param, section, "DROP")]
  elseif param == "TargetChain" then
    return resolve("Device.Firewall.Chain.{i}.", target) or ""
  elseif param == "SourceInterface" then
    return resolve("Device.IP.Interface.{i}.", srcIntf) or ""
  elseif param == "DestInterface" then
    return resolve("Device.IP.Interface.{i}.", destIntf) or ""
  elseif param == "IPVersion" then
    return getParamValue(param, section, "-1"):match("ipv(%d)") or "-1"
  else
    return getParamValue(param, section)
  end
end

Device_Firewall_Chain_i_Rule_i_.getall = function(mapping, key)
  local target, section, srcIntf, destIntf = key:match("^(.*)|(.*)|(.*)|(.*)")
  firewallBinding.sectionname = keyToSectionName[section]
  local firewallValues = uciHelper.getall_from_uci(firewallBinding)
  return {
    Enable = firewallValues["enabled"] or "1",
    Description = firewallValues["name"] or "",
    Target = targetMap[firewallValues["target"]] or "Drop",
    TargetChain = resolve("Device.Firewall.Chain.{i}.", target) or "",
    SourceInterface = resolve("Device.IP.Interface.{i}.", srcIntf) or "",
    DestInterface = resolve("Device.IP.Interface.{i}.", destIntf) or "",
    IPVersion =  firewallValues["family"] and firewallValues["family"]:match("ipv(%d)") or "-1",
    DestIP = firewallValues["dest_ip"] or "",
  }
end

local function setParamValue(mapping, param, value, key)
  firewallBinding.sectionname = keyToSectionName[key]
  firewallBinding.option = paramMap[param]
  uciHelper.set_on_uci(firewallBinding,value,commitapply)
  isConfigChanged = true
end

Device_Firewall_Chain_i_Rule_i_.set = function(mapping, param, value, key)
  local section = key:match("^.*|(.*)|.*|.*")
  if param == "IPVersion" then
    if value == "4" or value == "6" then
      value = "ipv".. value
    else
      value = "any"
    end
  elseif param == "Target" then
    value = targetMap[value] or "DROP"
  elseif param == "DestIP" and not nwCommon.isIPv4(value) then
    return nil, string.format("%s is not a valid IPv4 Address",value)
  end
  setParamValue(mapping, param, value, section)
end

Device_Firewall_Chain_i_Rule_i_.commit = function()
  if isConfigChanged then
    uciHelper.commit(firewallBinding)
    isConfigChanged = false
  end
end

Device_Firewall_Chain_i_Rule_i_.revert = function()
  if isConfigChanged then
    uciHelper.revert(firewallBinding)
    isConfigChanged = false
  end
end

register(Device_Firewall_Chain_i_Rule_i_)
