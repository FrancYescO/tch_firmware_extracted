-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_ManagementServer_ = {
  objectType = {
    name = "Device.ManagementServer.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      EnableCWMP = {
        access = "readWrite",
        type = "boolean",
        default = "true",
      },
      URL = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      Username = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      Password = {
        access = "readWrite",
        hidden = "true",
        type = "string",
        max = "256",
      },
--[[ TODO:
      ScheduleReboot = {
        access = "readWrite",
        type = "dateTime",
      },
      DelayReboot = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
          },
        },
      },
--]]
      PeriodicInformEnable = {
        access = "readWrite",
        type = "boolean",
      },
      PeriodicInformInterval = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
      PeriodicInformTime = {
        access = "readWrite",
        type = "dateTime",
      },
      ParameterKey = {
        access = "readOnly",
        activeNotify = "canDeny",
        forcedInform = "true",
        type = "string",
        max = "32",
      },
      ConnectionRequestURL = {
        access = "readOnly",
        activeNotify = "forceDefaultEnabled",
        forcedInform = "true",
        type = "string",
        max = "256",
      },
      ConnectionRequestUsername = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      ConnectionRequestPassword = {
        access = "readWrite",
        hidden = "true",
        type = "string",
        max = "256",
      },
      AliasBasedAddressing = {
        access = "readOnly",
        forcedInform = "true",
        type = "boolean",
      },
      UpgradesManaged = {
        access = "readWrite",
        type = "boolean",
      },
--[[ TODO:
      KickURL = {
        access = "readOnly",
        type = "string",
        max = "256",
      },
      DownloadProgressURL = {
        access = "readOnly",
        type = "string",
        max = "256",
      },
      DefaultActiveNotificationThrottle = {
        access = "readWrite",
        type = "unsignedInt",
      },
--]]
      CWMPRetryMinimumWaitInterval = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
            max = "65535",
          },
        },
      },
      CWMPRetryIntervalMultiplier = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1000",
            max = "65535",
          },
        },
      },
--[[
      UDPConnectionRequestAddress = {
        access = "readOnly",
        type = "string",
        max = "256",
      },
      STUNEnable = {
        access = "readWrite",
        type = "boolean",
      },
      STUNServerAddress = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      STUNServerPort = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "65535",
          },
        },
      },
      STUNUsername = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      STUNPassword = {
        access = "readWrite",
        hidden = "true",
        type = "string",
        max = "256",
      },
      STUNMaximumKeepAlivePeriod = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
          },
        },
      },
      STUNMinimumKeepAlivePeriod = {
        access = "readWrite",
        type = "unsignedInt",
      },
      NATDetected = {
        access = "readOnly",
        type = "boolean",
      },
      InstanceMode = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "InstanceNumber",
          "InstanceAlias",
        },
        default = "InstanceNumber",
      },
      AutoCreateInstances = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      -- ManageableDeviceNumberOfEntries
      -- automatically created when Device.ManagementServer.ManageableDevice.{i}. is loaded
      ManageableDeviceNotificationLimit = {
        access = "readWrite",
        type = "unsignedInt",
      },
      -- EmbeddedDeviceNumberOfEntries
      -- automatically created when Device.ManagementServer.EmbeddedDevice.{i}. is loaded
      -- VirtualDeviceNumberOfEntries
      -- automatically created when Device.ManagementServer.VirtualDevice.{i}. is loaded
      SupportedConnReqMethods = {
        access = "readOnly",
        list = true,
        type = "string",
        enumeration = {
          "HTTP",
          "STUN",
          "XMPP",
        },
      },
      ConnReqXMPPConnection = {
        access = "readWrite",
        type = "string",
        pathRef = true,
        targetParent = "Device.XMPP.Connection.{i}.",
      },
      ConnReqAllowedJabberIDs = {
        access = "readWrite",
        list = true,
        maxItems = "32",
        type = "string",
        max = "256",
      },
      ConnReqJabberID = {
        access = "readOnly",
        activeNotify = "forceDefaultEnabled",
        type = "string",
      },
      HTTPCompressionSupported = {
        access = "readOnly",
        list = true,
        type = "string",
        enumeration = {
          "GZIP",
          "Compress",
          "Deflate",
          "Disabled",
        },
      },
      HTTPCompression = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "GZIP",
          "Compress",
          "Deflate",
          "Disabled",
        },
        default = "Disabled",
      },
      LightweightNotificationProtocolsSupported = {
        access = "readOnly",
        list = true,
        type = "string",
        enumeration = {
          "UDP",
          "",
        },
      },
      LightweightNotificationProtocolsUsed = {
        access = "readWrite",
        list = true,
        type = "string",
        enumeration = {
          "UDP",
          "",
        },
      },
      UDPLightweightNotificationHost = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      UDPLightweightNotificationPort = {
        access = "readWrite",
        type = "unsignedInt",
      },
      -- InformParameterNumberOfEntries
      -- automatically created when Device.ManagementServer.InformParameter.{i}. is loaded
]]
    }
  }
}

local cwmpOption = {
  ["EnableCWMP"] = "state",
  ["URL"] = "acs_url",
  ["Username"] = "acs_user",
  ["Password"] = "acs_pass",
  ["PeriodicInformEnable"] = "periodicinform_enable",
  ["PeriodicInformInterval"] = "periodicinform_interval",
  ["PeriodicInformTime"] = "periodicinform_time",
  ["ParameterKey"] = "parameter_key",
  ["ConnectionRequestURL"] = "connectionrequest_url",
  ["ConnectionRequestUsername"] = "connectionrequest_username",
  ["ConnectionRequestPassword"] = "connectionrequest_password",
  ["UpgradesManaged"] = "upgradesmanaged",
  ["CWMPRetryMinimumWaitInterval"] = "backoff_minwait",
  ["CWMPRetryIntervalMultiplier"] = "backoff_multiplier",
}

local uciHelper = mapper("ucihelper")
local getFromUci = uciHelper.get_from_uci
local cwmpBinding = {config = "cwmpd", sectionname = "cwmpd_config"}
local isConfigChanged = false
local uci = require("uci")

local function removeFromState(option)
  local cursor = uci.cursor(nil,"/var/state") -- Can not use ucihelper, because it does not contain this kind of cursor.
  cursor:revert("cwmpd", "cwmpd_config", option)
  cursor:close()
end

local function getPeriodicInformTime(param)
  cwmpBinding.option = cwmpOption[param]
  local value = getFromUci(cwmpBinding)
  value = value ~= "" and tonumber(value)
  return value and os.date("%Y-%m-%dT%H:%M:%SZ", value) or "0001-01-01T00:00:00Z"
end

local function setPeriodicInformTime(value)
  local date = {}
  if value:match("(%d+)%-(%d+)%-(%d+)T(%d+):(%d+):(%d+)Z") then
    date.year, date.month, date.day, date.hour, date.min, date.sec = value:match("(%d+)%-(%d+)%-(%d+)T(%d+):(%d+):(%d+)Z")
    return os.time(date)
  end
  return nil
end

Device_ManagementServer_.get = function(mapping, param)
  if param == "PeriodicInformTime" then
    return getPeriodicInformTime(param)
  elseif param == "AliasBasedAddressing" then
    return "0"
  end
  cwmpBinding.option = cwmpOption[param]
  return getFromUci(cwmpBinding)
end

-- A getall implementation is not done as it will not bring any improvement

Device_ManagementServer_.set = function(mapping, param, value)
  if param == "PeriodicInformTime" then
    value = setPeriodicInformTime(value)
    if not value then
      return value, "invalid value"
    end
  end
  cwmpBinding.option = cwmpOption[param]
  removeFromState(cwmpBinding.option)
  uciHelper.set_on_uci(cwmpBinding, value, commitapply)
  isConfigChanged = true
end

Device_ManagementServer_.commit = function()
  if isConfigChanged then
    uciHelper.commit(cwmpBinding)
    isConfigChanged = false
  end
end

Device_ManagementServer_.revert = function()
  if isConfigChanged then
    uciHelper.revert(cwmpBinding)
    isConfigChanged = false
  end
end

register(Device_ManagementServer_)
