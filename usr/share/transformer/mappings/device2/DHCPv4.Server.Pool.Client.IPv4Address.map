-- Automatically generated from Device:2.11
-- using generator version 2.3
local Device_DHCPv4_Server_Pool_i_Client_i_IPv4Address_i_ = {
  objectType = {
    name = "Device.DHCPv4.Server.Pool.{i}.Client.{i}.IPv4Address.{i}.",
    access = "readOnly",
    numEntriesParameter = "IPv4AddressNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      LeaseTimeRemaining = {
        access = "readOnly",
        type = "dateTime",
      },
      IPAddress = {
        access = "readOnly",
        type = "string",
      },
    }
  }
}

local mapper, os, open = mapper, os, io.open
local ubus = mapper("ubus").connect()
local nwCommon = mapper("nwcommon")
local splitKey = nwCommon.split_key
local pairs, match = pairs, string.match
local uciHelper = mapper("ucihelper")
local dhcp = require("transformer.shared.dhcp")
local dhcpBinding = {config = "dhcp"}
local network = require("transformer.shared.common.network")

Device_DHCPv4_Server_Pool_i_Client_i_IPv4Address_i_.entries = function(mapping, parentkey)
  local entries = {}
  local devices = ubus:call("hostmanager.device", "get",  {})
  local interface, dev = splitKey(parentkey)
  dhcpBinding.sectionname = interface
  dhcpBinding.option = "interface"
  local intf = uciHelper.get_from_uci(dhcpBinding)
  local l3Intf = nwCommon.getIntfName(intf)
  local deviceInfo = devices and devices[dev]
  if deviceInfo and deviceInfo.l3interface == l3Intf and deviceInfo["ipv4"] then
    for index, v in pairs(deviceInfo["ipv4"]) do
      if type(v.dhcp) == "table" and v.dhcp.state == "connected" then
	local idx = #entries+1
        entries[idx] = deviceInfo["mac-address"] .. "|" .. tostring(deviceInfo.connected_time) .. "|" .. idx .. "|" .. parentkey
      end
    end
  end
  return entries or {}
end

local interfaceLease
local function extractDhcpExpirationTime(macadd, address_type)
  local devices = ubus:call("hostmanager.device", "get",{["mac-address"]=macadd})
    interfaceLease = devices["dev0"]["interface"] and devices["dev0"]["interface"] or ""
    if devices["dev0"] and devices["dev0"][address_type] then
      for _, value in pairs(devices["dev0"][address_type]) do
        if type(value.dhcp) == "table" and value.dhcp.state == "connected" and value.dhcp["expiration-time"] then
          return value.dhcp["expiration-time"]
        end
      end
    end
end
local function getLeaseRemaining(key)
  local macadd = splitKey(key)
  local lease = extractDhcpExpirationTime(macadd, 'ipv4') or 0
  dhcpBinding.sectionname = interfaceLease
  dhcpBinding.option = "leasetime"
  local leaseInfinite = uciHelper.get_from_uci(dhcpBinding)
  if leaseInfinite == "infinite" then
    return "9999-12-31T23:59:59Z"
  elseif (lease - os.time()) < 0 then
    return "0001-01-01T00:00:00Z"
  end
  return os.date("!%Y-%m-%dT%H:%M:%SZ", lease)
end

local function getIPAddress(key)
  local macaddr = splitKey(key)
  local hostData = network.getHostDataByMAC(macaddr)
  local addr
  if next(hostData.ipv4) then
    for _, value in pairs(hostData.ipv4) do
      if type(value.dhcp) == "table" and value.dhcp.state == "connected" then
        addr = value.address
	break
      end
    end
  end
  return addr or ""
end

Device_DHCPv4_Server_Pool_i_Client_i_IPv4Address_i_.get = {
  LeaseTimeRemaining = function(mapping, param, key)
    return getLeaseRemaining(key)
  end,
  IPAddress = function(mapping, param, key)
    return getIPAddress(key)
  end
}

register(Device_DHCPv4_Server_Pool_i_Client_i_IPv4Address_i_)
