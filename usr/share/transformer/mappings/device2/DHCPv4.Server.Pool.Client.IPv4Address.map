-- Automatically generated from Device:2.11
-- using generator version 2.3
local Device_DHCPv4_Server_Pool_i_Client_i_IPv4Address_i_ = {
  objectType = {
    name = "Device.DHCPv4.Server.Pool.{i}.Client.{i}.IPv4Address.{i}.",
    access = "readOnly",
    numEntriesParameter = "IPv4AddressNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      LeaseTimeRemaining = {
        access = "readOnly",
        type = "dateTime",
      },
      IPAddress = {
        access = "readOnly",
        type = "string",
      },
    }
  }
}

local mapper, os, open = mapper, os, io.open
local ubus = mapper("ubus").connect()
local nwCommon = mapper("nwcommon")
local splitKey = nwCommon.split_key
local pairs, match = pairs, string.match
local uciHelper = mapper("ucihelper")
local dhcp = require("transformer.shared.dhcp")
local dhcpBinding = {config = "dhcp"}
local network = require("transformer.shared.common.network")

Device_DHCPv4_Server_Pool_i_Client_i_IPv4Address_i_.entries = function(mapping, parentkey)
  local entries = {}
  local devices = ubus:call("hostmanager.device", "get",  {})
  local interface, dev = splitKey(parentkey)
  dhcpBinding.sectionname = interface
  dhcpBinding.option = "interface"
  local intf = uciHelper.get_from_uci(dhcpBinding)
  local l3Intf = nwCommon.getIntfName(intf)
  local deviceInfo = devices[dev]
  if deviceInfo and deviceInfo.l3interface == l3Intf and deviceInfo.state == "connected" and deviceInfo["ipv4"] then
    for index, v in pairs(deviceInfo["ipv4"]) do
      if v.state == "connected" or v.state == "stale" then
        entries[#entries+1] = deviceInfo["mac-address"] .. "|" .. deviceInfo.connected_time .. "|" .. index
      end
    end
  end
  return entries or {}
end

local function getLeaseRemaining(key)
  local leaseTimeLeft = 0
  local macadd, hostInfo = splitKey(key)
  local time = splitKey(hostInfo)
  local hostDetails = dhcp.getDhcpInfo(macadd)
  local lease = hostDetails.leasetime or "0"
  if lease ~= "0" then
    -- Leasetimeleft has been calculated as, LeaseTimeRemaining = ((Connectedtime + LeaseTime) - CurrentTime)
    leaseTimeLeft = (time + lease) - os.time()
    -- The while loop was added inorder to adjust the renewal offset.
    while leaseTimeLeft < 0 do
      leaseTimeLeft = leaseTimeLeft + lease
    end
  elseif lease == "0" then
    return "0"
  end
  return tostring(os.date("%FT%TZ", leaseTimeLeft)) or "0"
end

local function getIPAddress(key)
  local macaddr = splitKey(key)
  local hostData = network.getHostDataByMAC(macaddr)
  local addr = ""
  if next(hostData.ipv4) ~= nil then
    for _,n in pairs(hostData.ipv4) do
      if n.state == "connected" or n.state == "stale" then
        addr = n.address
      end
    end
  end
  return addr or ""
end

Device_DHCPv4_Server_Pool_i_Client_i_IPv4Address_i_.get = {
  LeaseTimeRemaining = function(mapping, param, key)
    return getLeaseRemaining(key)
  end,
  IPAddress = function(mapping, param, key)
    return getIPAddress(key)
  end
}

Device_DHCPv4_Server_Pool_i_Client_i_IPv4Address_i_.getall = function(mapping,key)
  local allValues = {
    LeaseTimeRemaining = getLeaseRemaining(key),
    IPAddress = getIPAddress(key),
  }
  return allValues
end

register(Device_DHCPv4_Server_Pool_i_Client_i_IPv4Address_i_)
