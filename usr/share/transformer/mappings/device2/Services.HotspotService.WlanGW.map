-- Manually generated
local Device_Services_Multi_WlanGW_i_ = {
  objectType = {
    name = "Device.Services.#VENDOR.WlanGW.{i}.",
    access = "readOnly",
    description = "To get or set parameters of hotspot service",
    numEntriesParameter = "WlanGWNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
        default = "true",
        description = "Enable or disable hotspot service",
      },
      Status = {
        access = "readOnly",
        type = "string",
        default = "Disabled",
        description = "Status of hotspot service",
      },
      CheckPrivateWifi = {
        access = "readWrite",
        type = "boolean",
        default = "true",
        description = "Disables the hotspot service when private wifi interface is down",
      },
      CheckPrivateWifiEncryption = {
        access = "readWrite",
        type = "boolean",
        default = "true",
        description = "Disables the hotspot service when private wifi interface is not secured",
      },
      AllowEthWanMode = {
        access = "readWrite",
        type = "boolean",
        default = "true",
        description = "Disables the hotspot service when WAN ethernet port is configured",
      },
      VLANID = {
        access = "readWrite",
        type = "unsignedInt",
        default = "0",
        description = "Vlan-id of hotspot service",
      },
      SSIDReference = {
        access = "readOnly", -- readWrite not supported, no lower layer support
        type = "string",
        max = "256",
        pathRef = true,
        default = "",
        description = "The path of WiFi - SSID to which the hotspot is connected",
      },
      GRETunnel = {
        access = "readWrite",
        type = "string",
        max = "256",
        pathRef = true,
        targetParent = "Device.GRE.Tunnel.{i}.",
        default = "",
        description = "The path of GRE-Tunnel to which the hotspot is connected",
      },
    }
  }
}

local string = string
local mapper, pairs, resolve, match, format  = mapper, pairs, resolve, string.match, string.format
local nwmodel = require "transformer.shared.models.device2.network"
local ubusConnection = mapper("ubus").connect()
local uciHelper = mapper("ucihelper")
local forEachOnUci = uciHelper.foreach_on_uci
local greBinding = { config = "gre_hotspotd" }
local networkBinding = { config = "network" }
local wirelessBinding = { config = "wireless" }
local conn = mapper("ubus").connect()
local transactions = {}

Device_Services_Multi_WlanGW_i_.entries = function()
  local hotspotEntries = {}
  greBinding.sectionname = "hotspot"
  forEachOnUci(greBinding, function(s)
     hotspotEntries[#hotspotEntries + 1] = s[".name"]
  end)
  return hotspotEntries
end

local function getUciValue(binding, section, option, default)
  binding.sectionname = section
  binding.option = option
  binding.default = default
  binding.state = false
  return uciHelper.get_from_uci(binding)
end

local function setUciValue(binding, section, option, value)
  binding.sectionname = section
  binding.option = option
  uciHelper.set_on_uci(binding, value, commitapply)
  transactions[binding] = true
end

-- Returns gre-iface and vlan-id from ifname of the hotspot
-- @param ifname ifname of the hotspot
-- @return gre-iface, vlan-id of the hotspot
local function getIfnameAndVlan(ifname)
  local greIface, vlanID, index
  if type(ifname) == "table" then
    for key, intfname in ipairs(ifname) do
      if match(intfname, "^@gt%d+") then
        ifname = intfname
        index = key
        break
      end
    end
  end
  greIface, vlanID = match(ifname, "@(gt%d+)%.*(%S*)")
  return greIface, vlanID ~= "" and vlanID or "0", index
end

local function isDuplicate(hotspot, greIface, vlanID)
  local duplicate = false
  networkBinding.sectionname = "interface"
  forEachOnUci(networkBinding, function(s)
    if s.ifname and s[".name"] ~= hotspot then
      local iface, vid = getIfnameAndVlan(s.ifname)
      if iface and iface == greIface and vid == vlanID then
        duplicate = true
        return false
      end
    end
  end)
  return duplicate
end

Device_Services_Multi_WlanGW_i_.get = {
  Enable = function(mapping, param, key)
    return getUciValue(greBinding, key, "enable", "1")
  end,
  Status = function(mapping, param, key)
    local hotspotData = ubusConnection:call("gre-hotspotd", "get", { ["name"] = key })
    return hotspotData and hotspotData[key] and hotspotData[key].state or "Disabled"
  end,
  VLANID = function(mapping, param, key)
    local _, vlanid = getIfnameAndVlan(getUciValue(networkBinding, key, "ifname"))
    return vlanid
  end,
  SSIDReference = function(mapping, param, key)
    local ssidReference
    local wifiIface = getUciValue(greBinding, key, "wifi_iface")
    wifiIface = type(wifiIface) == "table" and wifiIface[1] or wifiIface
    wirelessBinding.sectionname = "wifi-ap"
    forEachOnUci(wirelessBinding, function(s)
      if s.iface and s.iface == wifiIface then
        local model = nwmodel.load()
        ssidReference = model:getLowerLayersResolved(s[".name"], resolve)
        return false
      end
    end)
    return ssidReference or ""
  end,
  GRETunnel = function(mapping, param, key)
    local greIface = getIfnameAndVlan(getUciValue(networkBinding, key, "ifname"))
    return greIface and resolve("Device.GRE.Tunnel.{i}.", "gre-" .. greIface) or ""
  end,
  CheckPrivateWifi = function(mapping, param, key)
    return getUciValue(greBinding, key, "check_private_wifi", "1")
  end,
  CheckPrivateWifiEncryption = function(mapping, param, key)
    return getUciValue(greBinding, key, "check_private_wifi_encryption", "1")
  end,
  AllowEthWanMode = function(mapping, param, key)
    return getUciValue(greBinding, key, "allow_ethwan_mode", "1")
  end,
}

-- A getall implementation is not done as it will not bring any improvement
-- as data retrieval is done in the entries call. The get will use the cached data
-- no work is duplicated

Device_Services_Multi_WlanGW_i_.set = {
  Enable = function(mapping, param, value, key)
    setUciValue(greBinding, key, "enable", value)
  end,
  VLANID = function(mapping, param, value, key)
    local ifname = getUciValue(networkBinding, key, "ifname")
    local greIface = getIfnameAndVlan(ifname)
    if greIface and isDuplicate(key, greIface, value) then
      return nil, format("VLANID %s is already assigned", value)
    end
    conn:call("gre-hotspotd", "set", {["name"]=key,["vlan-id"]=value})
  end,
  GRETunnel = function(mapping, param, value, key)
    local err
    err, value = pcall(tokey, value, "Device.GRE.Tunnel.{i}.")
    value = value and match(value, "gre%-(%S+)")
    if not err or not value or value == "" then
      return nil, "Invalid value"
    end
    local ifname = getUciValue(networkBinding, key, "ifname")
    local _, vlanid, index = getIfnameAndVlan(ifname)
    if isDuplicate(key, value, vlanid) then
      return nil, format("Gre-iface %s is already assigned", value)
    end
    -- "vlan-id" is explicitly set to its current value to avoid the value automatically changing to 0 while "gre-iface" is set
    value = vlanid ~= "0" and "@" .. value .. "." .. vlanid or "@" .. value
    if index then
      ifname[index] = value
      setUciValue(networkBinding, key, "ifname", ifname)
    else
      setUciValue(networkBinding, key, "ifname", value)
    end
    commitapply:newset("gre_hotspotd")
  end,
  CheckPrivateWifi = function(mapping, param, value, key)
    setUciValue(greBinding, key, "check_private_wifi", value)
  end,
  CheckPrivateWifiEncryption = function(mapping, param, value, key)
    setUciValue(greBinding, key, "check_private_wifi_encryption", value)
  end,
  AllowEthWanMode = function(mapping, param, value, key)
    setUciValue(greBinding, key, "allow_ethwan_mode", value)
  end,
}

Device_Services_Multi_WlanGW_i_.commit = function()
  for binding in pairs(transactions) do
    uciHelper.commit(binding)
  end
  transactions = {}
end

Device_Services_Multi_WlanGW_i_.revert = function()
  for binding in pairs(transactions) do
    uciHelper.revert(binding)
  end
  transactions = {}
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Device_Services_Multi_WlanGW_i_, "#VENDOR", { "X_BELGACOM_HotspotService", "X_000E50_HotspotService" })
for _, dupli in ipairs(duplicates) do
  register (dupli)
end
