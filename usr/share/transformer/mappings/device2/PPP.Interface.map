-- Automatically generated from Device:2.10
-- using generator version 2.3
local Device_PPP_Interface_i_ = {
  objectType = {
    name = "Device.PPP.Interface.{i}.",
    access = "readOnly",
    numEntriesParameter = "InterfaceNumberOfEntries",
    enableParameter = "Enable",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Up",
          "Down",
          "Unknown",
          "Dormant",
          "NotPresent",
          "LowerLayerDown",
          "Error",
        },
        default = "Down",
      },
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
        max = "64",
      },
      Name = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
--[[ TODO
      LastChange = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
--]]
      LowerLayers = {
        access = "readOnly",  -- readWrite not supported
        list = true,
        max = "1024",
        type = "string",
        pathRef = true,
        default = "",
      },
      Reset = {
        access = "readWrite",
        hidden = "true",
        command = "true",
        type = "boolean",
        default = "false",
      },
      ConnectionStatus = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Unconfigured",
          "Connecting",
          "Authenticating",
          "Connected",
          "PendingDisconnect", -- currently support is not available for this state
          "Disconnecting",
          "Disconnected",
        },
      },
      LastConnectionError = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "ERROR_NONE",
          "ERROR_ISP_TIME_OUT",
          "ERROR_COMMAND_ABORTED",
          "ERROR_NOT_ENABLED_FOR_INTERNET",
          "ERROR_BAD_PHONE_NUMBER",
          "ERROR_USER_DISCONNECT",
          "ERROR_ISP_DISCONNECT",
          "ERROR_IDLE_DISCONNECT",
          "ERROR_FORCED_DISCONNECT",
          "ERROR_SERVER_OUT_OF_RESOURCES",
          "ERROR_RESTRICTED_LOGON_HOURS",
          "ERROR_ACCOUNT_DISABLED",
          "ERROR_ACCOUNT_EXPIRED",
          "ERROR_PASSWORD_EXPIRED",
          "ERROR_AUTHENTICATION_FAILURE",
          "ERROR_NO_DIALTONE",
          "ERROR_NO_CARRIER",
          "ERROR_NO_ANSWER",
          "ERROR_LINE_BUSY",
          "ERROR_UNSUPPORTED_BITSPERSECOND",
          "ERROR_TOO_MANY_LINE_ERRORS",
          "ERROR_IP_CONFIGURATION",
          "ERROR_UNKNOWN",
        },
      },
      AutoDisconnectTime = {
        access = "readOnly",  --readWrite not supported
        type = "unsignedInt",
      },
      IdleDisconnectTime = {
        access = "readOnly",  --readWrite not supported
        type = "unsignedInt",
      },
      WarnDisconnectDelay = {
        access = "readOnly",  --readWrite not supported
        type = "unsignedInt",
      },
      Username = {
        access = "readWrite",
        type = "string",
        max = "64",
      },
      Password = {
        access = "readWrite",
        hidden = "true",
        type = "string",
        max = "64",
      },
      EncryptionProtocol = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "None",
          "MPPE",
        },
      },
      CompressionProtocol = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "None",
          "Van Jacobson",
          "STAC LZS",
        },
      },
      AuthenticationProtocol = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "PAP",
          "CHAP",
          "MS-CHAP",
        },
      },
      MaxMRUSize = {
        access = "readOnly", -- readWrite not supported
        type = "unsignedInt",
        range = {
          {
            min = "64",
            max = "65535",
          },
        },
        default = "1500",
      },
      CurrentMRUSize = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
        range = {
          {
            min = "64",
            max = "65535",
          },
        },
      },
      ConnectionTrigger = {
        access = "readOnly",  -- readWrite not supported
        type = "string",
        enumeration = {
          "OnDemand",
          "AlwaysOn",
          "Manual",
        },
      },
      LCPEcho = {
        access = "readOnly",
        type = "unsignedInt",
      },
      LCPEchoRetry = {
        access = "readOnly",
        type = "unsignedInt",
      },
--[[ TODO
      IPCPEnable = {
        access = "readWrite",
        type = "boolean",
      },
      IPv6CPEnable = {
        access = "readWrite",
        type = "boolean",
      },
--]]
    }
  },
  aliasDefault = "Name"
}

local nwmodel = require "transformer.shared.models.device2.network"
local PPPInterface = nwmodel.register("PPPInterface", Device_PPP_Interface_i_.objectType.name)
local model

local nwCommon = mapper("nwcommon")
local uciHelper = mapper("ucihelper")
-- function aliases
local getUbusInterfaceStatus = nwCommon.get_ubus_interface_status
local getIntfInfo = nwCommon.getIntfInfo
local ubusConnection = mapper("ubus").connect()
local isConfigChanged = false
local match, gsub, open, commitApply = string.match, string.gsub, io.open, commitapply

-- binding for uciHelper
local binding = {config = "network", sectionname = "",option = "", default = ""}

-- convert pppstate to ConnectionStatus
local pppStateMap = {
  ["connected"]="Connected",
  ["disconnected"]="Disconnected",
  ["disconnecting"]="Disconnecting",
  ["authenticating"]="Authenticating",
  ["connecting"]="Connecting"
}

local lastConnectionErrorMap = {
  ["OK"]="ERROR_NONE",
  ["FATAL_ERROR"]="ERROR_COMMAND_ABORTED",
  ["OPTION_ERROR"]="ERROR_COMMAND_ABORTED",
  ["NOT_ROOT"]="ERROR_COMMAND_ABORTED",
  ["NO_KERNEL_SUPPORT"]="ERROR_COMMAND_ABORTED",
  ["USER_REQUEST"]="ERROR_USER_DISCONNECT",
  ["LOCK_FAILED"]="ERROR_COMMAND_ABORTED",
  ["OPEN_FAILED"]="ERROR_COMMAND_ABORTED",
  ["CONNECT_FAILED"]="ERROR_COMMAND_ABORTED",
  ["PTYCMD_FAILED"]="ERROR_COMMAND_ABORTED",
  ["NEGOTIATION_FAILED"]="ERROR_FORCED_DISCONNECT",
  ["PEER_AUTH_FAILED"]="ERROR_FORCED_DISCONNECT",
  ["IDLE_TIMEOUT"]="ERROR_IDLE_DISCONNECT",
  ["CONNECT_TIME"]="ERROR_ISP_DISCONNECT",
  ["CALLBACK"]="ERROR_COMMAND_ABORTED",
  ["PEER_DEAD"]="ERROR_FORCED_DISCONNECT",
  ["HANGUP"]="ERROR_ISP_DISCONNECT",
  ["LOOPBACK"]="ERROR_COMMAND_ABORTED",
  ["INIT_FAILED"]="ERROR_COMMAND_ABORTED",
  ["AUTH_TOPEER_FAILED"]="ERROR_ISP_DISCONNECT",
  ["TRAFFIC_LIMIT"]="ERROR_ISP_DISCONNECT",
  ["CNID_AUTH_FAILED"]="ERROR_USER_DISCONNECT",
  ["UNKNOWN_ERROR"]="ERROR_UNKNOWN"
}

local statusMap = {
  ["unknown"] = "Unknown",
  ["notpresent"] = "NotPresent",
  ["down"] = "Down",
  ["dormant"] = "Dormant",
  ["lowerlayerdown"] = "LowerLayerDown",
  ["up"] = "Up"
}

local paramMap = {
  ["Enable"] = "auto",
  ["Status"] = "device",
  ["Name"] = "ifname",
  ["Username"] = "username",
  ["Password"] = "password",
  ["IdleDisconnectTime"] = "demand",
  ["ConnectionTrigger"] = "demand",
  ["MaxMRUSize"] = "mtu",
  ["CurrentMRUSize"] = "ifname",
  ["LCPEcho"] = "pppd_options",
  ["LCPEchoRetry"] = "pppd_options",
  ["LowerLayers"] = "device"
}

local paramDefaults = {
  ["Enable"] = "1",
  ["IdleDisconnectTime"] = "0",
  ["MaxMRUSize"] = "1500",
  ["CurrentMRUSize"] = "0",
  ["LCPEcho"] = "0",
  ["LCPEchoRetry"] = "0",
  ["ConnectionTrigger"] = "AlwaysOn"
}

local pppdOptions = {
  ["LCPEcho"] = "lcp-echo-interval",
  ["LCPEchoRetry"] = "lcp-echo-failure"
}

Device_PPP_Interface_i_.entries = function(mapping, parentkey)
  model = nwmodel.load()
  return model:getKeys(PPPInterface)
end

local function getUciParam(mapping, param, key)
  binding.sectionname = model:getUciKey(key)
  binding.option = paramMap[param]
  binding.default = paramDefaults[param]
  return uciHelper.get_from_uci(binding)
end

local function getStatus(mapping, param, key, value)
  local device = model:getDevice(key)
  return statusMap[getIntfInfo(device,"operstate")] or ""
end

local function getConnStatus(mapping,param,key,value)
  local status = value or  getUbusInterfaceStatus(model:getInterface(key))
  if status and status.data and status.data.pppinfo then
    return status.data.pppinfo.pppstate and pppStateMap[status.data.pppinfo.pppstate] or "Disconnected"
  end
  return "Unconfigured"
end

local function getLastConnErr(mapping,param,key,value)
  local status = value or getUbusInterfaceStatus(model:getDevice(key))
  if status and status.errors then
    for _,error in pairs(status.errors) do
      if error.subsystem:match("^pppo[ea]") then
        return lastConnectionErrorMap[error.code] or "ERROR_UNKNOWN"
      end
    end
    return "ERROR_UNKNOWN"
  end
  return "ERROR_NONE"
end

local function getCurrentMRU(mapping,param,key,value)
  local device = value and value[paramMap[param]] or model:getDevice(key)
  return getIntfInfo(device,"mtu","0")
end

local function getAuthProto(mapping,param,key,value)
  local status = value or getUbusInterfaceStatus(model:getDevice(key))
  if status and status.data and status.data.pppinfo then
    return status.data.pppinfo.auth or ""
  end
  return ""
end

local function getPPPOptions(mapping,param,key,optionValue)
  local pppdOption = optionValue and optionValue[paramMap[param]] or getUciParam(mapping,param,key)
  local optionName = pppdOptions[param]
  local expression = gsub(optionName,"-","%%-") .. "%s+(%d+)"
  local value
  if pppdOption then
    value = match(pppdOption,expression)
    if value then
      return value
    end
  end
  
  value = ""
  local fileDescriptor = open("/etc/ppp/options","r")
  if fileDescriptor then
    for line in fileDescriptor:lines() do
      value = match(line,expression)
      if value then
        break
      end
    end
    fileDescriptor:close()
  end
  return value
end

local function getLowerLayer(mapping,param,key,value)
  return model:getLowerLayersResolved(key, resolve)
end

local function getConnectionTrigger(mapping,param,key,value)
  local connectionValue = value and value[paramMap[param]] or getUciParam(mapping,param,key)
  if connectionValue == "0" then
    return "AlwaysOn"
  end
  return "OnDemand"
end


Device_PPP_Interface_i_.get = {
  Enable = getUciParam,
  Status = getStatus,
  ConnectionStatus = getConnStatus,
  Name = function(mapping, param, key)
    return model:getName(key)
  end,
  Username = getUciParam,
  Password = getUciParam,
  LowerLayers = getLowerLayer,
  Reset = "0",
  LastConnectionError = getLastConnErr,
  AutoDisconnectTime = "0",
  IdleDisconnectTime = getUciParam,
  WarnDisconnectDelay = "0",
  AuthenticationProtocol = getAuthProto,
  EncryptionProtocol = "None",
  CompressionProtocol = "None",
  MaxMRUSize = getUciParam,
  CurrentMRUSize = getCurrentMRU,
  ConnectionTrigger = getConnectionTrigger,
  LCPEcho = getPPPOptions,
  LCPEchoRetry = getPPPOptions
}

Device_PPP_Interface_i_.getall = function(mapping,key)
  binding = {config = "network", sectionname = model:getUciKey(key),option = "", default = ""}
  local status = getUbusInterfaceStatus(model:getDevice(key))
  local uciValues = uciHelper.getall_from_uci(binding)
  return {
    Enable = uciValues[paramMap["Enable"]] or paramDefaults["Enable"],
    Status = getStatus(mapping,"Status",key,status),
    ConnectionStatus = getConnStatus(mapping,"ConnectionStatus",key),
    Name = model:getName(key),
    Username = uciValues[paramMap["Username"]] or "",
    Password = uciValues[paramMap["Password"]] or "",
    LowerLayers = getLowerLayer(mapping,"LowerLayers",key,uciValues),
    Reset = "0",
    LastConnectionError = getLastConnErr(mapping,"LastConnectionError",key,status),
    AutoDisconnectTime = "0",
    IdleDisconnectTime = uciValues[paramMap["IdleDisconnectTime"]] or paramDefaults["IdleDisconnectTime"],
    WarnDisconnectDelay = "0",
    AuthenticationProtocol = getAuthProto(mapping,"AuthenticationProtocol",key,status),
    EncryptionProtocol = "None",
    CompressionProtocol = "None",
    MaxMRUSize = uciValues[paramMap["MaxMRUSize"]] or paramDefaults["MaxMRUSize"],
    CurrentMRUSize = getCurrentMRU(mapping,"CurrentMRUSize",key,uciValues),
    ConnectionTrigger = getConnectionTrigger(mapping,"ConnectionTrigger",key,uciValues),
    LCPEcho = getPPPOptions(mapping,"LCPEcho",key,uciValues),
    LCPEchoRetry = getPPPOptions(mapping,"LCPEchoRetry",key,uciValues)
  }
end

local function setUciParam(mapping, param, value, key)
  binding.sectionname = model:getUciKey(key)
  binding.option = paramMap[param]
  uciHelper.set_on_uci(binding, value, commitApply)
  isConfigChanged = true
end

Device_PPP_Interface_i_.set = {
  Enable = setUciParam,
  Username = setUciParam,
  Password = setUciParam,
  Reset = function(mapping, param, value, key)
    if value == "1" then
      local fileHandler = open("/tmp/.ppp_intf","w")
      if fileHandler then
        fileHandler:write(key)
        fileHandler:close()
        commitApply:newset("Device.PPP.Interface.{i}.Reset")
      else
        return nil, "unexpected write error"
      end
    else
      return true
    end
  end,
}

Device_PPP_Interface_i_.commit = function()
  if isConfigChanged then
    uciHelper.commit(binding)
    isConfigChanged = false
  end
end

Device_PPP_Interface_i_.revert = function()
  if isConfigChanged then
    uciHelper.revert(binding)
    isConfigChanged = false
  end
end

local function setEvent(mapping, action, config, sectionType, sectionName, option)
  return { { key = sectionName, paramname = "Username" } }
end

Device_PPP_Interface_i_.add_watchers = function(mapping, param, key)
  local uci_evsrc = eventsource("uci")
  uci_evsrc.watch(mapping, { set = setEvent }, "network", "interface", key, "username")
end

register(Device_PPP_Interface_i_)
