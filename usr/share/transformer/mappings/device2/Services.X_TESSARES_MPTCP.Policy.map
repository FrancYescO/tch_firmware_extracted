-- Manually generated
local Device_Services_X_TESSARES_MPTCP_Policy_ = {
  objectType = {
    name = "Device.Services.X_TESSARES_MPTCP.Policy.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      ServerAddress = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      ServerPort = {
        access = "readWrite",
        type = "unsignedInt",
      },
      Username = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      Password = {
        access = "readWrite",
        hidden = true,
        type = "string",
        max = "256",
      },
      Blacklist = {
        access = "readWrite",
        type = "string",
        max = "12000",
      },
    }
  }
}

local inet = require("tch.inet")
local mapper, ipairs = mapper, ipairs
local mproxyBinding = { config = "mproxy", sectionname = "policy" }
local networkBinding = { config = "network" }
local uciHelper = mapper("ucihelper")
local ubusConnection = mapper("ubus").connect()
local configChanged = false
local interfaces = {'voip_mgmt', 'iptv'}

local paramMap = {
  ["ServerAddress"]  = "server_address",
  ["ServerPort"] = "server_port",
  ["Username"]  = "username",
  ["Password"]  = "password",
  ["Blacklist"] = "blacklist",
}

local function getUciValue(mapping, param, default)
  mproxyBinding.option = paramMap[param]
  mproxyBinding.default = default
  return uciHelper.get_from_uci(mproxyBinding)
end

-- ["^:"]   - If the value starts with ":" then replace it with "*:"
-- ["::"]   - If the value contains "::" then replace it with ":*:"
-- [".*:$"] - If the value ends with ":" then replace it with ":*"
local pattern = { ["^:"] = "*%1", ["::"] = ":*:", [".*:$"] = "%1*" }

local function getBlacklist(mapping, param)
  local valuefinal = {}
  local uciVal = getUciValue(mapping, param, {})

  -- blacklist value should be returned in 5-tuple format
  -- PROTO:SRC_IP/MASK[SRC_PORT_RANGE]:DST_IP/MASK[DST_PORT_RANGE], with any field being potentially *
  for _, destination in ipairs(uciVal) do
    if destination:match(":") then
      for pat, val in pairs(pattern) do
        destination = destination:gsub(pat, val)
      end
      valuefinal[#valuefinal + 1] = destination
    else
      valuefinal[#valuefinal + 1] = "*:*:" .. destination
    end
  end
  for _, v in ipairs(interfaces) do
    local value = uciHelper.get_from_uci({ config = "mproxy", sectionname = v, option = "blacklist", default = {} })
    for _, dest in ipairs(value) do
      local ubusStatus = ubusConnection:call("network.interface." .. v, "status", {})
      local staticRoutes = {}
      if ubusStatus and ubusStatus["route"] then
        staticRoutes = ubusStatus["route"]
      end
      for _, route in ipairs(staticRoutes) do
        if route.target .. "/" .. route.mask == dest then
          valuefinal[#valuefinal + 1] = "*:" .. route.source .. ":" .. route.target .. "/" .. route.mask
        end
      end
    end
  end
  return table.concat(valuefinal, ",")
end

local function setUciValue(mapping, param, value)
  mproxyBinding.option = paramMap[param]
  uciHelper.set_on_uci(mproxyBinding, value, commitapply)
  configChanged = true
end

-- Returns true if the port is in the format [start_port-end_port]
local function portValid(port)
  if not port or port == "" then
    return true
  end
  local start, endPort = port:match("^%[(%d+)%-(%d+)%]$")
  if start and endPort and (tonumber(start) <= tonumber(endPort)) then
    return true
  end
end

local function ipAndMaskValid(ipAddress)
  if ipAddress and ipAddress == "" then
    return true
  end
  --Extract the ip, mask and port from the input in the format: ip/mask[port]
  local ip, mask, port = ipAddress:match("^([^/%[]*)%/?([^%[]*)(%[?[^%]]*%]?)")
  if (ip == "" or inet.isValidIPv4(ip)) and (mask == "" or tonumber(mask) <= 32) and portValid(port) then
    return true
  end
end

local function fiveTupleValidation(val)
  if val:match(":") then
    local src, dest = val:match(".*:(.*):(.*)")
    if ipAndMaskValid(src) and ipAndMaskValid(dest) then
      return true
    end
  else
    return ipAndMaskValid(val)
  end
end

local function setBlacklist(mapping, param, value)
  local valueList = {}
  for val in value:gmatch('([^,]+)') do
    if val:match(":") then
      local _, times = val:gsub(":", ":")
      if times > 2 then
        return nil, "Not a Valid format"
      end
      val = val:gsub("*","")
    end
    if fiveTupleValidation(val) then
      valueList[#valueList +1] = val
    else
      return nil, "Not a Valid format"
    end
  end
  setUciValue(mapping, param, valueList)
end

Device_Services_X_TESSARES_MPTCP_Policy_.get = function(mapping, param)
  if param == "Blacklist" then
    return getBlacklist(mapping, param)
  end
  return getUciValue(mapping, param)
end

Device_Services_X_TESSARES_MPTCP_Policy_.getall = function()
  local allValues = uciHelper.getall_from_uci(mproxyBinding)
  return {
    ServerAddress = allValues["server_address"] or "",
    ServerPort = allValues["server_port"] or "",
    Username = allValues["username"] or "",
    Password = allValues["password"] or "",
    Blacklist = getBlacklist(nil, "Blacklist") or ""
  }
end

Device_Services_X_TESSARES_MPTCP_Policy_.set = function(mapping, param, value)
  if param == "Blacklist" then
    return setBlacklist(mapping, param, value)
  end
  return setUciValue(mapping, param, value)
end

Device_Services_X_TESSARES_MPTCP_Policy_.commit = function()
  if configChanged then
    uciHelper.commit(mproxyBinding)
    configChanged = false
  end
end

Device_Services_X_TESSARES_MPTCP_Policy_.revert = function()
  if configChanged then
    uciHelper.revert(mproxyBinding)
    configChanged = false
  end
end

register(Device_Services_X_TESSARES_MPTCP_Policy_)
