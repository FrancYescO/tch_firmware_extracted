--Automatically generated from Device:2.10
-- using generator version 2.3
local Device_WiFi_Radio_i_ = {
  objectType = {
    name = "Device.WiFi.Radio.{i}.",
    access = "readOnly",
    numEntriesParameter = "RadioNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Up",
          "Down",
          "Unknown",
          "Dormant",
          "NotPresent",
          "LowerLayerDown",
          "Error",
        },
      },
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
        max  = "64",
      },
      Name = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
      LastChange = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      LowerLayers = {
        access = "readOnly", -- this is the lowest layer
        list = true,
        max = "1024",
        type = "string",
        pathRef = true,
      },
      Upstream = {
        access = "readOnly",
        type = "boolean",
      },
      MaxBitRate = {
        access = "readOnly",
        type = "unsignedInt",
      },
      SupportedFrequencyBands = {
        access = "readOnly",
        list = true,
        type = "string",
        enumeration = {
          "2.4GHz",
          "5GHz",
        },
      },
      OperatingFrequencyBand = {
        access = "readOnly",  -- this cannot be changed
        type = "string",
        enumeration = {
          "2.4GHz",
          "5GHz",
        },
      },
      SupportedStandards = {
        access = "readOnly",
        list = true,
        type = "string",
        enumeration = {
          "a",
          "b",
          "g",
          "n",
          "ac",
          "ax",
        },
      },
      OperatingStandards = {
        access = "readWrite",
        list = true,
        type = "string",
        enumeration = {
          "a",
          "b",
          "g",
          "n",
          "ac",
          "ax",
        },
      },
      PossibleChannels = {
        access = "readOnly",
        list = true,
        max = "1024",
        type = "string",
      },
      ChannelsInUse = {
        access = "readOnly",
        activeNotify = "canDeny",
        list = true,
        max = "1024",
        type = "string",
      },
      Channel = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
            max = "255",
          },
        },
      },
      AutoChannelSupported = {
        access = "readOnly",
        type = "boolean",
      },
      AutoChannelEnable = {
        access = "readWrite",
        type = "boolean",
      },
      AutoChannelRefreshPeriod = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "604800",
          },
        },
      },
      OperatingChannelBandwidth = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "20MHz",
          --[[ currently not supported due to unavailable lower layer support
          "40MHz",
          "80MHz",
          "160MHz",
          --]]
          "Auto",
        },
      },
      CurrentOperatingChannelBandwidth = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "20MHz",
          "40MHz",
          "80MHz",
          "160MHz",
        },
      },
      ExtensionChannel = {
        access = "readOnly", -- readwrite currently not supported
        type = "string",
        enumeration = {
          "AboveControlChannel",
          "BelowControlChannel",
          "Auto",
        },
      },
      GuardInterval = {
        access = "readWrite",
        type = "string",
        enumeration = {
          -- "400nsec", Restricting Enum values because 'sgi' will return boolean values.
          "800nsec",
          "Auto",
        },
      },
--[[ TODO
      MCS = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
            max = "15",
          },
          {
            min = "16",
            max = "31",
          },
        },
      },
--]]
      TransmitPower = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
            max = "100",
          },
        },
      },
      TransmitPowerSupported = {
        access = "readOnly",
        list = true,
	max = "64",
        type = "int",
        range = {
          {
            min = "-1",
            max = "100",
          },
        },
      },
      IEEE80211hSupported = {
        access = "readOnly",
        type = "boolean",
      },
      IEEE80211hEnabled = {
        access = "readOnly", -- readwrite currently not supported
        type = "boolean",
      },
      RegulatoryDomain = {
        access = "readWrite",
        type = "string",
        min = "3",
        max = "3",
      },
--[[ TODO
      RetryLimit = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "7",
          },
        },
      },
      CCARequest = {
        access = "readWrite",
        type = "hexBinary",
        min = "11",
        max = "11",
      },
      CCAReport = {
        access = "readOnly",
        type = "hexBinary",
        min = "12",
        max = "12",
      },
      RPIHistogramRequest = {
        access = "readWrite",
        type = "hexBinary",
        min = "11",
        max = "11",
      },
      RPIHistogramReport = {
        access = "readOnly",
        type = "hexBinary",
        min = "19",
        max = "19",
      },
      FragmentationThreshold = {
        access = "readWrite",
        type = "unsignedInt",
      },
      LongRetryLimit = {
        access = "readWrite",
        type = "unsignedInt",
      },
      PacketAggregationEnable = {
        access = "readWrite",
        type = "boolean",
      },
--]]
      RTSThreshold = {
        access = "readOnly", -- readwrite currently not supported due to unavailable lower layer support
        type = "unsignedInt",
      },
      PreambleType = {
        access = "readOnly", -- readwrite currently not supported due to unavailable lower layer support
        type = "string",
        enumeration = {
          "short",
          "long",
          "auto",
        },
      },
      DTIMPeriod = {
        access = "readOnly", -- readwrite currently not supported due to unavailable lower layer support
        type = "unsignedInt",
      },
      BeaconPeriod = {
        access = "readOnly", -- readwrite currently not supported due to unavailable lower layer support
        type = "unsignedInt",
      },
      BasicDataTransmitRates = {
        access = "readWrite",
        list = true,
        type = "string",
      },
      OperationalDataTransmitRates = {
        access = "readWrite",
        list = true,
        type = "string",
      },
      SupportedDataTransmitRates = {
        access = "readOnly",
        list = true,
        type = "string",
      },
      ChannelLastChange = {
        access = "readOnly",
        type = "unsignedInt",
      },
      X_000E50_ACSRescanPeriod = {
        access = "readWrite",
        type = "unsignedInt",
        description = "Specifies the Rescan time period of ACS in seconds",
        range = {
          {
            min = "0",
            max = "604800",
          },
        },
      },
      X_000E50_ACSRescanDelayPolicy = {
        access = "readWrite",
        type = "string",
        description = "Indicates the ACS rescan delay policy (always/notraffic)",
        -- As per the implementation,it accepts only the following values.
        enumeration = {
          "always",
          "nostation",
          "notraffic",
        },
      },
      X_000E50_ACSRescanDelay = {
        access = "readWrite",
        type = "unsignedInt",
        description = "Specifies the time period of Rescan delay in seconds",
        range = {
          {
            min = "10",
            max = "3600",
          },
        },
      },
      X_000E50_ACSRescanDelayMaxEvents = {
        access = "readWrite",
        type = "unsignedInt",
        description = "Maximum amount of times a rescan is allowed to be delayed",
        range = {
          {
            min = "1",
            max = "999",
          },
        },
      },
      X_000E50_ACSRescan = {
        access = "readWrite",
        type = "boolean",
        description = "Triggers ACS rescan once when value is set to 1",
      },
      X_000E50_SetDefAcAgg = {
        access = "readWrite",
        type = "boolean",
        description = "Enables agg holding time for WMM video packets"
      },
      X_000E50_MUMIMO = {
        access = "readWrite",
        type = "boolean",
        description = "Enables or disables transmit MU MIMO",
      },
      X_000E50_ACSDFSReEntry = {
        access = "readWrite",
        type = "boolean",
        description = "Enables or disables the zero wait DFS Re-Entry functionality",
      },
      X_000E50_ACSTXTrafficThreshold = {
        access = "readWrite",
        type = "int",
        description = "Specifies TX traffic detection threshold [packets/monitor period]",
        range = {
          {
            min = "1",
            max = "9999",
          },
        },
      },
      X_000E50_ACSRXTrafficThreshold = {
        access = "readWrite",
        type = "int",
        description = "Specifies RX traffic detection threshold [packets/monitor period]",
        range = {
          {
            min = "1",
            max = "9999",
          },
        },
      },
      X_000E50_ACSTrafficSensePeriod = {
        access = "readWrite",
        type = "int",
        description = "Specifies the period over which the traffic on the WLAN interface is monitored",
        range = {
          {
            min = "5",
            max = "60",
          },
        },
      },
      X_000E50_AllowedChannels = {
        access = "readWrite",
        list = true,
        max = "1024",
        type = "string",
        description = "Possible radio channels for the wireless standard",
      },
    }
  },
  aliasDefault = "Name",
}

local nwmodel = require "transformer.shared.models.device2.network"
local WifiRadio = nwmodel.register("WifiRadio", Device_WiFi_Radio_i_.objectType.name)
local model
local nwWifi = require "transformer.shared.wifi"
local tostring, string, table, gmatch, gsub = tostring, string, table, string.gmatch, string.gsub
local format = string.format
local commitapply, mapper, register = commitapply, mapper, register
local uci_helper = mapper("ucihelper")
local conn = mapper("ubus").connect()
local getall_from_uci = uci_helper.getall_from_uci
local wirelessBinding = {config="wireless"}
local posix = require("tch.posix")
local getClockTime = posix.clock_gettime
local lastStateChangeTime = {}
local split_key = mapper("nwcommon").split_key
local floor = math.floor

-- Embedded allowed channels list for EU/US countries so that it can be used for validation in mappings
local allowedChannelsMap2G = {
  ["US GB"] = { 1,2,3,4,5,6,7,8,9,10,11 },
  ["EU FR BE BG HR CY CZ DK EE FI DE GR HU IE IT LV LT LU MT NL PL PT RO SK SI ES SE CH NO"] = { 1,2,3,4,5,6,7,8,9,10,11,12,13 }
}

local allowedChannelsMap5G = {
  ["US GB"] = { 36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,144,149,153,157,161,165 },
  ["EU FR BE BG HR CY CZ DK EE FI DE GR HU IE IT LV LT LU MT NL PL PT RO SK SI ES SE CH NO"] = { 36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140 }
}

-- convert ext_channel_location to ExtensionChannel
local extChannelMap = {
  ["upper"] = "AboveControlChannel",
  ["lower"] = "BelowControlChannel",
  [""] = "Auto",
}

local cache = {
  uci = {},
  ubus = {}
}

local function drop_cache()
  cache.uci = {}
  cache.ubus = {}
end

local function getFromUci(key, option)
  local data = cache.uci[key]
  if not data then
    wirelessBinding.sectionname = key
    wirelessBinding.option = nil
    data = getall_from_uci(wirelessBinding)
    cache.uci[key] = data or {}
  end
  return data[option]
end

local function getFromUbus(key, option)
  local data = cache.ubus[key]
  if not data then
    for k, info in pairs(conn:call("wireless.radio", "get", {}) or {}) do
      cache.ubus[k] = info
    end
    data = cache.ubus[key] or {}
  end
  return data[option]
end

local function getOption(modelKey, uciOption, ubusOption)
  local key = model:getUciKey(modelKey)
  local value
  if uciOption then
    value = getFromUci(key, uciOption)
  end
  if not value and ubusOption then
    value = getFromUbus(key, ubusOption)
  end
  return value and tostring(value)
end

local function getUbusDataValue(radioKey, ubusStr)
  local data = conn:call("wireless.radio.acs", "get",  { name = radioKey }) or {}
  if ubusStr then
    return data[radioKey] and data[radioKey][ubusStr] or ""
  else
    local scan = data[radioKey] and data[radioKey]["scan_report"] or ""
    local channel_stats = data[radioKey] and data[radioKey]["channel_stats"] or ""
    return scan, channel_stats
  end
end

local uci_changed
local function setOption(modelKey, option, value)
  local key = model:getUciKey(modelKey)
  local old = getOption(key, option)
  if value~=old then
    cache.uci[key].option = value
    wirelessBinding.sectionname = key
    wirelessBinding.option = option
    uci_helper.set_on_uci(wirelessBinding, value, commitapply)
    uci_changed = true
  end
end

local function end_transaction(uci_action)
  drop_cache()
  if uci_changed then
    uci_action(wirelessBinding)
    uci_changed = false
  end
end

function Device_WiFi_Radio_i_.entries(mapping)
  drop_cache()
  model = nwmodel.load()
  return model:getKeys(WifiRadio)
end

local validStds = {
  ["2.4GHz"] = {
    b = true,
    g = true,
    n = true,
    ax = true,
  },
  ["5GHz"] = {
    a = true,
    n = true,
    ac = true,
    ax = true,
  }
}
local stdOrder = {"b", "g", "a", "n", "ac", "ax"}

local function wifiStdToList(std)
  local r = {}
  for v in std:gmatch("[abgn][cx]?") do
    r[#r+1] = v
  end
  return r
end

local function formatChannelsList(channels)
    local v = channels:gsub("%s+", ",") --replace runs of spaces with a single comma
    return v:match("^,?(.-),?$") --get rid of possible starting and/or ending comma
end

-- Maps uci values of mumimo with its equivalent Enumerations and viceversa
local mumimoUciEnumMap = {
  ["on"] = "ON",
  ["0"] = "OFF",
  ["1"] = "Auto",
  ["ON"] = "on",
  ["OFF"] = "0",
  ["Auto"] = "1",
}

local supportedBW = {
  ["160"] = "20,40,80,160",
  ["80"] = "20,40,80",
  ["40"] = "20,40",
  ["20"] = "20"
}

Device_WiFi_Radio_i_.get = {
  Enable = function(mapping, param, key)
    return getOption(key, "state", "admin_state") or "0"
  end,

  Status = function(mapping, param, key)
    local state = getOption(key, nil, "oper_state")
    if state == "1" then
      return 'Up'
    elseif state == "0" then
      return 'Down'
    else
      return 'Error'
    end
  end,

  Name = function(mapping, param, key)
    return model:getName(key)
  end,

  LastChange = function(mapping, param, key)
    return tostring(getClockTime(posix.CLOCK_MONOTONIC) - (lastStateChangeTime[key] or 0))
  end,

  LowerLayers = "",

  Upstream = "0",

  Channel = function(mapping, param, key)
    local channel = getOption(key, "channel") or "auto"
    if channel=="auto" then
      -- channel not available in uci
      channel = getOption(key, nil, "channel") or "255"
    end
    return channel
  end,

  BeaconPeriod = function(mapping, param, key)
    return getOption(key, "beacon_period", "beacon_period") or ""
  end,

  DTIMPeriod = function(mapping, param, key)
    return getOption(key, "dtim_interval", "dtim_interval") or ""
  end,

  PreambleType = function(mapping, param, key)
    return getOption(key, "short_slot", "short_slot") or ""
  end,

  RTSThreshold = function(mapping, param, key)
    return getOption(key, "rts_threshold", "rts_threshold") or ""
  end,

  GuardInterval = function(mapping, param, key)
    local value = getOption(key, "sgi", "sgi")
    if value == "1" then
      return "Auto"
    end
    return "800nsec"
  end,

  TransmitPower = function(mapping, param, key)
    local max_target_power = getOption(key, "max_target_power", "max_target_power")
    local max_target_power_adjusted = getOption(key, "max_target_power_adjusted", "max_target_power_adjusted")
    local power = nwWifi.getTxPower(max_target_power, max_target_power_adjusted)
    return power == "" and "100" or tostring(power)
  end,

  TransmitPowerSupported = "10,20,30,40,50,60,70,80,90,100",

  AutoChannelSupported = "1",

  AutoChannelEnable = function(mapping, param, key)
    local req = getOption(key, "channel", "requested_channel")
    if req == "auto" then
      return '1'
    else
      return '0'
    end
  end,

  AutoChannelRefreshPeriod = function(mapping, param, key)
    local uciKey = model:getUciKey(key)
    local refreshPeriod = getFromUci(uciKey, "acs_rescan_period")
    if not refreshPeriod then
      refreshPeriod = tostring(getUbusDataValue(uciKey, "rescan_period")) or "0"
    end
    return refreshPeriod
  end,

  MaxBitRate = function(mapping, param, key)
    local bitRate = getOption(key, nil, "max_phy_rate")
    return bitRate and tostring(floor(bitRate/1000)) or "0"
  end,

  SupportedFrequencyBands = function(mapping, param, key)
    return getOption(key, nil, "supported_frequency_bands") or ""
  end,

  OperatingFrequencyBand = function(mapping, param, key)
    return getOption(key, nil, "band") or ""
  end,

  SupportedStandards = function(mapping, param, key)
    local standard = getOption(key, nil, "supported_standards") or ""
    return table.concat(wifiStdToList(standard), ",")
  end,

  OperatingStandards = function(mapping, param, key)
    local standard = getOption(key, "standard", "standard") or ""
    return table.concat(wifiStdToList(standard), ",")
  end,

  PossibleChannels = function(mapping, param, key)
    return formatChannelsList(getOption(key, nil, "allowed_channels") or "")
  end,

  ChannelsInUse = function(mapping, param, key)
    return formatChannelsList(getOption(key, nil, "used_channels") or "")
  end,

  OperatingChannelBandwidth = function(mapping, param, key)
    return getOption(key, nil, "requested_channel_width") or "Auto"
  end,

  CurrentOperatingChannelBandwidth = function(mapping, param, key)
    return getOption(key, nil, "channel_width") or ""
  end,

  RegulatoryDomain = function(mapping, param, key)
    local country = getOption(key, "country", "country") or ""
    -- currently hostapd daemon does not support 3rd character, hence by default "I" (inside) is appended
    return country ~= "" and country .. "I" or country
  end,

  BasicDataTransmitRates = function(mapping, param, key)
    local rateset = getOption(key, "rateset", "rateset") or ""
    local basicrates = {}
    for rate in rateset:gmatch("([%d.]+)%(b%)") do
        basicrates[#basicrates+1] = rate
    end
    return table.concat(basicrates, ",")
  end,

  OperationalDataTransmitRates = function(mapping, param, key)
    local rateset = getOption(key, "rateset", "rateset") or ""
    local r = {}
    -- only keep the rate numbers, get rid of '(b)'
    for rate in rateset:gmatch("([%d.]+)") do
      r[#r+1] = rate
    end
    return table.concat(r, ",")
  end,

  ExtensionChannel = function(mapping, param, key)
    return extChannelMap[getOption(key, nil, "ext_channel_location") or ""] or ""
  end,

  IEEE80211hSupported = function(mapping, param, key)
    if (getOption(key, nil, "supported_frequency_bands") or "") == "5GHz" then
      local std = getOption(key, nil, "supported_standards") or ""
      if std:match("a?n") then
        return "1"
      end
    end
    return "0"
  end,

  IEEE80211hEnabled = function(mapping, param, key)
    if (getOption(key, nil, "band") or "") == "5GHz" then
      local std = getOption(key, nil, "standard") or ""
      if std:match("a?n") then
        return "1"
      end
    end
    return "0"
  end,
  SupportedDataTransmitRates = function(mapping, param, key)
    local rateSet = getOption(key, "rateset", "rateset") or ""
    local suppRates = {}
    for rate in rateSet:gmatch("([%d.]+)%(b%)") do
      suppRates[#suppRates+1] = rate
    end
    return table.concat(suppRates, ",")
  end,
  ChannelLastChange = function(mapping, param, key)
    local lastChange
    local data = conn:call("wireless.radio.acs", "get", { name = key }) or {}
    local scanHistory = data[key] and data[key].scan_history or ""
    local timestamp = scanHistory:match("[^;]+;([^;]+);[^;]+;[^;]+;[^;]+;[^;]+;[^;]+;$")
    if timestamp then
      local hr, min, sec, date, mon, yr = timestamp:match("(%d+):(%d+):(%d+)%-(%d+)/(%d+)/(%d+)")
      local changeTime = os.time({ year = yr, month = mon, day = date, hour = hr, min = min, sec = sec })
      local now = os.time()
      -- calculate the time difference with current time in GMT format as ubus call format is GMT
      lastChange = os.difftime(os.time(os.date("!*t", now)), changeTime)
    end
    return lastChange and tostring(lastChange) or "0"
  end,
  X_000E50_ACSRescan = "0",
  X_000E50_ACSRescanPeriod = function(mapping, param, key)
    local uciKey = model:getUciKey(key)
    local refreshPeriod = getFromUci(uciKey, "acs_rescan_period")
    if not refreshPeriod then
      refreshPeriod = tostring(getUbusDataValue(uciKey, "rescan_period")) or "0"
    end
    return refreshPeriod
  end,
  X_000E50_ACSRescanDelayPolicy = function(mapping, param, key)
    local uciKey = model:getUciKey(key)
    local delayPolicy = getFromUci(uciKey, "acs_rescan_delay_policy") or ""
    if delayPolicy == "" then
      delayPolicy = getUbusDataValue(uciKey, "rescan_delay_policy") or ""
    end
    return delayPolicy:lower()
  end,
  X_000E50_ACSRescanDelay = function(mapping, param, key)
    local uciKey = model:getUciKey(key)
    local rescanDelay = getFromUci(uciKey, "acs_rescan_delay") or ""
    if rescanDelay == "" then
      rescanDelay = tostring(getUbusDataValue(uciKey, "rescan_delay")) or "0"
    end
    return rescanDelay
  end,
  X_000E50_ACSRescanDelayMaxEvents = function(mapping, param, key)
    local uciKey = model:getUciKey(key)
    local maxEvents = getFromUci(uciKey, "acs_rescan_delay_max_events") or ""
    if maxEvents == "" then
      maxEvents = tostring(getUbusDataValue(uciKey, "rescan_delay_max_events")) or "0"
    end
    return maxEvents
  end,
  X_000E50_ACSTXTrafficThreshold = function(mapping, param, key)
    return getOption(key, "acs_tx_traffic_threshold", "tx_traffic_threshold") or "0"
  end,
  X_000E50_ACSRXTrafficThreshold = function(mapping, param, key)
    return getOption(key, "acs_rx_traffic_threshold", "rx_traffic_threshold") or "0"
  end,
  X_000E50_ACSTrafficSensePeriod = function(mapping, param, key)
    return getOption(key, "acs_traffic_sense_period", "traffic_sense_period") or "0"
  end,
  X_000E50_SetDefAcAgg = function(mapping, param, key)
    local uciKey = model:getUciKey(key)
    local radioType = getFromUci(uciKey, "type") or ""
    return radioType == "quantenna" and getFromUci(uciKey, "ac_agg_vi") and "0" or "1"
  end,
  X_000E50_MUMIMO = function(mapping, param, key)
    return getOption(key, "mumimo") or "0"
  end,
  X_000E50_ACSDFSReEntry = function(mapping, param, key)
    local acsreentry = conn:call("wireless.radio.acs", "get", { name = key }) or {}
    return acsreentry and acsreentry[key] and acsreentry[key]["dfs_reentry"] and acsreentry[key]["dfs_reentry"] == "bgdfs" and "1" or "0"
  end,
  X_000E50_AllowedChannels = function(mapping, param, key)
    return formatChannelsList(getOption(key, nil, "allowed_channels") or "")
  end,
}

-- Required Input Pattern for OperatingStandards param
local reqOpStds = {
  ["2.4GHz"] = {
    ["bg"] = {
      ["b,g"] = true,
    },
    ["bgn"] = {
      ["b,g"] = true,
      ["b,g,n"] = true,
    },
    ["bgnax"] = {
      ["b,g,n"] = true,
      ["ax,b,g,n"] = true,
    }
  },
  ["5GHz"] = {
    ["an"] = {
      ["a,n"] = true,
    },
    ["anac"] = {
      ["a,n"] = true,
      ["a,ac,n"] = true,
    },
    ["anacax"] = {
      ["a,ac,n"] = true,
      ["a,ac,ax,n"] = true,
    }
  }
}

-- Nomalize value to be usable as key in reqOpStds
-- @param value the OperatingStandards value
-- @return normalized OperatingStandards value
local function normalizeOpStd(value)
  local opStd = {}
  for std in value:gmatch("(%a+),?") do
    opStd[#opStd + 1] = std
  end
  table.sort(opStd)
  return table.concat(opStd, ",") or ""
end

-- Validate the OperatingStandards value
-- @param key the radio name
-- @param value the OperatingStandards value
-- @param band the UBUS band value
-- @param suppStd the UBUS SupportedStandards value
-- @return OparatingStandards value
local function validOpStds(key, value, band, suppStd)
  value = normalizeOpStd(value)
  return reqOpStds[band] and reqOpStds[band][suppStd] and reqOpStds[band][suppStd][value]
end

local function setOperatingStandards(key, value, param)
  local band = getOption(key, nil, "band") or ""
  local suppStd = getOption(key, nil, "supported_standards") or ""
  if validOpStds(key, value, band, suppStd) then
    local setList = {}
    for std in value:gmatch("(%a+),?") do
      if not validStds[band][std] then
        return nil, format("Setting %s on %s band is not allowed", std, band)
      end
      setList[std] = true
    end
    value = {}
    for _, std in ipairs(stdOrder) do
      if setList[std] then
        value[#value+1] = std
      end
    end
    value = table.concat(value, "")
    setOption(key, "standard", value)
  else
    return nil, format("Setting '%s' pattern on '%s' band is not allowed", value, band)
  end
end

-- Maps equivalent "channelwidth" from device2 datamodel to uci
-- Contains the lowerlayer supported channelwidth
local channelWidthFromDevToUci = {
  ["radio_2G"] = {
    ["Auto"]  = "auto",
    ["20MHz"] = "20MHz"
  },
  ["radio_5G"] = {
    ["Auto"]   = "auto",
    ["20MHz"]  = "20MHz",
    ["40MHz"]  = "20/40MHz",
    ["80MHz"]  = "20/40/80MHz",
    ["160MHz"] = "20/40/80/160MHz"
  },
  ["radio2"] = {
    ["Auto"]  = "auto",
    ["20MHz"] = "20MHz",
    ["40MHz"] = "20/40MHz",
    ["80MHz"] = "20/40/80MHz",
    ["160MHz"] = "20/40/80/160MHz"
 }
}

local function isAllowedChannel(country, currChannel, radio)
  local channelMap = radio == "radio_2G" and allowedChannelsMap2G or allowedChannelsMap5G
  for codes, channelList in pairs(channelMap) do
    if codes:match(country) then
      for _, channel in ipairs(channelList) do
        if tonumber(currChannel) == tonumber(channel) then
          return true
        end
      end
    end
  end
end

Device_WiFi_Radio_i_.set = {
  Enable = function(mapping, param, value, key)
    return setOption(key, "state", value)
  end,

  OperatingStandards = function(mapping, param, value, key)
    return setOperatingStandards(key, value, param)
  end,

  Channel = function(mapping, param, value, key)
    local allowedChannels = getOption(key, nil, "allowed_channels")
    if not allowedChannels then
      return setOption(key, "channel", value)
    end
    for channel in allowedChannels:gmatch("(%d+)") do
      if channel == value then
        return setOption(key, "channel", value)
      end
    end
    return nil, "Given channel is not allowed"
  end,

  AutoChannelEnable = function(mapping, param, value, key)
    -- As of now, disabling of AutoChannelEnable on a disabled radio is not handled
    local channelValue = getOption(key, "channel") or "auto"
    if value == "1" then
      value = "auto"
      if channelValue == "auto" then
        commitapply:newset("Device.WiFi.Radio.{i}.AutoChannelEnable")
      end
    elseif value == "0" then
      if channelValue ~= "auto" then
        value = channelValue -- just keep the value already set
      else
        value = getOption(key, nil, "channel") or "" --use the current one
      end
    end
    setOption(key, "channel", value)
  end,

  GuardInterval = function(mapping, param, value, key)
    if value == "Auto" then
      value = "1"
    else
      value = "0"
    end
    setOption(key, "sgi", value)
  end,

  TransmitPower = function(mapping, param, value, key)
    local maxPower = getOption(key, "max_target_power", "max_target_power")
    local power = nwWifi.setTxPower(maxPower, value)
    if power then
      return setOption(key, "tx_power_adjust", power)
    end
    return nil,"Invalid power value"
  end,

  AutoChannelRefreshPeriod = function(mapping, param, value, key)
    if value == "0" or tonumber(value) >= 60 then
      setOption(key, "acs_rescan_period", value)
    else
      return nil,"Refresh Period must be 0 (only at boottime) or at least 60s"
    end
  end,

  OperatingChannelBandwidth = function(mapping, param, value, key)
    local supportedChannelWidth = channelWidthFromDevToUci[key][value]
    if supportedChannelWidth then
      return setOption(key, "channelwidth", supportedChannelWidth)
    else
      return nil, format("Cannot set channelwidth to %s as it is not a %s channel width", value, key)
    end
  end,

  RegulatoryDomain = function(mapping, param, value, key)
    local country = value:match("^([A-Z][A-Z])I$")
    if country then
      return setOption(key, "country", country)
    end
    return nil, "The first 2 characters should be a mandatory country code and third character(only 'I') is supported"
  end,

  BasicDataTransmitRates = function(mapping, param, value, key)
    local rateset = getOption(key, "rateset", "rateset") or ""
    local val, error = nwWifi.setBasicRateset(value,rateset)
    if val then
      setOption(key, "rateset", val)
    else
      return nil, error
    end
  end,

  OperationalDataTransmitRates = function(mapping, param, value, key)
    local rateset = getOption(key, "rateset", "rateset") or ""
    local val, error = nwWifi.setOperationalRateset(value,rateset)
    if val then
      setOption(key, "rateset", val)
    else
      return nil, error
    end
  end,

  X_000E50_ACSRescan = function(mapping, param, value, key)
    if value == "1" then
      commitapply:newset("ACSRescan." .. key)
    end
  end,

  X_000E50_ACSRescanPeriod = function(mapping, param, value, key)
    setOption(key, "acs_rescan_period", value)
  end,
  X_000E50_ACSRescanDelayPolicy = function(mapping, param, value, key)
    setOption(key, "acs_rescan_delay_policy", value)
  end,

  X_000E50_ACSRescanDelay = function(mapping, param, value, key)
    setOption(key, "acs_rescan_delay", value)
  end,

  X_000E50_ACSRescanDelayMaxEvents  = function(mapping, param, value, key)
    setOption(key, "acs_rescan_delay_max_events", value)
  end,

  X_000E50_ACSTXTrafficThreshold = function (mapping, param, value, key)
    setOption(key,"acs_tx_traffic_threshold", value)
  end,

  X_000E50_ACSRXTrafficThreshold = function (mapping, param, value, key)
    setOption(key,"acs_rx_traffic_threshold", value)
  end,

  X_000E50_ACSTrafficSensePeriod = function (mapping, param, value, key)
    setOption(key,"acs_traffic_sense_period", value)
  end,

  X_000E50_SetDefAcAgg = function(mapping, param, value, key)
    local uciKey = model:getUciKey(key)
    local radioType = getFromUci(uciKey, "type")
    value = (value == "0") and "3000" or ""
    if radioType == "quantenna" then
      setOption(key, "ac_agg_vi", value)
    else
      return nil, "SetDefAcAgg is applicable only for quantenna based radio_5G"
    end
  end,

  X_000E50_MUMIMO = function(mapping, param, value, key)
    setOption(key, "mumimo", value)
  end,
  X_000E50_ACSDFSReEntry = function(mapping, param, value, key)
    local dfsValue = value == "1" and "bgdfs" or "off"
    setOption(key, "acs_dfs_reentry", dfsValue)
  end,
  X_000E50_AllowedChannels = function(mapping, param, value, key)
    local channels = {}
    local country = getOption(key, "country", "country")
    for channel in value:gmatch("[^,%s]+") do
      if not tonumber(channel) then
        return nil, "Please enter a valid channel"
      elseif country and not isAllowedChannel(country, channel, key) then
        return nil, "Please enter allowed channel for this region"
      end
      channels[#channels + 1] = channel
    end
    return setOption(key, "allowed_channels", table.concat(channels, " "))
  end,
}

Device_WiFi_Radio_i_.commit = function()
  end_transaction(uci_helper.commit)
end

Device_WiFi_Radio_i_.revert = function()
  end_transaction(uci_helper.revert)
end

local function onStateChanged(mapping, action, config, sectionType, sectionName, option)
  lastStateChangeTime[sectionName] = getClockTime(posix.CLOCK_MONOTONIC)
  return { { key = sectionName, paramname = "Enable" } }
end

local productName = uci_helper.get_from_uci({config = "version", sectionname = "@version[0]", option = "product", extended = true})
local function setScanHistoryInUci(radioType , scanHistory)
  if not scanHistory or scanHistory == "" then
    return
  end
  local scanCount = 0
  for scanData in scanHistory:gmatch("%d+;%d+:%d+:%d+%-[^;]+;.-;[^;]+;[^;]+;[^;]+;[^;]+;") do
    scanCount = scanCount + 1
  end
  scanHistory = scanCount > 96 and gsub(scanHistory, "%d+;%d+:%d+:%d+%-[^;]+;.-;[^;]+;[^;]+;[^;]+;[^;]+;", "", scanCount - 96) or scanHistory
  if not cache.uci[radioType] then
    cache.uci[radioType] = {}
  end
  cache.uci[radioType].scan_history = scanHistory or ""
  wirelessBinding.sectionname = radioType
  wirelessBinding.option = "scan_history"
  uci_helper.set_on_uci(wirelessBinding, scanHistory or "", commitapply)
  uci_helper.commit(wirelessBinding)
end

local function updateScanHistory()
  local ubusData = conn:call("wireless.radio.acs", "get", {}) or {}
  local scanHistory2GInUci = getFromUci("radio_2G", "scan_history")
  local scanHistory5GInUci = getFromUci("radio_5G", "scan_history")
  local scanHistory2G = ubusData["radio_2G"] and ubusData["radio_2G"].scan_history or ""
  local scanHistory5G = ubusData["radio_5G"] and ubusData["radio_5G"].scan_history or ""
  setScanHistoryInUci("radio_2G", scanHistory2GInUci and scanHistory2GInUci .. scanHistory2G or scanHistory2G)
  setScanHistoryInUci("radio_5G", scanHistory5GInUci and scanHistory5GInUci .. scanHistory5G or scanHistory5G)
end



local function setScanHistory(_, action, data)
  if data.event == "acs_history_update" then
    local radioType = data.name
    local ubusData = conn:call("wireless.radio.acs", "get", { name = radioType }) or {}
    local scanHistory = ubusData[radioType] and ubusData[radioType].scan_history
    local scanHistoryInUci = getFromUci(radioType, "scan_history")
    if scanHistory and scanHistoryInUci then
      local lastScanData, lastScanDataInUci, lastDataMatched
      local scanCount = 0
      for scanData in scanHistoryInUci:gmatch("%d+;%d+:%d+:%d+%-[^;]+;.-;[^;]+;[^;]+;[^;]+;[^;]+;") do
        scanCount = scanCount + 1
        lastScanDataInUci = scanData
      end
      for scanData in scanHistory:gmatch("%d+;%d+:%d+:%d+%-[^;]+;.-;[^;]+;[^;]+;[^;]+;[^;]+;") do
        if lastDataMatched then
          lastScanData = lastScanData and lastScanData .. scanData or scanData
        else
          lastDataMatched = lastScanDataInUci == scanData
        end
      end
      scanHistory = lastScanData and scanHistoryInUci .. lastScanData or scanHistoryInUci
    end
    setScanHistoryInUci(radioType, scanHistory)
  end
end

Device_WiFi_Radio_i_.add_watchers = function(mapping, param, key)
  local uciEventSource = eventsource("uci")
  uciEventSource.watch(mapping, { set = onStateChanged }, "wireless", "wifi-device", key, "state")

end

register(Device_WiFi_Radio_i_)

local Device_WiFi_Radio_i_Multi_i_ = {
  objectType = {
    name = "#ROOT",
    access = "readOnly",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      Score = {
        access = "readOnly",
        type ="string",
        description = "Score assigned by WiFi AP to WiFi channel during the channel selection phase, the score calculation SHOULD be executed considering noise type and tx/rx occupation level listened over the radio channel. The calculation SHALL be updated each time the AP refreshes the channel selection phase",
      },
      WiFiNoiseLevel = {
        access = "readOnly",
        type ="string",
        description = "Noise level due to WiFi devices accountable over the channel",
      },
      NONWiFiNoiseLevel = {
        access = "readOnly",
        type ="string",
        description = "Noise level due to NON-WiFi devices accountable over the channel",
      },
      DutyCycle = {
        access = "readOnly",
        type = "string",
        description = "Tx/Rx level of channel occupation",
      },
      SignalStrength = {
        access = "readOnly",
        type = "string",
        description = "Signal strength of BSSID list of the current channel"
      },
      AvgSignalStrength = {
        access = "readOnly",
        type = "int",
        description = "Average signal strength of BSSID list of the channel"
      },
      MinSignalStrength = {
        access = "readOnly",
        type = "int",
        description = "Minimum signal strength of BSSID list of the channel"
      },
      MaxSignalStrength = {
        access = "readOnly",
        type = "int",
        description = "Maximum signal strength of BSSID list of the channel"
      },
      NumberAP = {
        access = "readOnly",
        type = "unsignedInt",
        description = "Number of BSSID seen on channel"
      },
      Channel = {
        access = "readOnly",
        type = "int",
        description = "Allowed channel value for radio 2G/5G",
      },
    },
  }
}

-- Function to get the Ubus Call data for "ubusName" and "key"
local function getUbusData(ubusName, key)
  local data = conn:call(ubusName, "get", { name = key })
  return data and data[key] or {}
end

-- Function to match the Radio2G/Radio5G score for each channel from the UBUS Call: " ubus call wireless.radio.acs get "
-- where, Radio2G/Radio5G channel score is the Fifth Value of each channel tuple
-- Example of ubusStr : "05:15:28-31\/03\/2017;2;1;;13;1:0:3:0:-300;2:9:0:0:-400;3:1:0:0:-400;4:8:1:0:-600;5:6:0:0:-600;6:11:5:0:-600;7:4:0:0:-500;8:0:0:0:-500;9:0:0:0:-400;10:3:0:0:-400;11:9:4:0:-400;12:6:0:0:-400;13:0:0:0:-400;"
local function getRadioScore(ubusStr, currChannel)
  local scores = ubusStr:match("[^;]*;[^;]*;[^;]*;[^;]*;[^;]*;(.*)") or ""
  for channel, score in scores:gmatch("([^:]+):[^:]+:[^:]+:[^:]+:([^:]+);") do
    if channel == currChannel then
      return score
    end
  end
  return ""
end

local function getDutyCycle(ubusStr, currChannel)
   local DutyCycleStr = ubusStr:match("[^;]*;[^;]*;[^;]*;[^;]*;[^;]*;(.*)") or ""
   for channel, cycle in DutyCycleStr:gmatch("([^:]+):([^:]+):[^:]+:[^:]+:[^:]+;") do
   if channel == currChannel then
      return cycle
    end
  end
  return ""
end

-- Function to Find the channelIndex of currChannel from the channelList
local function getChannelIndex(key, channel)
  local chList = {}
  local allowedChannels = getOption(key, nil, "allowed_channels")
  for value in allowedChannels:gmatch("(%d+)") do
    chList[#chList + 1] = value
  end
  for chIndex, value in ipairs(chList) do
    if channel == value then
      return chIndex
    end
  end
end

-- Function to Find the 14th and 17th value from the UbusStr(a string),
-- so converting that string to table and returning the respective Value from the specified position
local function extractNoiseLevels(ubusStr)
  local subStrTable = {}
  for subStr in string.gmatch(ubusStr, "%S+") do
    subStrTable[#subStrTable+1] = subStr
  end
  local wifiNoiseLevel = subStrTable[14] or ""
  local nonwifiNoiseLevel = subStrTable[17] or ""
  return wifiNoiseLevel, nonwifiNoiseLevel
end

-- Function to get Noise value for the respective params
local function getWiFiNoiseLevel(ubusStr, key, channel)
  local rowNum = 1
  local chIndex = getChannelIndex(key, channel)
  for subStr in ubusStr:gmatch("([^\n]+)") do
    if rowNum - 2 == chIndex then --values start from rowNum 3 onwards
      return extractNoiseLevels(subStr)
    end
    rowNum = rowNum + 1
  end
end

-- Function to seprate the required SubString from the UbusData
local function getSubUbusStr(ubusData, option)
  if ubusData then
    for rKey, rValue in pairs(ubusData) do
      if rKey == option then
        return rValue and tostring(rValue) or ""
      end
    end
  end
  return ""
end

local function getNumberAP(channel, ubusStr)
  local bssCount, currChannel
  for val in ubusStr:gmatch("([^;]+)") do
    currChannel , bssCount = val:match("^([^:]+):[^:]+:([^:]+):")
    if bssCount and channel == currChannel then
      return bssCount
    end
  end
end

local function getSignalStrength(key)
  local channel
  key, channel = split_key(key)
  local ubusData = conn:call("wireless.radio.bsslist", "get",{}) or {}
  local rssi = {}
  if ubusData and ubusData[key] then
    for _, v in pairs(ubusData[key]) do
      if channel == tostring(v.channel) then
        rssi[#rssi+1] = tonumber(v.rssi)
      end
    end
  end
  table.sort(rssi)
  local minSignalStrength = rssi and rssi[1] and tostring(rssi[1]) or "0"
  local maxSignalStrength = rssi and rssi[#rssi] and tostring(rssi[#rssi]) or "0"
  return minSignalStrength, maxSignalStrength, rssi
end

local function avgSignalStrength(rssi)
  local sum = 0
  if next(rssi) then
    for _, val in ipairs(rssi) do
      sum = sum + val
    end
    return string.format("%0.3f",sum/#rssi)
  end
  return "0"
end

Device_WiFi_Radio_i_Multi_i_.entries = function(mapping, parentkey)
  local ubusData, ubusStr
  ubusData = getUbusData("wireless.radio", parentkey)
  ubusStr = getSubUbusStr(ubusData, "allowed_channels")
  local allowedchannels = {}
  if ubusStr then
    for val in ubusStr:gmatch("[^%s]+") do
      allowedchannels[#allowedchannels+1] = parentkey .."|".. val
    end
  end
  return allowedchannels
end

Device_WiFi_Radio_i_Multi_i_.get = {
  Score = function(mappings, param, key)
    local radioKey, channel = split_key(key)
    local scan = getUbusDataValue(radioKey, "scan_report")
    return getRadioScore(scan, channel) or ""
  end,
  WiFiNoiseLevel = function(mappings, param, key)
    local radioKey, channel = split_key(key)
    local channel_stats = getUbusDataValue(radioKey, "channel_stats")
    local wifiNoiseLevel = getWiFiNoiseLevel(channel_stats, radioKey, channel)
    return wifiNoiseLevel or ""
  end,
  NONWiFiNoiseLevel = function(mappings, param, key)
    local radioKey, channel = split_key(key)
    local channel_stats = getUbusDataValue(radioKey, "channel_stats")
    local _, nonwifiNoiseLevel = getWiFiNoiseLevel(channel_stats, radioKey, channel)
    return nonwifiNoiseLevel or ""
  end,
  DutyCycle = function(mappings, param, key)
    local radioKey, channel = split_key(key)
    local scan = getUbusDataValue(radioKey, "scan_report")
    return getDutyCycle(scan, channel)
  end,
  SignalStrength = function(mapping, param, key)
    local _, _, rssi = getSignalStrength(key)
    return table.concat(rssi, ",")
  end,
  MinSignalStrength = function(mapping, param, key)
    local minSignalStrength = getSignalStrength(key)
    return minSignalStrength
  end,
  MaxSignalStrength = function(mapping, param, key)
    local _, maxSignalStrength = getSignalStrength(key)
    return maxSignalStrength
  end,
  AvgSignalStrength = function(mapping, param, key)
    local _, _, rssi = getSignalStrength(key)
    return avgSignalStrength(rssi)
  end,
  NumberAP =  function(mapping, param, key)
    local radioKey, channel = split_key(key)
    local scan = getUbusDataValue(radioKey, "scan_report")
    return getNumberAP(channel, scan) or "0"
  end,
  Channel = function(mapping, param, key)
    local _, channel = split_key(key)
    return channel or ""
  end,
}

Device_WiFi_Radio_i_Multi_i_.getall = function(mapping, key)
  local radioKey, channel = split_key(key)
  local scan, channel_stats = getUbusDataValue(radioKey)
  local minSignalStrength, maxSignalStrength, rssi = getSignalStrength(key)
  local wifiNoiseLevel, nonwifiNoiseLevel = getWiFiNoiseLevel(channel_stats, radioKey, channel)
  return {
    Score = getRadioScore(scan, channel),
    WiFiNoiseLevel = wifiNoiseLevel,
    NONWiFiNoiseLevel = nonwifiNoiseLevel,
    DutyCycle = getDutyCycle(scan, channel),
    SignalStrength = table.concat(rssi, ","),
    MinSignalStrength = minSignalStrength,
    MaxSignalStrength = maxSignalStrength,
    AvgSignalStrength = avgSignalStrength(rssi),
    NumberAP = getNumberAP(channel, scan) or "0",
    Channel = channel or "",
}
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Device_WiFi_Radio_i_Multi_i_, "#ROOT", {"Device.WiFi.Radio.{i}.X_000E50_ChannelQuality.{i}."})
for _, dupli in ipairs(duplicates) do
  register(dupli)
end
