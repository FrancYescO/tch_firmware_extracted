-- Automatically generated from InternetGatewayDevice:1.14
-- using generator version 2.3
local math = math
local WLANConfiguration = {
    objectType = {
        name = "InternetGatewayDevice.#SUBROOT.WLANConfiguration.{i}.",
        access = "readOnly",
        numEntriesParameter = "LANWLANConfigurationNumberOfEntries",
        minEntries = 0,
        maxEntries = math.huge,
        aliasParameter = "Alias",
        parameters = {
            Enable = {
                access = "readWrite",
                type = "boolean",
            },
            Status = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "Up",
                    "Error",
                    "Disabled",
                },
            },
            Alias = {
                access = "readWrite",
                activeNotify = "canDeny",
                type = "string",
            },
            Name = {
                access = "readOnly",
                type = "string",
                max = "16",
            },
            BSSID = {
                access = "readOnly",
                type = "string",
            },
            MaxBitRate = {
                access = "readOnly", --readWrite not supported
                type = "string",
                max = "4",
            },
            Channel = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "0",
                        max = "255",
                    },
                },
            },
            SSID = {
                access = "readWrite",
                type = "string",
                max = "32",
            },
            BeaconType = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "None",
                    "Basic",
                    "11i",
		    "WPAand11i",
		    --[[ Currently not supported
                    "BasicandWPA",
                    "Basicand11i",
                    "BasicandWPAand11i",
		    --]]
                },
            },
            MACAddressControlEnabled = {
                access = "readWrite",
                type = "boolean",
            },
            Standard = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "a",
                    "b",
                    "g",
                    "g-only",
                    "n",
                },
            },
            WEPKeyIndex = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "1",
                        max = "4",
                    },
                },
            },
            KeyPassphrase = {
                access = "readWrite",
                hidden = "true",
                type = "string",
                max = "63",
            },
            WEPEncryptionLevel = {
                access = "readOnly",
                list = true,
                max = "64",
                type = "string",
                enumeration = {
                    "Disabled",
                    "40-bit",
                    "104-bit",
                },
            },
            BasicEncryptionModes = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "None",
                    "WEPEncryption",
                },
            },
            BasicAuthenticationMode = {
                access = "readOnly", -- readwrite not supported
                type = "string",
                max = "31",
                enumeration = {
                    "None",
		    --[[ Other values are currently not supported.
		    "EAPAuthentication",
                    "SharedAuthentication",--]]
                },
            },
            WPAEncryptionModes = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "TKIPEncryption",

                    --[[ This should only be queried when beacon type includes WPA and only expose TKIP in WPA
                    "AESEncryption",
                    "TKIPandAESEncryption",
                    --]]
                },
            },
            WPAAuthenticationMode = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "PSKAuthentication",
                    "EAPAuthentication",
                },
            },
            IEEE11iEncryptionModes = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "AESEncryption",
                    --[[ This should only be queried when beacon type includes WPA2 and only expose AES in WPA2
                    "TKIPEncryption",
                    "TKIPandAESEncryption",
                    --]]
                },
            },
            IEEE11iAuthenticationMode = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "PSKAuthentication",
                    "EAPAuthentication",
                    -- "EAPandPSKAuthentication", This should only be queried when beacon type includes WPA2 and not allowing dual support
                },
            },
            PossibleChannels = {
                access = "readOnly",
                list = true,
                max = "1024",
                type = "string",
            },
            BasicDataTransmitRates = {
                access = "readWrite",
                list = true,
                max = "256",
                type = "string",
            },
            OperationalDataTransmitRates = {
                access = "readWrite",
                list = true,
                max = "256",
                type = "string",
            },
            PossibleDataTransmitRates = {
                access = "readOnly",
                list = true,
                max = "256",
                type = "string",
            },
            InsecureOOBAccessEnabled = {
                access = "readOnly", -- readWrite currently not supported, hence making readOnly
                type = "boolean",
            },
            BeaconAdvertisementEnabled = {
                access = "readOnly",
                type = "boolean",
            },
            SSIDAdvertisementEnabled = {
                access = "readWrite",
                type = "boolean",
            },
            RadioEnabled = {
                access = "readWrite",
                type = "boolean",
            },
            TransmitPowerSupported = {
                access = "readOnly",
                max = "64",
                type = "string",
            },
            TransmitPower = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                  {
                    min = "25",
                    max = "100",
                  },
                },
            },
            AutoRateFallBackEnabled = {
                -- No lower layer support, hence write functionality is disabled currently
                access = "readOnly",
                type = "boolean",
            },
            LocationDescription = {
                access = "readOnly", -- readWrite currently not supported, hence making readOnly.
                type = "string",
                max = "4096",
            },
            RegulatoryDomain = {
                access = "readWrite",
                type = "string",
                max = "3",
            },
            TotalPSKFailures = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            TotalIntegrityFailures = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            ChannelsInUse = {
                access = "readOnly",
                activeNotify = "canDeny",
                list = true,
                max = "1024",
                type = "string",
            },
            DeviceOperationMode = {
                access = "readOnly", -- readWrite not supported
                type = "string",
                max = "31",
                enumeration = {
                    "InfrastructureAccessPoint",
                --[[other values are not supported currently.
		    "WirelessBridge",
                    "WirelessRepeater",
                    "WirelessStation",--]]
                },
            },
            DistanceFromRoot = {
                access = "readOnly",-- readWrite currently not supported, hence making readOnly
                type = "unsignedInt",
            },
            PeerBSSID = {
                access = "readOnly", -- readWrite currently not supported, hence making readOnly
                type = "string",
            },
            AuthenticationServiceMode = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "None",
                    "LinkAuthentication",
                    "RadiusClient",
                },
            },
            WMMSupported = {
                access = "readOnly",
                type = "boolean",
            },
            UAPSDSupported = {
                access = "readOnly",
                type = "boolean",
            },
            UAPSDEnable = {
                access = "readOnly", -- readWrite not supported
                type = "boolean",
            },
            WMMEnable = {
                access = "readOnly", -- no readWrite since as per TRS "By default a Technicolor Gateway must enable WMM on all radio interfaces"
                type = "boolean",
            },
            TotalBytesSent = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            TotalBytesReceived = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            TotalPacketsSent = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            TotalPacketsReceived = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            X_000E50_ACSState = {
                access = "readOnly",
                type = "string",
                description = "Radio's Operational state of Automatic channel selection",
            },
            X_000E50_ACSMode = {
                access = "readOnly",
                type = "string",
                description = "Automatic Channel Selection Policy",
            },
            X_000E50_ACSCHMonitorPeriod = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Interval over which the Channel interference monitor statistics are averaged",
                range = {
                    {
                        min = "1",
                        max = "10",
                    },
                },
            },
            X_000E50_ACSScanReport = {
                access = "readOnly",
                type = "string",
                description = "Data that represents the ACS scan results",
                max = "4096",
            },
            X_000E50_ACSScanHistory = {
                access = "readOnly",
                type = "string",
                description = "Overview of the most recent scan actions and the outcome",
                max = "2560",
            },
            X_000E50_ACSRescanPeriod = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Specifies the Rescan time period of ACS in seconds",
                range = {
                    {
                        min = "0",
                        max = "604800",
                    },
                },
            },
            X_000E50_ACSRescanDelayPolicy = {
                access = "readWrite",
                type = "string",
                description = "Indicates the ACS rescan delay policy (always/notraffic)",
                -- As per the implementation,it accepts only the following values.
                enumeration = {
                    "always",
                    "nostation",
                    "notraffic",
                },
            },
            X_000E50_ACSRescanDelay = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Specifies the time period of Rescan delay in seconds",
                range = {
                    {
                        min = "10",
                        max = "3600",
                    },
                },
            },
            X_000E50_ACSRescanDelayMaxEvents = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Maximum amount of times a rescan is allowed to be delayed",
                range = {
                    {
                        min = "1",
                        max = "999",
                    },
                },
            },
            X_000E50_ACSCHFailLockoutPeriod = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Period activated to prevent the flood of channel change events after valid channel change",
                range = {
                    {
                        min = "1",
                        max = "86400",
                    },
                },
            },
            X_000E50_ChannelWidth = {
                access = "readWrite",
                type = "string",
                description = "Bandwidth used by the radio",
            },
            X_000E50_SetDefAcAgg = {
                access = "readWrite",
                type = "boolean",
                description = "Enables agg holding time for WMM video packets"
            },
            X_000E50_ShortGuardInterval = {
                access = "readWrite",
                type = "boolean",
                description = "Enable/Disable Short Guard Interval",
            },
            X_000E50_SpaceTimeBlockCoding = {
                access = "readWrite",
                type = "boolean",
                description = "Enable/Disable SpaceTimeBlockCoding option for improving reliability of data transfer",
            },
            X_000E50_CyclicDelayDiversity = {
                access = "readWrite",
                type = "boolean",
                description = "Enable/Disable CyclicDelayDiversity option to avoid intersymbol interference",
            },
            AutoChannelEnable = {
                access = "readWrite",
                type = "boolean",
            },
            X_000E50_ACSRescan = {
                access = "readWrite",
                type = "boolean",
                description = "Enable/Disable the ACS Rescan",
            },
            X_000E50_ACSBssList = {
                access = "readOnly",
                type = "string",
                description = "List of BSS connected to the Access Point",
                max = "16384",
            },
            X_000E50_ChannelMode = {
                access = "readWrite",
                type = "string",
                description = "ACS channel selection mode",
                enumeration = {
                    "Auto",
                    "Manual",
                },
            },
            X_000E50_Power = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Increase/decrease TX power (relative) in steps of 1dB",
                range = {
                    {
                        min = "1",
                        max = "4",
                    },
                },
            },
            X_000E50_PowerDefault = {
                access = "readOnly",
                type = "string",
                description = "Value of the default power level",
            },
            X_000E50_PowerList = {
                access = "readOnly",
                type = "string",
                description = "List of power levels supported",
            },
            X_000E50_PacketsDropped = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
                description = "Total number of dropped packets",
            },
            X_000E50_PacketsErrored = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
                description = "Total number of error packets",
            },
            X_000E50_RemotelyManaged = {
                access = "readOnly",
                type = "boolean",
                description = "ACS manageability of TG23x device connected to CPE",
            },
            X_000E50_UpgradeURL = {
                access = "readWrite",
                type = "string",
                description = "Indicates the URL path from where firmware image can be obtained",
            },
            X_000E50_UpgradeCheckPeriod = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Upgrade Check Interval for the remotely Managed device",
                range = {
                    {
                        min = "1",
                        max = "8760", -- one year
                   },
                },
            },
            X_000E50_UpgradeSWVersion = {
                access = "readOnly",
                type = "string",
                description = "Indicate the Software version of the remotly managed device",
            },
            X_000E50_BandSteerEnable = {
                access = "readWrite",
                type = "boolean",
                description = "Enable/Disable the Bandsteer",
            },
            X_000E50_ChannelBandwidth = {
                access = "readWrite",
                type = "string",
                description = "Indicates the bandwidth at which the channel is operating",
                enumeration = {
                    "Auto",
                    "20MHz",
                    "20/40MHz",
                },
            },
            X_AutoChannelReselectionTimeout = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Configuration of the timer for auto channel reselection",
                range = {
                    {
                        min = "0",
                        max = "604800",
                    },
                },
            },
            X_AutoChannelReselectionEnable = {
                access = "readWrite",
                type = "boolean",
                description = "Enable or Disable WiFi auto channel reselection Default value: 1",
            },
            X_WPS_V2_ENABLE = {
                access = "readWrite",
                type = "boolean",
                description = "Enable or disable WPS 2.0",
            },
            X_0876FF_AllowedMACAddresses = {
                access = "readWrite",
                list = "true",
                max = "512",
                type = "string",
                description = "List of hardware addresses that are allowed to connect to this connection",
            },
            X_0876FF_DeniedMACAddresses = {
                access = "readWrite",
                list = "true",
                max = "512",
                type = "string",
                description = "List of hardware addresses that are not allowed to connect to this connection",
            },
            X_0876FF_SupportedFrequencyBands = {
                access = "readOnly",
                list = true,
                type = "string",
                enumeration = {
                    "2.4GHz",
                    "5GHz",
                },
                description = "List of frequency bands at which the radio can operate",
            },
            X_0876FF_OperatingFrequencyBand = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "2.4GHz",
                    "5GHz",
                },
                description = "Indicates the frequency band at which the radio is operating",
            },
            X_0876FF_SupportedStandards = {
                access = "readOnly",
                list = true,
                type = "string",
                enumeration = {
                    "a",
                    "b",
                    "g",
                    "n",
                    "ac",
                },
                description = "Lists the Supported standards for IEEE 802.11",
            },
            X_0876FF_WMMPowerSaveEnabled = {
                access = "readOnly",
                type = "boolean",
                description = "Enables/disables WMM PowerSave",
            },
            X_0876FF_KeyPassphrase = {
                access = "readWrite",
                type = "string",
                max = "63",
                description = "Readable KeyPassphrase",
            },
            X_0876FF_RestoreDefaultKey = {
                access = "readWrite",
                type = "boolean",
                description = "Restore the default WEP/WPA key per SSID",
            },
            X_0876FF_RestoreDefaultWireless = {
                access = "readWrite",
                type= "boolean",
                description = "Restores default wireless settings per interface and accesspoint",
            },
            X_0876FF_DFSAvailable = {
                access = "readOnly",
                type = "boolean",
                description = "Indicated the devices capability for DFS band channels",
            },
            X_0876FF_DFSEnable = {
                access = "readWrite",
                type = "boolean",
                description = "Enables the DFS frequency band for Auto channel selection",
            },
            X_0876FF_MaxConcurrentDevices = {
                access = "readOnly",
                type = "int",
                description = "Maximum number of concurrent devices that can be connected to the SSID"
            },
            X_000E50_Band = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "2.4GHz",
                    "5GHz",
                },
                description = "Wireless device frequency band (either 2.4GHz / 5GHz)",
            },
            X_VODAFONE_MACAddressControlMode = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "Off",
                    "Allow",
                    "Deny",
                },
                default = "Off",
                description = "Get/Set the type of MAC address control type",
            },
            X_0876FF_SubnetMask = {
                access = "readOnly",
                type = "string",
                description = "The subnet mask IP address of the secondary SSID subnet feature",
            },
            X_0876FF_SubnetGatewayAddr = {
                access = "readOnly",
                type = "string",
                description = "The gateway IP address of the secondary SSID subnet feature",
            },
            X_0876FF_SubnetEnable = {
                access = "readWrite",
                type = "boolean",
                description = "Enable or Disable the Secondary SSID subnet feature",
            },
            X_0876FF_RadioID = {
                access = "readOnly",
                type = "int",
                description = "Arbitrary integer identifier for each radio",
            },
            X_0876FF_SubnetMinAddr = {
                access = "readWrite",
                type = "string",
                description = "The first LAN IP address in the DHCP pool to be assigned by the secondary SSID subnet feature",
            },
            X_0876FF_SubnetMaxAddr = {
                access = "readWrite",
                type = "string",
                description = "The last LAN IP address in the DHCP pool to be assigned by the secondary SSID subnet feature",
            },
            X_0876FF_GREInterface = {
                access = "readWrite",
                type = "string",
                description = "The path of the GRE tunnel interface for the corresponding SSID",
            },
            X_000E50_PMF = {
                access = "readWrite",
                type = "string",
                description = "To control the state of the protected management frames setting per radio",
                enumeration = {
                    "Enabled",
                    "Required",
                    "Disabled",
                },
            },
            X_000E50_MuMimo = {
                access = "readWrite",
                type = "boolean",
                description = "Enables or disables transmit MU MIMO",
            },
            X_SecurityModesSupported = {
                access = "readOnly",
                list = true,
                type = "string",
                enumeration = {
                    "None",
                    -- "WEP-64",  -- "wep" mode is not supported
                    -- "WEP-128",
                    "WPA-Personal",
                    "WPA2-Personal",
                    "WPA-WPA2-Personal",
                    "WPA-Enterprise",
                    "WPA2-Enterprise",
                    "WPA-WPA2-Enterprise",
                },
                description = "Indicates which security modes this AccessPoint instance is capable of supporting",
            },
            X_SupportedStandards = {
                access = "readOnly",
                list = true,
                type = "string",
                enumeration = {
                    "a",
                    "b",
                    "g",
                    "n",
                    "ac",
                },
                description = "Indicates which IEEE 802.11 standards this Radio instance can support",
            },
            X_RadioStatus = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "Up",
                    "Down",
                    "Unknown",
                    "Dormant",
                    "NotPresent",
                    "LowerLayerDown",
                    "Error",
                },
                description = "The current operational state of the radio",
            },
            X_LastChange = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
                description = "The accumulated time in seconds since the radio entered its current operational state",
            },
            -- TotalAssociations
            -- automatically created when InternetGatewayDevice.LANDevice.{i}.WLANConfiguration.{i}.AssociatedDevice.{i}. is loaded
        }
    }
}


local require, mapper, register = require, mapper, register
local ipairs, pairs, tonumber, table = ipairs, pairs, tonumber, table
local eventsource, tostring = eventsource, tostring
local ubus = require("ubus")
local uciHelper = mapper("ucihelper")
local conn = ubus.connect()
local wlanConfigCommon = require("transformer.shared.WLANConfigurationCommon")
local bandSteerHelper = require("transformer.shared.bandsteerhelper")
local getWirelessUbus = wlanConfigCommon.getWirelessUbus
local wirelessBinding = {config = "wireless"}
local wirelessDefaultsBinding = { config = "wireless_defaults" }
local dhcp = require("transformer.shared.dhcp")
local network = require("transformer.shared.common.network")
local nwCommon = require("transformer.mapper.nwcommon")
local nwWifi = require("transformer.shared.wifi")
local networkBinding = { config = "network" }
local posix = require("tch.posix")
local getClockTime = posix.clock_gettime
local transactions = {}
local lastStateChangeTime = {}
local wlanconfig = require 'transformer.shared.mappings.lan.wlanconfig'

local dmordering = require "transformer.shared.models.dmordering"

local entriesWLANInterfaces = function(mapping)
  local _, e = wlanconfig.entries()
  return dmordering.sort(e, mapping.objectType.name)
end

local entriesWLANDevice = function(mapping, parentkey)
  local e = wlanconfig.entries(parentkey)
  return dmordering.sort(e, mapping.objectType.name)
end

local iface_binding = {config = "wireless", sectionname = "wifi-iface"}

-- For a given radio name (radio_2G for instance), return the wifi-iface sections associated with it in UCI (wl0)
local function getIfacesForRadio(radio)
  local ifaces = {}
  uciHelper.foreach_on_uci(iface_binding, function(s)
    if s["device"] == radio then
      ifaces[#ifaces + 1] = s[".name"]
    end
  end)
  return ifaces
end

local ap_binding = {config = "wireless", sectionname = nil, option = "iface", extended = true}

local function getDataFromRadio(radio, option)
  local radioInfo = conn:call("wireless.radio", "get", { name = radio }) or {}
  if option then
    return radioInfo[radio] and tostring(radioInfo[radio][option] or "") or ""
  end
  return radioInfo[radio] or {}
end

local function getRadioStatus(key)
  local state = getDataFromRadio(wlanConfigCommon.getRadioFromIface(key), "oper_state")
  if state == "1" then
    return "Up"
  elseif state == "0" then
    return "Down"
  end
  return "Error"
end

local function convertToList(standards)
  local stdList = {}
  for std in standards:gmatch("[abgn]c?") do
    stdList[#stdList + 1] = std
  end
  return table.concat(stdList, ",")
end

-- For a given AP name (ap0 for instance), return the wifi-iface section associated with it in UCI (wl0)
local function getIfaceForAP(ap)
  ap_binding.sectionname = ap
  return uciHelper.get_from_uci(ap_binding)
end

local function getFromUci(binding, sectionname, option, default, state)
  binding.sectionname = sectionname
  if option then
    binding.option = option
    binding.default = default
    binding.state = state
    return uciHelper.get_from_uci(binding)
  end
  return uciHelper.getall_from_uci(binding)
end

local supportedModesMap = {
  ["none"]          = "None",
  ["wep"]           = "None", -- "wep" mode is not supported
  ["wpa2-psk"]      = "WPA2-Personal",
  ["wpa-wpa2-psk"]  = "WPA-WPA2-Personal",
  ["wpa2"]          = "WPA2-Enterprise",
  ["wpa-wpa2"]      = "WPA-WPA2-Enterprise"
}

local function getModesSupported(ap)
  local supportedModes = getFromUci(wirelessBinding, ap, "supported_security_modes")
  if not supportedModes then
    local data = conn:call("wireless.accesspoint.security", "get", { name = ap }) or {}
    supportedModes = data[ap] and data[ap].supported_modes or ""
  end
  if supportedModes ~= "" then
    local modes = {}
    for mode in supportedModes:gmatch("%S+") do
      if mode ~= "wep" then  -- "wep" mode is not supported, so skipping if it is populated from UCI
        modes[#modes + 1] = supportedModesMap[mode]
      end
    end
    return table.concat(modes, ",")
  end
  return ""
end

local function setOnUci(sectionname, option, value, commitapply)
  wirelessBinding.sectionname = sectionname
  wirelessBinding.option = option
  uciHelper.set_on_uci(wirelessBinding, value, commitapply)
  transactions[wirelessBinding.config] = true
end

local function getStdList(standards)
  local stdList = {}
  for std in standards:gmatch("[abgn]c?") do
    stdList[#stdList+1] = std
  end
  return table.concat(stdList, ",")
end

local encryptionModeMap = {
  wep  = "WEPEncryption",
  none = "None"
}

local wpaAuthenticationModeMap = {
  ["wpa2-psk"]     = "PSKAuthentication",
  ["wpa-wpa2-psk"] = "PSKAuthentication",
  ["wpa2"]         = "EAPAuthentication",
  ["wpa-wpa2"]     = "EAPAuthentication",
}

local beaconTypeMap = {
  ["none"]         = "Basic",
  ["wep"]          = "Basic",
  ["wpa-psk"]      = "WPA",
  ["wpa2-psk"]     = "11i",
  ["wpa-wpa2-psk"] = "WPAand11i",
  ["wpa"]          = "WPA",
  ["wpa2"]         = "11i",
  ["wpa-wpa2"]     = "WPAand11i",
  ["WPA"]          = "wpa",
  ["WPAand11i"]    = "wpa-wpa2",
  ["11i"]          = "wpa2"
}

local modeMap = {
  Off = "disabled",
  Allow = "unlock",
  Deny = "lock",
  disabled = "Off",
  unlock = "Allow",
  lock = "Deny",
}

local powerLevelMap = {
  ["-6"] = "1",
  ["-3"] = "2",
  ["-1"] = "3",
  ["0"] = "4",
  ["1"] = "-6",
  ["2"] = "-3",
  ["3"] = "-1",
  ["4"] = "0",
}

local authServiceModeMap = {
  ["none"]         = "None",
  ["wep"]          = "None",
  ["wpa"]          = "RadiusClient",
  ["wpa2"]         = "RadiusClient",
  ["wpa-wpa2"]     = "RadiusClient",
  ["None"]         = "none",
  ["LinkAuthentication"] = "wpa2-psk",
  ["RadiusClient"] = "wpa2"
}

local transmitPowerMap = {
  ["-6"] = "25",
  ["-3"] = "50",
  ["-1"] = "75",
  ["0"]  = "100",
  ["25"] = "-6",
  ["50"] = "-3",
  ["75"] = "-1",
  ["100"]= "0",
}

local DFSChannels = { 52, 56, 60, 64, 100, 104, 108, 112, 116, 132, 136, 140 }

local igdtouciMap = {
  Enabled = "enabled",
  Disabled = "disabled",
  Required = "required",
}

local ucitoigdMap = {
  enabled = "Enabled",
  disabled = "Disabled",
  required = "Required",
}

local function deleteOnUci(sectionname, commitapply)
  wirelessBinding.sectionname = sectionname
  wirelessBinding.option = nil
  uciHelper.delete_on_uci(wirelessBinding, commitapply)
  transactions[wirelessBinding.config] = true
end

local function createSection(sectionType, sectionName)
  deleteOnUci(sectionName, commitapply)
  wirelessBinding.sectionname = sectionName
  uciHelper.set_on_uci(wirelessBinding, sectionType)
end

local function restoreSection(sectionType, sectionName)
  createSection(sectionType, sectionName)
  local wirelessDefaults = getFromUci(wirelessDefaultsBinding, sectionName)
  for option, value in pairs(wirelessDefaults) do
    if not option:match("^%.") then
      setOnUci(sectionName, option, value, commitapply)
    end
  end
end

local function getChannels(key, val, channel)
  local channels
  if not val then
    local radio = wlanConfigCommon.getRadioFromIface(key)
    channels = getWirelessUbus("radio", radio, channel)
  else
    channels = val
  end
  channels = channels:gsub("%s+", ",")
  return channels:match("^,?(.-),?$") or ""
end

local ratePatternMap = {
  BasicDataTransmitRates       = "([%d.]+)%(b%)",
  OperationalDataTransmitRates = "([%d.]+)",
  PossibleDataTransmitRates    = "([%d.]+)"
}

local function getRates(param, key)
  local radio = wlanConfigCommon.getRadioFromIface(key)
  local rateSet = getFromUci(wirelessBinding, radio, "rateset")
  local rates = {}
  for rate in rateSet:gmatch(ratePatternMap[param]) do
    rates[#rates +1] = rate
  end
  return table.concat(rates, ",")
end

local function getSSIDAdvertisementEnabled(key)
  local ap = wlanConfigCommon.getAPFromIface(key)
  local val = getFromUci(wirelessBinding, ap, "public")
  if val ~= "" then
    return val
  end
  return getWirelessUbus("accesspoint", key, "public", "0")
end

local function getAuthenticationServiceMode(key)
  local ap = wlanConfigCommon.getAPFromIface(key)
  local mode = getFromUci(wirelessBinding, ap, "security_mode")
  if mode == "" then
    mode = getWirelessUbus("security", key, "mode")
  end
  return authServiceModeMap[mode] or "LinkAuthentication"
end

local function getTransmitPower(key)
  local radio = wlanConfigCommon.getRadioFromIface(key)
  local power = getFromUci(wirelessBinding, radio, "tx_power_adjust")
  return power == "" and "50" or transmitPowerMap[power] or ""
end

local function getACSBssList(radio)
  local bssList = conn:call("wireless.radio.bsslist", "get", { name = radio }) or {}
  local bssData = ""
  if bssList then
    for mac, data in pairs(bssList[radio] or {}) do
      -- all the colons are removed from the mac
      local bssid = mac:gsub(":","") or ""
      local bssInfo = string.format("%s:%s:%s:%s:%s:%s;", bssid, data.ssid or "", data.channel or "", data.rssi or "", data.sec or "", data.cap or "")
      if ((#bssData + #bssInfo) <= 16*1024) then
        bssData = bssData .. bssInfo
      else
        return bssData
      end
    end
  end
  return bssData
end

local function getRadioEnabled(key)
  local radio = wlanConfigCommon.getRadioFromIface(key)
  local state = getFromUci(wirelessBinding, radio, "state")
  if state == "" then
    state = getWirelessUbus("radio", radio, "admin_state")
  end
  return state ~= "" and tostring(state) or "0"
end

local function getChannelMode(key)
  local radio = wlanConfigCommon.getRadioFromIface(key)
  local channel = getFromUci(wirelessBinding, radio, "channel")
  if channel == "" then
    channel = getWirelessUbus("radio", radio, "requested_channel")
  end
  return channel == "auto" and "Auto" or "Manual"
end

local function getSubnetInfo(key, option)
  local iface = key:gsub("_remote", "")
  local interface = getFromUci(wirelessBinding, iface, "network")
  return getFromUci(networkBinding, interface, option, nil, false)
end

local function setSubnetInfo(key, option, value)
  local iface = key:gsub("_remote", "")
  local interface = getFromUci(wirelessBinding, iface, "network")
  networkBinding.sectionname = interface
  networkBinding.option = option
  uciHelper.set_on_uci(networkBinding, value, commitapply)
  transactions[networkBinding.config] = true
end

local function getSubnetAddress(key)
  local subnetInfo = getSubnetInfo(key)
  if subnetInfo and not subnetInfo.ipaddr or not subnetInfo.netmask then
    return ""
  end
  local iface = key:gsub("_remote", "")
  local interface = getFromUci(wirelessBinding, iface, "network")
  local data = dhcp.parseDHCPData(nil, interface)
  local startAddr = data.ipStart and nwCommon.numToIPv4(data.ipStart) or ""
  local endAddr = data.ipEnd and nwCommon.numToIPv4(data.ipEnd) or ""
  return startAddr, endAddr
end

local function channelStrToList(str)
  local list = {}
  for channel in str:gmatch("(%d+)") do
    list[#list + 1] = tonumber(channel)
  end
  return list
end

local function channelExist(channels, chan)
  for _, channel in pairs(channels) do
    if chan == channel then
      return true
    end
  end
  return false
end

local function getDFSStatus(radio)
  local channels = channelStrToList(getFromUci(wirelessBinding, radio, "allowed_channels"))
  for _, channel in pairs(channels) do
    if channelExist(DFSChannels, channel) then
      return "1"
    end
  end
  return "0"
end

local function addDFSChannels(channels)
  for _, dfsChannel in pairs(DFSChannels) do
    local exist = channelExist(channels, dfsChannel)
    if not exist then
      channels[#channels + 1] = tonumber(dfsChannel)
    end
  end
  table.sort(channels)
  return table.concat(channels, " ")
end

local function removeDFSChannels(channels)
  for key, channel in pairs(channels) do
    if channelExist(DFSChannels, channel) then
      channels[key] = nil
    end
  end
  table.sort(channels)
  return table.concat(channels, " ")
end

local function getRadioStandard(radio)
  local standard = getWirelessUbus("radio", radio, "standard")
  if standard:match("n") then
    return "n"
  elseif standard:match("g") then
    if standard:match("b") then
      return "g"
    else
      return "g-only"
    end
  else
    return "b"
  end
end

local function setWPAKey(key, value, commitapply)
  local len = #value
  if (len < 8 or len > 63) then
     return nil,"invalid value"
  end
  local iface = key:gsub("_remote", "")
  if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) then
    return nil, "Cannot modify KeyPassphrase when bandsteer is enabled"
  else
    local ap = wlanConfigCommon.getAPFromIface(key)
    setOnUci(ap, "wpa_psk_key", value, commitapply)
    wlanConfigCommon.modifyBSPeerNodeAuthentication("wpa_psk_key", value, key, commitapply)
  end
end

local function getEnable(key)
  local ap = wlanConfigCommon.getAPFromIface(key)
  local val = getFromUci(wirelessBinding, ap, "state")
  if val ~= "" then
    return val
  end
  return wlanConfigCommon.getWirelessUbus("accesspoint", key, "admin_state", "0")
end

-- @return the value from uci(if present) or from ubus
local function getAPMode(key)
  local ap = wlanConfigCommon.getAPFromIface(key)
  local mode = getFromUci(wirelessBinding, ap, "security_mode")
  if mode == "" then
    mode = getWirelessUbus("security", key, "mode")
  end
  return mode
end

local function getMACAddressControlEnabled(key)
  local ap = wlanConfigCommon.getAPFromIface(key)
  local aclMode = getFromUci(wirelessBinding, ap, "acl_mode")
  return (aclMode == "lock" or aclMode == "register") and "1" or "0"
end

local function setAuthenticationMode(key, value, commitapply)
  local ap = wlanConfigCommon.getAPFromIface(key)
  local secMode = getWirelessUbus("security", key, "mode")
  local val
  if not wpaAuthenticationModeMap[secMode] then
    return nil, "Authentication mode cannot be set for this capability"
  end
  if value == "PSKAuthentication" then
    if (secMode == "wpa-wpa2" or secMode == "wpa-wpa2-psk") then
      val = "wpa-wpa2-psk"
    else
      val = "wpa2-psk"
    end
  elseif value == "EAPAuthentication" then
    if (secMode == "wpa-wpa2" or secMode == "wpa-wpa2-psk") then
      val = "wpa-wpa2"
    else
      val = "wpa2"
    end
  end
  if nwWifi.isSupportedMode(ap, val) then
    setOnUci(ap, "security_mode", val, commitapply)
    wlanConfigCommon.modifyBSPeerNodeAuthentication("security_mode", val, key, commitapply)
  else
    return nil, "Authentication mode cannot be set for unsupported security modes"
  end
end

local uciACSOptionMap = {
  X_000E50_ACSCHMonitorPeriod   = "acs_channel_monitor_period",
  X_000E50_ACSRescanPeriod      = "acs_rescan_period",
  X_000E50_ACSRescanDelayPolicy = "acs_rescan_delay_policy",
  X_000E50_ACSRescanDelay       = "acs_rescan_delay",
  X_000E50_ACSRescanDelayMaxEvents = "acs_rescan_delay_max_events",
  X_000E50_ACSCHFailLockoutPeriod  = "acs_channel_fail_lockout_period",
}

local ubusACSOptionMap = {
  X_000E50_ACSCHMonitorPeriod   = "channel_monitor_period",
  X_000E50_ACSRescanPeriod      = "rescan_period",
  X_000E50_ACSRescanDelayPolicy = "rescan_delay_policy",
  X_000E50_ACSRescanDelay       = "rescan_delay",
  X_000E50_ACSRescanDelayMaxEvents = "rescan_delay_max_events",
  X_000E50_ACSCHFailLockoutPeriod  = "channel_lockout_period",
}

--- Retrieves the acs info for the given param
-- @function getACSOptionValue
-- @param the parameter name
-- @param key the interface name
-- @return the value for the given param from uci(if present) or from ubus
local function getACSOptionValue(param, key)
  local radio = wlanConfigCommon.getRadioFromIface(key)
  local val = getFromUci(wirelessBinding, radio, uciACSOptionMap[param])
  if val == "" then
    val = getWirelessUbus("acs", radio, ubusACSOptionMap[param])
  end
  return val
end

local wepKeys = {}
local wepKeyIndex = {}
uciHelper.foreach_on_uci({ config = "wireless", sectionname = "wifi-ap" }, function(s)
  local name = s[".name"]
  wepKeyIndex[name] = 1
  wepKeys[name] = { "", "", "", "" }
end)

local uciUpgradeOptionMap = {
  X_000E50_UpgradeURL         = "remote_upgrade_url",
  X_000E50_UpgradeCheckPeriod = "remote_upgrade_check_period"
}

local ubusUpgradeOptionMap = {
  X_000E50_UpgradeURL         = "url",
  X_000E50_UpgradeCheckPeriod = "check_period"
}

--- Retrieves the remote upgrade information
-- @function getUpgradeInfo
-- @param the parameter name
-- @param key the interface name
-- @return the value for the given param from uci(if present) or the value is retrieved from ubus
local function getUpgradeInfo(param, key)
  local radio = wlanConfigCommon.getRadioFromIface(key)
  local val = getFromUci(wirelessBinding, radio, uciUpgradeOptionMap[param])
  if val == "" then
    val = getWirelessUbus("upgrade", radio, ubusUpgradeOptionMap[param]) or ""
  end
  return val
end

local function getMACAddresses(iface, option)
  local macList = {}
  local result = getFromUci(wirelessBinding, wlanConfigCommon.getAPFromIface(iface), option)
  if result ~= "" then
    for _, v in ipairs(result) do
      macList[#macList+1] = v
    end
  end
  return table.concat(macList, ',')
end

local function setMACAddresses(iface, option, value)
  local macList = {}
  for mac in string.gmatch(value, '([^,]+)') do
    if nwCommon.isMAC(mac) then
      macList[#macList + 1] = mac
    else
      return nil, "Invalid MAC address; cannot set"
    end
  end
  setOnUci(wlanConfigCommon.getAPFromIface(iface), option, macList, commitapply)
end

local getWLANDevice = {
  WMMEnable = "1",
  UAPSDEnable = "0",
  WMMSupported = "1",
  UAPSDSupported = "0",
  Enable = function(mapping, param, key)
    return getEnable(key)
  end,
  Status = function(mapping, param, key)
    key = key:gsub("_remote", "")
    local status = getWirelessUbus("ssid", key, "oper_state")
    return status == "1" and "Up" or "Disabled"
  end,
  BSSID = function(mapping, param, key)
    key = key:gsub("_remote", "")
    return getWirelessUbus("ssid", key, "bssid")
  end,
  MaxBitRate = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local bitRate = getWirelessUbus("radio", radio, "max_phy_rate")
    return bitRate ~= "" and tostring(tonumber(bitRate)/1000) or "Auto"
  end,
  Channel = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local val = getFromUci(wirelessBinding, radio, "channel")
    if val ~= "" and val ~= "auto" then
      return val
    end
    return getWirelessUbus("radio", radio, "channel")
  end,
  Name = function(mapping, param, key)
    return key:gsub("_remote", "") or ""
  end,
  SSID = function(mapping, param, key)
    key = key:gsub("_remote", "")
    return getFromUci(wirelessBinding, key, "ssid")
  end,
  TransmitPowerSupported = "25,50,75,100",
  TransmitPower = function(mapping, param, key)
    return getTransmitPower(key)
  end,
  BeaconType = function(mapping, param, key)
    return beaconTypeMap[getAPMode(key)] or ""
  end,
  MACAddressControlEnabled = function(mapping, param, key)
    return getMACAddressControlEnabled(key)
  end,
  Standard = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getRadioStandard(radio)
  end,
  WEPKeyIndex = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return tostring(wepKeyIndex[ap])
  end,
  KeyPassphrase = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return getFromUci(wirelessBinding, ap, "wpa_psk_key")
  end,
  WEPEncryptionLevel = "Disabled,40-bit,104-bit",
  BasicEncryptionModes = function(mapping, param, key)
    return encryptionModeMap[getAPMode(key)] or "None"
  end,
  BasicAuthenticationMode = "None",
  WPAEncryptionModes = "TKIPEncryption",
  WPAAuthenticationMode = function(mapping, param, key)
    local mode = getWirelessUbus("security", key, "mode")
    return wpaAuthenticationModeMap[mode] or ""
  end,
  IEEE11iEncryptionModes = "AESEncryption",
  IEEE11iAuthenticationMode = function(mapping, param, key)
    return wpaAuthenticationModeMap[getAPMode(key)] or ""
  end,
  PossibleChannels = function(mapping, param, key)
    return getChannels(key, nil, "allowed_channels")
  end,
  BasicDataTransmitRates = function(mapping, param, key)
    return getRates(param, key)
  end,
  OperationalDataTransmitRates = function(mapping, param, key)
    return getRates(param, key)
  end,
  PossibleDataTransmitRates = function(mapping, param, key)
    return getRates(param, key)
  end,
  InsecureOOBAccessEnabled = "1",
  BeaconAdvertisementEnabled = "1",
  SSIDAdvertisementEnabled = function(mapping, param, key)
    return getSSIDAdvertisementEnabled(key)
  end,
  RadioEnabled = function(mapping, param, key)
    return getRadioEnabled(key)
  end,
  AutoRateFallBackEnabled = "1",
  LocationDescription = "",
  RegulatoryDomain = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getFromUci(wirelessBinding, radio, "country")
  end,
  TotalPSKFailures = "0",
  TotalIntegrityFailures = "0",
  ChannelsInUse = function(mapping, param, key)
    return getChannels(key, nil, "used_channels")
  end,
  DeviceOperationMode = "InfrastructureAccessPoint",
  DistanceFromRoot = "0",
  PeerBSSID = "",
  AuthenticationServiceMode = function(mapping, param, key)
    return getAuthenticationServiceMode(key)
  end,
  TotalBytesSent = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("radiostats", radio, "tx_bytes")
  end,
  TotalBytesReceived = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("radiostats", radio, "rx_bytes")
  end,
  TotalPacketsSent = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("radiostats", radio, "tx_packets")
  end,
  TotalPacketsReceived = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("radiostats", radio, "rx_packets")
  end,
  X_000E50_ACSState = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("radio", radio, "state")
  end,
  X_000E50_ACSMode = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("acs", radio, "policy")
  end,
  X_000E50_ACSCHMonitorPeriod = function(mapping, param, key)
    return getACSOptionValue(param, key)
  end,
  X_000E50_ACSScanReport = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("acs", radio, "scan_report")
  end,
  X_000E50_ACSScanHistory = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("acs", radio, "scan_history")
  end,
  X_000E50_ACSRescanPeriod = function(mapping, param, key)
    return getACSOptionValue(param, key)
  end,
  X_000E50_ACSRescanDelayPolicy = function(mapping, param, key)
    return getACSOptionValue(param, key):lower()
  end,
  X_000E50_ACSRescanDelay = function(mapping, param, key)
    return getACSOptionValue(param, key)
  end,
  X_000E50_ACSRescanDelayMaxEvents = function(mapping, param, key)
    return getACSOptionValue(param, key)
  end,
  X_000E50_ACSCHFailLockoutPeriod = function(mapping, param, key)
    return getACSOptionValue(param, key)
  end,
  AutoChannelEnable  = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local channel = getFromUci(wirelessBinding, radio, "channel")
    return channel == "auto" and "1" or "0"
  end,
  X_AutoChannelReselectionTimeout = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local acsdata = getWirelessUbus("acs", radio)
    return acsdata["rescan_period"] and tostring(acsdata["rescan_period"]) or "0"
  end,
  X_AutoChannelReselectionEnable = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local channel = getFromUci(wirelessBinding, radio, "channel")
    return (channel == "auto") and "1" or "0"
  end,
  X_WPS_V2_ENABLE = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return getFromUci(wirelessBinding, ap, "wps_state", "0")
  end,
  X_000E50_ACSRescan = "0",
  X_000E50_ACSBssList = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getACSBssList(radio)
  end,
  X_000E50_ChannelMode = function(mapping, param , key)
    return getChannelMode(key)
  end,
  X_000E50_Power = function(mapping, param , key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local power = getFromUci(wirelessBinding, radio, "tx_power_adjust")
    return power ~= "" and powerLevelMap[power] or "4"
  end,
  X_000E50_PowerDefault = "1",
  X_000E50_PowerList = "1,2,3,4",
  X_000E50_PacketsDropped = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local stats = getWirelessUbus("radiostats", radio)
    return stats and tostring((tonumber(stats.rx_discards) or 0) + (tonumber(stats.tx_discards) or 0)) or "0"
  end,
  X_000E50_PacketsErrored = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local stats = getWirelessUbus("radiostats", radio)
    return stats and tostring((tonumber(stats.rx_errors) or 0) + (tonumber(stats.tx_errors) or 0)) or "0"
  end,
  X_000E50_RemotelyManaged = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("radio", radio, "remotely_managed")
  end,
  X_000E50_UpgradeURL = function(mapping, param, key)
    return getUpgradeInfo(param, key)
  end,
  X_000E50_UpgradeCheckPeriod = function(mapping, param, key)
    return getUpgradeInfo(param, key)
  end,
  X_000E50_UpgradeSWVersion = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("upgrade", radio, "software_version") or ""
  end,
  X_000E50_BandSteerEnable = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return bandSteerHelper.isBandSteerEnabledByAp(ap) and "1" or "0"
  end,
  X_000E50_ChannelWidth = function(mapping, param , key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getFromUci(wirelessBinding, radio, "channelwidth")
  end,
  X_000E50_ShortGuardInterval = function(mapping, param , key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getFromUci(wirelessBinding, radio, "sgi")
  end,
  X_000E50_SpaceTimeBlockCoding = function(mapping, param , key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getFromUci(wirelessBinding, radio, "stbc")
  end,
  X_000E50_CyclicDelayDiversity = function(mapping, param , key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getFromUci(wirelessBinding, radio, "cdd")
  end,
  X_000E50_ChannelBandwidth = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local channelBandWidth = getFromUci(wirelessBinding, radio, "channelwidth")
    return channelBandWidth == "auto" and "Auto" or tostring(channelBandWidth)
  end,
  X_0876FF_AllowedMACAddresses = function(mapping, param, key)
    return getMACAddresses(key, "acl_accept_list")
  end,
  X_0876FF_DeniedMACAddresses = function(mapping, param, key)
    return getMACAddresses(key, "acl_deny_list")
  end,
  X_0876FF_SupportedFrequencyBands = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("radio", radio, "supported_frequency_bands")
  end,
  X_0876FF_OperatingFrequencyBand = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("radio", radio, "band")
  end,
  X_0876FF_SupportedStandards = function(mapping, param, key)
    local standards = getWirelessUbus("radio", wlanConfigCommon.getRadioFromIface(key), "supported_standards")
    return getStdList(standards)
  end,
  X_0876FF_KeyPassphrase = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return getFromUci(wirelessBinding, ap, "wpa_psk_key")
  end,
  X_000E50_SetDefAcAgg = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local radioType = getFromUci(wirelessBinding, radio, "type")
    return radioType == "quantenna" and getFromUci(wirelessBinding, radio, "ac_agg_vi") ~= "" and "0" or "1"
  end,
  X_0876FF_WMMPowerSaveEnabled = "0",  --always returns "0" as it is hard-coded
  X_0876FF_RestoreDefaultKey = "0", -- always returns "0", If enabled sets the default key from wireless_defaults
  X_0876FF_RestoreDefaultWireless = "0", -- always returns "0", If enabled, resets the default configuration of particular interface and ap
  X_0876FF_DFSAvailable = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    if radio == "radio_2G" then
      return "0" -- always returns "0", since DFS Channels are supported only for radio_5G
    else
      return "1" -- always returns "1", since DFS Channels are supported
    end
  end,
  X_0876FF_DFSEnable = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    if radio == "radio_2G" then
      return "0" -- always returns "0", since DFS Channels are supported only for radio_5G
    else
      return getDFSStatus(radio)
    end
  end,
  X_0876FF_MaxConcurrentDevices = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return getFromUci(wirelessBinding, ap, "max_assoc", "0")
  end,
  X_VODAFONE_Key = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return getFromUci(wirelessBinding, ap, "wpa_psk_key")
  end,
  X_000E50_Band = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getWirelessUbus("radio", radio, "band")
  end,
  X_VODAFONE_WPAPassword = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return getFromUci(wirelessBinding, ap, "wpa_psk_key")
  end,
  X_VODAFONE_MACAddressControlMode = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    local aclMode = getFromUci(wirelessBinding, ap, "acl_mode")
    return modeMap[aclMode] or "Off"
  end,
  X_0876FF_SubnetEnable = function(mapping, param, key)
    return getSubnetInfo(key, "auto") == "0" and "0" or "1"
  end,
  X_0876FF_SubnetMask = function(mapping, param, key)
    return getSubnetInfo(key, "netmask")
  end,
  X_0876FF_SubnetGatewayAddr = function(mapping, param, key)
    return getSubnetInfo(key, "ipaddr")
  end,
  X_0876FF_RadioID = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    -- TODO: Hard-coded values should be revisited
    return radio == "radio_2G" and "1" or "2"
  end,
  X_0876FF_SubnetMinAddr = function(mapping, param, key)
    return getSubnetAddress(key)
  end,
  X_0876FF_SubnetMaxAddr = function(mapping, param, key)
    local _, endAddr = getSubnetAddress(key)
    return endAddr or ""
  end,
  X_0876FF_GREInterface = function(mapping, param, key)
    local iface = getFromUci(wirelessBinding, key, "gre_tunnel_iface", "gre-gt0")
    return resolve('InternetGatewayDevice.GRE.Tunnel.{i}.Interface.{i}.', iface) or ""
  end,
  X_000E50_PMF = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return ucitoigdMap[getFromUci(wirelessBinding, ap, "pmf", "disabled")]
  end,
  X_000E50_MuMimo = function(mapping, param, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    return getFromUci(wirelessBinding, radio, "mumimo", "0")
  end,
  X_SecurityModesSupported = function(mapping, param, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    return getModesSupported(ap)
  end,
  X_SupportedStandards = function(mapping, param, key)
    local standards = getDataFromRadio(wlanConfigCommon.getRadioFromIface(key), "supported_standards") or ""
    return convertToList(standards)
  end,
  X_RadioStatus = function(mapping, param, key)
    return getRadioStatus(key)
  end,
  X_LastChange = function(mapping, param, key)
    return tostring(getClockTime(posix.CLOCK_MONOTONIC) - (lastStateChangeTime[wlanConfigCommon.getRadioFromIface(key)] or 0))
  end,
}

local function getallWLANDevice(mapping, key)
  local keySub = key:gsub("_remote", "")
  local radio = wlanConfigCommon.getRadioFromIface(key)
  local uciValues = getFromUci(wirelessBinding, radio)
  local ap = wlanConfigCommon.getAPFromIface(key)
  local radioData = getWirelessUbus("radio", radio)
  local apSecData = getWirelessUbus("security", key)
  local acsData = getWirelessUbus("acs", radio)
  local ssidData = getWirelessUbus("ssid", keySub)
  local radioStats = getWirelessUbus("radiostats", radio)
  local ifaceName = key:gsub("_remote", "") or ""
  local subnetInfo = getSubnetInfo(key)
  local startAddr, endAddr = getSubnetAddress(key)
  return {
    Enable = getEnable(key),
    Status = ssidData.oper_state and tostring(ssidData.oper_state) == "1" and "Up" or "Disabled",
    BSSID = ssidData.bssid and tostring(ssidData.bssid) or "",
    MaxBitRate = radioData.max_phy_rate and tostring(tonumber(radioData.max_phy_rate)/1000) or "Auto",
    Channel = radioData.channel and tostring(radioData.channel) or "",
    Name = ifaceName,
    SSID = getFromUci(wirelessBinding, ifaceName, "ssid"),
    TransmitPowerSupported = "25,50,75,100",
    TransmitPower = getTransmitPower(key),
    BeaconType = beaconTypeMap[getAPMode(key)] or "",
    MACAddressControlEnabled = getMACAddressControlEnabled(key),
    Standard = getRadioStandard(radio),
    WEPKeyIndex = tostring(wepKeyIndex[ap]),
    KeyPassphrase = getFromUci(wirelessBinding, ap, "wpa_psk_key"),
    BasicEncryptionModes = encryptionModeMap[getAPMode(key)] or "None",
    WPAAuthenticationMode = apSecData.mode and wpaAuthenticationModeMap[apSecData.mode] or "",
    IEEE11iAuthenticationMode = wpaAuthenticationModeMap[getAPMode(key)] or "",
    OperationalDataTransmitRates = getRates("OperationalDataTransmitRates", key),
    PossibleDataTransmitRates = getRates("PossibleDataTransmitRates", key),
    BasicDataTransmitRates = getRates("BasicDataTransmitRates", key),
    PossibleChannels = getChannels(key, radioData.allowed_channels),
    SSIDAdvertisementEnabled = getSSIDAdvertisementEnabled(key),
    RadioEnabled = getRadioEnabled(key),
    RegulatoryDomain = radioData.country and tostring(radioData.country) or "",
    ChannelsInUse = getChannels(key, radioData.used_channels),
    AuthenticationServiceMode = getAuthenticationServiceMode(key),
    TotalBytesSent = radioStats.tx_bytes and tostring(radioStats.tx_bytes) or "",
    TotalBytesReceived = radioStats.rx_bytes and tostring(radioStats.rx_bytes) or "",
    TotalPacketsSent = radioStats.tx_packets and tostring(radioStats.tx_packets) or "",
    TotalPacketsReceived = radioStats.rx_packets and tostring(radioStats.rx_packets) or "",
    X_000E50_ACSState = acsData.state and tostring(acsData.state) or "",
    X_000E50_ACSMode = acsData.policy and tostring(acsData.policy) or "",
    X_000E50_ACSCHMonitorPeriod = getACSOptionValue("X_000E50_ACSCHMonitorPeriod", key),
    X_000E50_ACSScanReport = acsData.scan_report and tostring(acsData.scan_report) or "",
    X_000E50_ACSScanHistory = acsData.scan_history and tostring(acsData.scan_history) or "",
    X_000E50_ACSRescanPeriod = getACSOptionValue("X_000E50_ACSRescanPeriod", key),
    X_000E50_ACSRescanDelayPolicy = getACSOptionValue("X_000E50_ACSRescanDelayPolicy", key):lower(),
    X_000E50_ACSRescanDelay = getACSOptionValue("X_000E50_ACSRescanDelay", key),
    X_000E50_ACSRescanDelayMaxEvents = getACSOptionValue("X_000E50_ACSRescanDelayMaxEvents", key),
    X_000E50_ACSCHFailLockoutPeriod = getACSOptionValue("X_000E50_ACSCHFailLockoutPeriod", key),
    AutoChannelEnable = uciValues.channel and uciValues.channel == "auto" and "1" or "0",
    X_000E50_ACSBssList = getACSBssList(radio),
    X_000E50_ChannelMode = getChannelMode(key),
    X_000E50_Power = uciValues.tx_power_adjust and powerLevelMap[uciValues.tx_power_adjust] or "4",
    X_000E50_PacketsDropped = tostring((radioStats.rx_discards or 0) + (radioStats.tx_discards or 0)) or "0",
    X_000E50_PacketsErrored = tostring((radioStats.rx_errors or 0) + (radioStats.tx_errors + 0)) or "0",
    X_000E50_RemotelyManaged = radioData.remotely_managed and tostring(radioData.remotely_managed) or "0",
    X_000E50_UpgradeURL = getUpgradeInfo("X_000E50_UpgradeURL", key),
    X_000E50_UpgradeCheckPeriod = getUpgradeInfo("X_000E50_UpgradeCheckPeriod", key),
    X_000E50_UpgradeSWVersion = getWirelessUbus("upgrade", radio, "software_version") or "",
    X_000E50_BandSteerEnable = bandSteerHelper.isBandSteerEnabledByAp(ap) and "1" or "0",
    X_000E50_ChannelWidth = uciValues.channelwidth and uciValues.channelwidth or "",
    X_000E50_ShortGuardInterval = uciValues.sgi and uciValues.sgi or "",
    X_000E50_SpaceTimeBlockCoding = uciValues.stbc and uciValues.stbc or "",
    X_000E50_CyclicDelayDiversity = uciValues.cdd and uciValues.cdd or "",
    X_000E50_ChannelBandwidth = uciValues.channelwidth and (uciValues.channelwidth == "auto" and "Auto" or tostring(uciValues.channelwidth)) or "",
    X_0876FF_AllowedMACAddresses = getMACAddresses(key, "acl_accept_list"),
    X_0876FF_DeniedMACAddresses = getMACAddresses(key, "acl_deny_list"),
    X_0876FF_SupportedFrequencyBands = radioData.supported_frequency_bands and tostring(radioData.supported_frequency_bands) or "",
    X_0876FF_OperatingFrequencyBand = radioData.band and tostring(radioData.band) or "",
    X_0876FF_SupportedStandards = getStdList(radioData.supported_standards),
    X_0876FF_KeyPassphrase = getFromUci(wirelessBinding, ap, "wpa_psk_key"),
    X_0876FF_DFSAvailable = (radio == "radio_2G") and "0" or "1",
    X_0876FF_DFSEnable = (radio == "radio_2G") and "0" or getDFSStatus(radio),
    X_0876FF_MaxConcurrentDevices = getFromUci(wirelessBinding, ap, "max_assoc", "0"),
    X_VODAFONE_Key = getFromUci(wirelessBinding, ap, "wpa_psk_key"),
    X_000E50_Band = radioData.band and tostring(radioData.band) or "",
    X_VODAFONE_WPAPassword = getFromUci(wirelessBinding, ap, "wpa_psk_key"),
    X_VODAFONE_MACAddressControlMode = modeMap[getFromUci(wirelessBinding, ap, "acl_mode")] or "Off",
    X_0876FF_SubnetEnable = subnetInfo and subnetInfo.auto and subnetInfo.auto or "1",
    X_0876FF_SubnetMask = subnetInfo and subnetInfo.netmask and subnetInfo.netmask or "",
    X_0876FF_SubnetGatewayAddr = subnetInfo and subnetInfo.ipaddr and subnetInfo.ipaddr or "",
    X_0876FF_RadioID = radio == "radio_2G" and "1" or "2", -- TODO: Hard-coded values should be revisited
    X_0876FF_SubnetMinAddr = startAddr,
    X_0876FF_SubnetMaxAddr = endAddr or "",
    X_000E50_MuMimo = uciValues.mumimo or "0",
    X_SecurityModesSupported = getModesSupported(ap),
    X_SupportedStandards = convertToList(radioData.supported_standards),
    X_RadioStatus = getRadioStatus(key),
 }
end

local setWLANDevice = {
  Enable = function(mapping, param, value, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    setOnUci(ap, "state", value, commitapply)
    if value == "0" and bandSteerHelper.isBandSteerEnabledByIface(key) then
      return wlanConfigCommon.disableBandSteer(key, commitapply)
    end
  end,
  Channel = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local allowedChannels = getWirelessUbus("radio", radio, "allowed_channels")
    -- set the given channel if the allowed channels list is empty
    if allowedChannels == "" then
      return setOnUci(radio, "channel", value, commitapply)
    end
    for channel in allowedChannels:gmatch("(%d+)") do
      -- set the given channel if it is present in the allowed channels list
      if channel == value then
        return setOnUci(radio, "channel", value, commitapply)
      end
    end
    return nil, "Given channel is not allowed"
  end,
  SSID = function(mapping, param, value, key)
    local iface = key:gsub("_remote", "")
    local validSSID = "^[^?\"$%[%]+\\]*$"
    local validStart = "^[^%s#!;]"
    local preventXssAttack = "<[ -~]+>"
    if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) then
      return nil, "Cannot modify SSID when band steer enabled"
    else
      if value and value ~= "" and value:match(validStart) and value:match(validSSID) and not value:match(preventXssAttack) then
        setOnUci(iface, "ssid", value, commitapply)
        wlanConfigCommon.modifyBSPeerNodeAuthentication("ssid", value, key, commitapply)
      elseif value and value ~= "" then
        return nil, "SSID should not contain ?, \", $, [, \\, ],and + special characters or not start with ; # ! and should not contain <> characters to prevent XSS script execution."
      else
        return nil, "SSID can not be empty"
      end
    end
  end,
  TransmitPower = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local power = transmitPowerMap[value]
    if power then
      return setOnUci(radio, "tx_power_adjust", power, commitapply)
    end
    return nil,"Invalid power value"
  end,
  BeaconType = function(mapping, param, value, key)
    local iface = key:gsub("_remote", "")
    if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) then
      return nil, "Cannot modify the value when bandsteer is enabled"
    end
    local ap = wlanConfigCommon.getAPFromIface(key)
    local supportedSecMode = getWirelessUbus("security", key, "supported_modes")
    local secMode = getFromUci(wirelessBinding, ap, "security_mode")
    local beaconType = beaconTypeMap[value]
    if not beaconType then
      if value == "Basic" then
        if secMode ~= "none" and secMode ~= "wep" then
          if supportedSecMode:match("wep") then
            beaconType = "wep"
          else
            beaconType = "none"
          end
        else
          beaconType = secMode
        end
      else
        return nil, "Unsupported BeaconType Value"
      end
    elseif value == "11i" then
      if secMode == "wpa2" or secMode == "wpa-wpa2" then
        beaconType = "wpa2"
      else
        beaconType = "wpa2-psk"
      end
    elseif value == "WPAand11i" then
      if secMode == "wpa2" or secMode == "wpa-wpa2" then
        beaconType = "wpa-wpa2"
      else
        beaconType = "wpa-wpa2-psk"
      end
    end
    if nwWifi.isSupportedMode(ap, beaconType) then
      setOnUci(ap, "security_mode", beaconType, commitapply)
      wlanConfigCommon.modifyBSPeerNodeAuthentication("security_mode", beaconType, key, commitapply)
    else
      return nil, "Cannot modify the beacon type for unsupported security modes"
    end
  end,
  MACAddressControlEnabled = function(mapping, param, value, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    local aclmode = "disabled"
    if value == "1" then
      aclmode = "lock"
    end
    setOnUci(ap, "acl_mode", aclmode, commitapply)
  end,
  WEPKeyIndex = function(mapping, param, value, key)
    local index = tonumber(value)
    local ap = wlanConfigCommon.getAPFromIface(key)
    if index ~= wepKeyIndex[ap] then
      wepKeyIndex[ap] = index
      setOnUci(ap, "wep_key", wepKeys[ap][index], commitapply)
    end
  end,
  KeyPassphrase = function(mapping, param, value, key)
    local len = value:len()
    if (len < 8 or len > 63) then
      return nil,"invalid value"
    end
    local iface = key:gsub("_remote", "")
    if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) then
      return nil, "Cannot modify KeyPassphrase when bandsteer is enabled"
    else
      local ap = wlanConfigCommon.getAPFromIface(key)
      setOnUci(ap, "wpa_psk_key", value, commitapply)
      wlanConfigCommon.modifyBSPeerNodeAuthentication("wpa_psk_key", value, key, commitapply)
      for wepKey in pairs(wepKeys[ap]) do
        wepKeys[ap][wepKey] = value
      end
    end
  end,
  BasicEncryptionModes = function(mapping, param, value, key)
    local iface = key:gsub("_remote", "")
    if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) and value == "WEPEncryption" then
      return nil, "Cannot modify BasicEncryptionModes when band steer enabled"
    end
    local ap = wlanConfigCommon.getAPFromIface(key)
    local supportedModes = getWirelessUbus("security", key, "supported_modes")
    local secMode = getFromUci(wirelessBinding, ap, "security_mode")
    local mode = ""
    -- BasicEncryptionModes is effect only when BeaconType is Basic
    if secMode == "none" or secMode == "wep" then
      if value == "WEPEncryption" then
        if not supportedModes:match("wep") then
          return nil, "wep is not supported"
        end
        mode = "wep"
      elseif value == "None" then
        mode = "none"
      end
      if mode ~= "" then
        setOnUci(ap, "security_mode", mode, commitapply)
        wlanConfigCommon.modifyBSPeerNodeAuthentication("security_mode", mode, key, commitapply)
      end
    else
      return nil, "Not supported if BeaconType is not 'Basic'"
    end
  end,
  WPAEncryptionModes = function(mapping, param, value, key)
    local iface = key:gsub("_remote", "")
    if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) then
      return nil, "Cannot modify the value when bandsteer is enabled"
    end
    -- hardcoded to TKIPEncrytption, based on lower layer support.
  end,
  WPAAuthenticationMode = function(mapping, param, value, key)
    local iface = key:gsub("_remote", "")
    if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) then
      return nil, "Cannot modify the value when bandsteer is enabled"
    end
    return setAuthenticationMode(key, value, commitapply)
  end,
  IEEE11iEncryptionModes = function(mapping, param, value, key)
    local iface = key:gsub("_remote", "")
    if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) then
      return nil, "Cannot modify the value when bandsteer is enabled"
    end
    -- hardcoded to AESEncrytption, based on lower layer support.
  end,
  IEEE11iAuthenticationMode = function(mapping, param, value, key)
    local iface = key:gsub("_remote", "")
    if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) then
      return nil, "Cannot modify the value when bandsteer is enabled"
    end
    return setAuthenticationMode(key, value, commitapply)
  end,
  BasicDataTransmitRates = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local rateSet = getFromUci(wirelessBinding, radio, "rateset")
    local rateSetVal, err = nwWifi.setBasicRateset(value, rateSet)
    if rateSetVal then
      setOnUci(radio, "rateset", rateSetVal, commitapply)
    else
      return nil, err
    end
  end,
  OperationalDataTransmitRates = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local rateSet = getFromUci(wirelessBinding, radio, "rateset")
    local rateSetVal, err = nwWifi.setOperationalRateset(value, rateSet)
    if rateSetVal then
      setOnUci(radio, "rateset", rateSetVal, commitapply)
    else
      return nil, err
    end
  end,
  SSIDAdvertisementEnabled = function(mapping, param, value, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    setOnUci(ap, "public", value, commitapply)
  end,
  RadioEnabled = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    setOnUci(radio, "state", value, commitapply)
  end,
  RegulatoryDomain = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    setOnUci(radio, "country", value, commitapply)
  end,
  AuthenticationServiceMode = function(mapping, param, value, key)
    local mode = authServiceModeMap[value]
    local iface = key:gsub("_remote", "")
    if not bandSteerHelper.isBaseIface(iface) and bandSteerHelper.isBandSteerEnabledByIface(iface) and mode == "wep" then
      return nil, "Can not modify the value to wep when band steer enabled"
    end
    setOnUci(wlanConfigCommon.getAPFromIface(key), "security_mode", mode, commitapply)
    wlanConfigCommon.modifyBSPeerNodeAuthentication("security_mode", mode, key, commitapply)
  end,
  X_000E50_ACSCHMonitorPeriod = function(mapping, param, value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "acs_channel_monitor_period", value, commitapply)
  end,
  X_000E50_ACSRescanPeriod = function(mapping, param, value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "acs_rescan_period", value, commitapply)
  end,
  X_000E50_ACSRescanDelayPolicy = function(mapping, param, value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "acs_rescan_delay_policy", value, commitapply)
  end,
  X_000E50_ACSRescanDelay = function(mapping, param, value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "acs_rescan_delay", value, commitapply)
  end,
  X_000E50_ACSRescanDelayMaxEvents = function(mapping, param, value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "acs_rescan_delay_max_events", value, commitapply)
  end,
  X_000E50_ACSCHFailLockoutPeriod = function(mapping, param, value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "acs_channel_fail_lockout_period", value, commitapply)
  end,
  AutoChannelEnable  = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    if value == "1" then
      value = "auto"
    elseif value == "0" then
      local channel = getFromUci(wirelessBinding, radio, "channel")
      channel = channel == "" and "auto" or channel
      if channel ~= "auto" then
        value = channel
      else
        value = getWirelessUbus("radio", radio, "channel")
      end
    end
    setOnUci(radio, "channel", value, commitapply)
  end,
  X_AutoChannelReselectionTimeout = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    setOnUci(radio, "acs_rescan_period", value, commitapply)
  end,
  X_AutoChannelReselectionEnable = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    if value == "1" then
      value = "auto"
    elseif value == "0" then
      local channel = getFromUci(wirelessBinding, radio, "channel")
      channel = channel == "" and "auto" or channel
      if channel ~= "auto" then
        value = channel
      else
        value = getWirelessUbus("radio", radio, "channel")
      end
    end
    setOnUci(radio, "channel", value, commitapply)
  end,
  X_WPS_V2_ENABLE = function(mapping, param, value, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    setOnUci(ap, "wps_state", value, commitapply)
  end,
  X_000E50_ACSRescan = function(mapping, param, value, key)
    conn:call("wireless.radio.acs", "rescan", { name = wlanConfigCommon.getRadioFromIface(key), act = value })
  end,
  X_000E50_ChannelMode = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local channel = getFromUci(wirelessBinding, radio, "channel")
    channel = channel == "" and "auto" or channel
    if value == "Manual" then
      if channel == "auto" then
        channel = getWirelessUbus("radio", radio, "channel")
      end
    elseif value == "Auto" then
      channel = "auto"
    end
    setOnUci(radio, "channel", channel, commitapply)
  end,
  X_000E50_Power = function(mapping, param, value, key)
    local power = powerLevelMap[value] or "-3"
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "tx_power_adjust", power, commitapply)
  end,
  X_000E50_UpgradeURL = function(mapping, param, value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "remote_upgrade_url", value, commitapply)
  end,
  X_000E50_UpgradeCheckPeriod = function(mapping, param, value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "remote_upgrade_check_period", value, commitapply)
  end,
  X_000E50_BandSteerEnable = function(mapping, param, value, key)
    if value == "1" then
      wlanConfigCommon.enableBandSteer(key, commitapply)
    else
      wlanConfigCommon.disableBandSteer(key, commitapply)
    end
    transactions[wirelessBinding.config] = true
  end,
  X_000E50_ChannelWidth = function(mapping, param, value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "channelwidth", value, commitapply)
  end,
  X_000E50_SetDefAcAgg = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    local radioType = getFromUci(wirelessBinding, radio, "type")
    value = (value == "0") and "3000" or ""
    if radioType == "quantenna" then
      setOnUci(radio, "ac_agg_vi", value, commitapply)
    else
      return nil, "SetDefAcAgg is applicable only for quantenna based radio_5G"
    end
  end,
  X_000E50_ShortGuardInterval = function(mapping, param , value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "sgi", value, commitapply)
  end,
  X_000E50_SpaceTimeBlockCoding = function(mapping, param , value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    if radio == "radio_2G" then
      setOnUci(radio, "stbc", value, commitapply)
    else
      return nil, "For 5G mode, BCM setting is not available"
    end
  end,
  X_000E50_CyclicDelayDiversity = function(mapping, param , value, key)
    setOnUci(wlanConfigCommon.getRadioFromIface(key), "cdd", value, commitapply)
  end,
  X_000E50_ChannelBandwidth = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    value = value == "Auto" and "auto" or tostring(value)
    if value == "20/40MHz" and radio == "radio_2G" then
      return nil, "Invalid channelwidth for 2.4G"
    end
    setOnUci(radio, "channelwidth", value, commitapply)
  end,
  X_0876FF_AllowedMACAddresses = function(mapping, param, value, key)
    return setMACAddresses(key, "acl_accept_list", value)
  end,
  X_0876FF_DeniedMACAddresses = function(mapping, param, value, key)
    return setMACAddresses(key, "acl_deny_list", value)
  end,
  X_0876FF_KeyPassphrase = function(mapping, param, value, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    setOnUci(ap, "wpa_psk_key", value, commitapply)
  end,
  X_0876FF_RestoreDefaultKey = function(mapping, param, value, key)
    if value == "1" then
      local ap = wlanConfigCommon.getAPFromIface(key)
      local defaultKey = getFromUci(wirelessDefaultsBinding, ap, "wpa_psk_key")
      setOnUci(ap, "wpa_psk_key", defaultKey, commitapply)
    end
  end,
  X_0876FF_RestoreDefaultWireless = function(mapping, param, value, key)
    if value == "1" then
      local ifaceName = key:gsub("_remote", "") or ""
      local ap = wlanConfigCommon.getAPFromIface(key)
      -- restore the default configuration for interface
      restoreSection("wifi-iface", ifaceName)
      -- restore the default configuration for accesspoint
      restoreSection("wifi-ap", ap)
    end
  end,
  X_0876FF_DFSEnable = function(mapping, param, value, key)
    local radio = wlanConfigCommon.getRadioFromIface(key)
    if radio == "radio_5G" then
      local channels = channelStrToList(getWirelessUbus("radio", radio, "allowed_channels"))
      if value == "1" then
        channels = addDFSChannels(channels)
      else
        channels = removeDFSChannels(channels)
      end
      setOnUci(radio, "allowed_channels", channels, commitapply)
    else
      return nil, "For 2G mode, DFSEnable is not available"
    end
  end,
  X_VODAFONE_Key = function(mapping, param, value, key)
    setWPAKey(key, value, commitapply)
  end,
  X_VODAFONE_WPAPassword = function(mapping, param, value, key)
    setWPAKey(key, value, commitapply)
  end,
  X_VODAFONE_MACAddressControlMode = function(mapping, param, value, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    setOnUci(ap, "acl_mode", modeMap[value], commitapply)
  end,
  X_0876FF_SubnetEnable = function(mapping, param, value, key)
    local ifname = getSubnetInfo(key, "ifname")
    local intf = {}
    for word in ifname:gmatch("%S+") do intf[#intf + 1] = word end
    if #intf > 1 then
      return nil, "Subnet cannot be disabled since it involves more than 1 interface"
    end
    setSubnetInfo(key, "auto", value)
  end,
  X_0876FF_SubnetMask = function(mapping, param, value, key)
    setSubnetInfo(key, "netmask", value)
  end,
  X_0876FF_SubnetGatewayAddr = function(mapping, param, value, key)
    setSubnetInfo(key, "ipaddr", value)
  end,
  X_0876FF_SubnetMinAddr = function(mapping, param, value, key)
    local iface = key:gsub("_remote", "")
    local interface = getFromUci(wirelessBinding, iface, "network")
    local res, err = network.setDHCPMinAddress(interface, value, commitapply)
    if not res then
      return nil, err
    end
    transactions["dhcp"] = true
  end,
  X_0876FF_SubnetMaxAddr = function(mapping, param, value, key)
    local iface = key:gsub("_remote", "")
    local interface = getFromUci(wirelessBinding, iface, "network")
    local res, err = network.setDHCPMaxAddress(interface, value, commitapply)
    if not res then
      return nil, err
    end
    transactions["dhcp"] = true
  end,
  X_0876FF_GREInterface = function(mapping, param, value, key)
    local val = tokey(value, "InternetGatewayDevice.GRE.Tunnel.{i}.Interface.{i}.")
    setOnUci(key, "gre_tunnel_iface", val, commitapply)
  end,
  X_000E50_PMF = function(mapping, param, value, key)
    local ap = wlanConfigCommon.getAPFromIface(key)
    if value ~= "Disabled" then
      local securityMode = getFromUci(wirelessBinding, ap, "security_mode")
      if securityMode:match("^wpa2%-") then
        return setOnUci(ap, "pmf", igdtouciMap[value], commitapply)
      else
        return nil, "Security mode should be WPA2"
      end
    else
      return setOnUci(ap, "pmf", igdtouciMap[value], commitapply)
    end
  end,
  X_000E50_MuMimo = function(mapping, param, value, key)
      local radio = wlanConfigCommon.getRadioFromIface(key)
      setOnUci(radio, "mumimo", value, commitapply)
  end,
}

local function commit()
  for config in pairs(transactions) do
    uciHelper.commit({config = config})
  end
  transactions = {}
end

local function revert()
  for config in pairs(transactions) do
    uciHelper.revert({config = config})
  end
  transactions = {}
end

-- TODO remove this workaround when NG-15901 is implemented
local function handle_state_option(sectionname)
  local ifaces, igd
  local section = getFromUci(wirelessBinding, sectionname)
  if section[".type"] == "wifi-iface" then
    ifaces = sectionname
    igd = "Enable"
  elseif section[".type"] == "wifi-ap" then
    ifaces = section["iface"]
    igd = "Enable"
  elseif section[".type"] == "wifi-device" then
    ifaces = getIfacesForRadio(sectionname)
    lastStateChangeTime[sectionname] = getClockTime(posix.CLOCK_MONOTONIC)
    igd = "RadioEnabled"
  end
  return ifaces, igd
end

local function translate_cb(_, _, _, _, sectionname, option)
  local ifaces
  local igd
  if option == "ssid" then
    ifaces = sectionname
    igd = "SSID"
  elseif option == "channel" then
    ifaces = getIfacesForRadio(sectionname)
    igd = "Channel"
  elseif option == "wpa_psk_key" then
    ifaces = getIfaceForAP(sectionname)
    igd = "KeyPassphrase"
  elseif option == "state" then
    ifaces, igd =  handle_state_option(sectionname)
  end
  if igd and ifaces then
    local events = {}
    if type(ifaces) == "table" then
      for _,v in ipairs(ifaces) do
        events[#events + 1] = { key = v, paramname = igd }
        events[#events + 1] = { key = v.."_remote", paramname = igd }
      end
    else
      events[#events + 1] = { key = ifaces, paramname = igd }
      events[#events + 1] = { key = ifaces.."_remote", paramname = igd }
    end
    if #events > 0 then
      return events
    end
  end
end

local function ubus_event_cb_status(mapping, event, data)
  if data.oper_state and data.name then
    return { { key = data["name"], paramname = "Status" }, { key = data["name"].."_remote", paramname = "Status" } }
  end
end

local function ubus_event_cb_totalassociations(mapping, event, data)
  if ( data["state"]== "Associated" or data["state"] == "Disconnected" ) then
    local ap = data["ap_name"]
    local iface = getIfaceForAP(ap)
    if iface then
      return { { key = iface, paramname = "TotalAssociations" }, { key = iface.."_remote", paramname = "TotalAssociations" } }
    end
  end
end

WLANConfiguration.add_watchers = function(mapping)
  local uci_evsrc = eventsource("uci")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-iface", nil, "ssid")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-iface", nil, "state")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-device", nil, "channel")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-ap", nil, "wpa_psk_key")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-ap", nil, "state")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-device", nil, "state")

  local ubus_evsrc = eventsource("ubus")
  ubus_evsrc.watch_event(mapping, ubus_event_cb_status, "wireless.ssid")
  ubus_evsrc.watch_event(mapping, ubus_event_cb_totalassociations, "wireless.accesspoint.station")
end

WLANConfiguration.entries = entriesWLANDevice
WLANConfiguration.getall = getallWLANDevice
WLANConfiguration.get = getWLANDevice
WLANConfiguration.set = setWLANDevice
WLANConfiguration.commit = commit
WLANConfiguration.revert = revert

do
  local duplicator = mapper("multiroot").duplicate
  local  duplicates = duplicator(WLANConfiguration, "#SUBROOT", {
                        "LANDevice.{i}",
                        "LANInterfaces"
                      })
  for _, mapping in ipairs(duplicates) do
    if mapping.objectType.name:match("InternetGatewayDevice.LANDevice") then
      mapping.entries = entriesWLANDevice
    else
      mapping.entries = entriesWLANInterfaces
    end
    register(mapping)
  end
end

