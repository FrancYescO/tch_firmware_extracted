-- Automatically generated from InternetGatewayDevice:1.4
-- using generator version 2.1
local InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_ = {
    objectType = {
        name = "InternetGatewayDevice.LANInterfaces.WLANConfiguration.{i}.",
        access = "readOnly",
        numEntriesParameter = "LANWLANConfigurationNumberOfEntries",
        minEntries = 0,
        maxEntries = math.huge,
        parameters = {
            Enable = {
                access = "readWrite",
                type = "boolean",
            },
            Status = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "Up",
                    "Error",
                    "Disabled",
                },
            },
            BSSID = {
                access = "readOnly",
                type = "string",
            },
            MaxBitRate = {
                access = "readWrite",
                type = "string",
                max = "4",
            },
            Channel = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "0",
                        max = "255",
                    },
                },
            },
            SSID = {
                access = "readWrite",
                type = "string",
                max = "32",
            },
            BeaconType = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "None",
                    "Basic",
                    "WPA",
                    "11i",
                    "BasicandWPA",
                    "Basicand11i",
                    "WPAand11i",
                    "BasicandWPAand11i",
                },
            },
            MACAddressControlEnabled = {
                access = "readWrite",
                type = "boolean",
            },
            Standard = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "a",
                    "b",
                    "g",
                },
            },
            WEPKeyIndex = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "1",
                        max = "4",
                    },
                },
            },
            KeyPassphrase = {
                access = "readWrite",
                type = "string",
                max = "63",
            },
            WEPEncryptionLevel = {
                access = "readOnly",
                list = true,
                max = "64",
                type = "string",
                enumeration = {
                    "Disabled",
                    "40-bit",
                    "104-bit",
                },
            },
            BasicEncryptionModes = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "None",
                    "WEPEncryption",
                },
            },
            BasicAuthenticationMode = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "None",
                    "EAPAuthentication",
                    "SharedAuthentication",
                },
            },
            WPAEncryptionModes = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "TKIPEncryption",
                    "AESEncryption",
                    "TKIPandAESEncryption",
                },
            },
            WPAAuthenticationMode = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "PSKAuthentication",
                    "EAPAuthentication",
                },
            },
            IEEE11iEncryptionModes = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "TKIPEncryption",
                    "AESEncryption",
                    "TKIPandAESEncryption",
                },
            },
            IEEE11iAuthenticationMode = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "PSKAuthentication",
                    "EAPAuthentication",
                    "EAPandPSKAuthentication",
                },
            },
            PossibleChannels = {
                access = "readOnly",
                list = true,
                max = "1024",
                type = "string",
            },
            BasicDataTransmitRates = {
                access = "readWrite",
                list = true,
                max = "256",
                type = "string",
            },
            OperationalDataTransmitRates = {
                access = "readWrite",
                list = true,
                max = "256",
                type = "string",
            },
            PossibleDataTransmitRates = {
                access = "readOnly",
                list = true,
                max = "256",
                type = "string",
            },
            InsecureOOBAccessEnabled = {
                access = "readWrite",
                type = "boolean",
            },
            BeaconAdvertisementEnabled = {
                access = "readOnly",
                type = "boolean",
            },
            SSIDAdvertisementEnabled = {
                access = "readWrite",
                type = "boolean",
            },
            RadioEnabled = {
                access = "readWrite",
                type = "boolean",
            },
            AutoRateFallBackEnabled = {
                access = "readWrite",
                type = "boolean",
            },
            LocationDescription = {
                access = "readWrite",
                type = "string",
                max = "4096",
            },
            RegulatoryDomain = {
                access = "readWrite",
                type = "string",
                max = "3",
            },
            TotalPSKFailures = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            TotalIntegrityFailures = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            ChannelsInUse = {
                access = "readOnly",
                activeNotify = "canDeny",
                list = true,
                max = "1024",
                type = "string",
            },
            DeviceOperationMode = {
                access = "readWrite",
                type = "string",
                max = "31",
                enumeration = {
                    "InfrastructureAccessPoint",
                    "WirelessBridge",
                    "WirelessRepeater",
                    "WirelessStation",
                },
            },
            DistanceFromRoot = {
                access = "readWrite",
                type = "unsignedInt",
            },
            PeerBSSID = {
                access = "readWrite",
                type = "string",
            },
            AuthenticationServiceMode = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "None",
                    "LinkAuthentication",
                    "RadiusClient",
                },
            },
            TotalBytesSent = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            TotalBytesReceived = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            TotalPacketsSent = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            TotalPacketsReceived = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            X_000E50_ACSState = {
                access = "readOnly",
                type = "string",
            },
            X_000E50_ACSMode = {
                access = "readOnly",
                type = "string",
            },
            X_000E50_ACSCHMonitorPeriod = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "1",
                        max = "10",
                    },
                },
            },
            X_000E50_ACSScanReport = {
                access = "readOnly",
                type = "string",
                max = "4096",
            },
            X_000E50_ACSScanHistory = {
                access = "readOnly",
                type = "string",
                max = "2560",
            },
            X_000E50_ACSRescanPeriod = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "0",
                        max = "604800",
                    },
                },
            },
            X_000E50_ACSRescanDelayPolicy = {
                access = "readWrite",
                type = "string",
            },
            X_000E50_ACSRescanDelay = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "10",
                        max = "3600",
                    },
                },
            },
            X_000E50_ACSRescanDelayMaxEvents = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "1",
                        max = "999",
                    },
                },
            },
            X_000E50_ACSCHFailLockoutPeriod = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "1",
                        max = "86400",
                    },
                },
            },
            AutoChannelEnable = {
                access = "readWrite",
                type = "boolean",
            },
            X_000E50_ACSRescan = {
                access = "readWrite",
                type = "boolean",
            },
            X_000E50_ACSBssList = {
                access = "readOnly",
                type = "string",
                max = "16384",
            },
            X_000E50_ChannelMode = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "Auto",
                    "Manual",
                },
            },
            X_000E50_Power = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "1",
                        max = "4",
                    },
                },
            },
            X_000E50_PowerDefault = {
                access = "readOnly",
                type = "string",
            },
            X_000E50_PowerList = {
                access = "readOnly",
                type = "string",
            },
            X_000E50_PacketsDropped = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            X_000E50_PacketsErrored = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            X_000E50_RemotelyManaged = {
                access = "readOnly",
                type = "boolean",
            },
            X_000E50_UpgradeURL = {
                access = "readWrite",
                type = "string",
            },
            X_000E50_UpgradeCheckPeriod = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "1",
                        max = "8760", -- one year
                   },
                },
            },
            X_000E50_UpgradeSWVersion = {
                access = "readOnly",
                type = "string",
            },
        -- TotalAssociations
        -- automatically created when InternetGatewayDevice.LANInterfaces.WLANConfiguration.{i}.AssociatedDevice.{i}. is loaded
        }
    }
}

local require, mapper, error = require, mapper, error
local ipairs, pairs = ipairs, pairs
local register, commitapply = register, commitapply

local uci_helper = mapper("ucihelper")
local common = mapper("nwcommon")
local wlc = require("transformer.shared.WLANConfigurationCommon").getMappings(commitapply)

local conn = mapper("ubus").connect()

local entriesWLANDevice = function()
    local entries = {}
    local lanmap = {}
    local intfmap = {}
    local lan = common.findLanWanInterfaces(false)

    for _,l in ipairs(lan) do
        lanmap[l] = true
        local ll_intfs = common.get_lower_layers(l)

        if ll_intfs then
            for _,v in ipairs(ll_intfs) do
                intfmap[v] = true
            end
        end
    end

    local wlanintf = conn:call("wireless.ssid", "get", {})
    local wlanradio = conn:call("wireless.radio", "get", {})

    if wlanintf then
        for k,v in pairs(wlanintf) do
            -- Remotely managed and the network associated is not a LAN network
            if wlanradio[v.radio].remotely_managed == 1 then
                local network = uci_helper.get_from_uci({ config = "wireless", sectionname = k, option = "network", extended = true})
                if not network or not lanmap[network] then
                    entries[#entries+1] = k .. "_remote"
                end
            -- Integrated and the interface does not belong to a LAN network
            elseif not intfmap[k] then
                entries[#entries+1] = k
            end
        end
    end
    table.sort(entries)
    return entries
end

local iface_binding = {config = "wireless", sectionname = "wifi-iface"}

-- For a given radio name (radio_2G for instance), return the wifi-iface sections associated with it in UCI (wl0)
local function getIfacesForRadio(radio)
  local ifaces = {}
  uci_helper.foreach_on_uci(iface_binding, function(s)
    if s["device"] == radio then
      ifaces[#ifaces + 1] = s[".name"]
    end
  end)
  return ifaces
end

local ap_binding = {config = "wireless", sectionname = nil, option = "iface", extended = true}

-- For a given AP name (ap0 for instance), return the wifi-iface section associated with it in UCI (wl0)
local function getIfaceForAP(ap)
  ap_binding.sectionname = ap
  return uci_helper.get_from_uci(ap_binding)
end

local wireless_binding = { config = "wireless" }

local function get_uci_section(sectionname)
  wireless_binding.sectionname = sectionname
  return uci_helper.getall_from_uci(wireless_binding)
end

-- TODO remove this workaround when NG-15901 is implemented
local function handle_state_option(sectionname)
  local ifaces, igd
  local section = get_uci_section(sectionname)
  if section[".type"] == "wifi-iface" then
    ifaces = sectionname
    igd = "Enable"
  elseif section[".type"] == "wifi-ap" then
    ifaces = section["iface"]
    igd = "Enable"
  elseif section[".type"] == "wifi-device" then
    ifaces = getIfacesForRadio(sectionname)
    igd = "RadioEnabled"
  end
  return ifaces, igd
end

local function translate_cb(_, _, _, _, sectionname, option)
  local ifaces
  local igd
  if option == "ssid" then
    ifaces = sectionname
    igd = "SSID"
  elseif option == "channel" then
    ifaces = getIfacesForRadio(sectionname)
    igd = "Channel"
  elseif option == "wpa_psk_key" then
    ifaces = getIfaceForAP(sectionname)
    igd = "KeyPassphrase"
  elseif option == "state" then
    ifaces, igd =  handle_state_option(sectionname)
  end
  if igd and ifaces then
    local events = {}
    if type(ifaces) == "table" then
      for _,v in ipairs(ifaces) do
        events[#events + 1] = { key = v, paramname = igd }
      end
    else
      events[#events + 1] = { key = ifaces, paramname = igd }
    end
    if #events > 0 then
      return events
    end
  end
end

local function ubus_event_cb_status(mapping, event, data)
  if data.oper_state then
    return { { key = data["name"], paramname = "Status" } }
  end
end

local function ubus_event_cb_totalassociations(mapping, event, data)
  if ( data["state"]== "Associated" or data["state"] == "Disconnected" ) then
    local ap = data["ap_name"]
    local iface = getIfaceForAP(ap)
    if iface then
      return { { key = iface, paramname = "TotalAssociations" } }
    end
  end
end

InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_.add_watchers = function(mapping)
  local uci_evsrc = eventsource("uci")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-iface", nil, "ssid")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-iface", nil, "state")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-device", nil, "channel")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-ap", nil, "wpa_psk_key")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-ap", nil, "state")
  uci_evsrc.watch(mapping, { set = translate_cb }, "wireless", "wifi-device", nil, "state")

  local ubus_evsrc = eventsource("ubus")
  ubus_evsrc.watch_event(mapping, ubus_event_cb_status, "wireless.ssid")
  ubus_evsrc.watch_event(mapping, ubus_event_cb_totalassociations, "wireless.accesspoint.station")
end

InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_.entries = entriesWLANDevice
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_.getall = wlc.wlan.getall
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_.get = wlc.wlan.get
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_.set = wlc.wlan.set
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_.commit = wlc.wlan.commit
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_.revert = wlc.wlan.revert

register(InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_)

local InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_Stats_ = {
    objectType = {
        name = "InternetGatewayDevice.LANInterfaces.WLANConfiguration.{i}.Stats.",
        access = "readOnly",
        minEntries = 1,
        maxEntries = 1,
        parameters = {
            ErrorsSent = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            ErrorsReceived = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            DiscardPacketsSent = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            },
            DiscardPacketsReceived = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "unsignedInt",
            }
        }
    }
}

InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_Stats_.getall = wlc.stats.getall
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_Stats_.get = wlc.stats.get

register(InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_Stats_)

--- WEP keys
local InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_WEPKey_i_ = {
    objectType = {
        name = "InternetGatewayDevice.LANInterfaces.WLANConfiguration.{i}.WEPKey.{i}.",
        access = "readOnly",
        minEntries = 1, -- TODO: understand why transformer complains about minEntries being 4 (see mapload.lua:84)
        maxEntries = 4,
        parameters = {
            WEPKey = {
                access = "readWrite",
                type = "string",
                max = "128",
            }
        }
    }
}

local function wepkey_cb(mapping, action, config, sectiontype, sectionname, option)
  if option == "wep_key" then
     -- see WLANConfigurationCommon.lua for the reason:
     -- 1) entriesWEPKey(), the key was composed of wifi-iface name(parentkey) + "_wep_" + [1-10]
     -- 2) getWEPKey(), when set uci.wireless.wifi-ap.@?.wep_key,
     --    all of InternetGatewayDevice.LANDevice.i.WLANConfiguration.i.WEPKey.?.WEPKey,
     --    whose parentkey is this wifi-iface, will be changed
     local iface = getIfaceForAP(sectionname)
     if iface then
        local events = {}
        for i = 1,4 do
            events[#events + 1] = { key = iface.."_wep_"..tostring(i), paramname = "WEPKey" }
        end
        return events
     end
  end
end

InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_WEPKey_i_.add_watchers = function(mapping)
  local uci_evsrc = eventsource("uci")
  uci_evsrc.watch(mapping, { set = wepkey_cb }, "wireless", "wifi-ap", nil, "wep_key")
end

InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_WEPKey_i_.entries = wlc.wepkey.entries
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_WEPKey_i_.get = wlc.wepkey.get
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_WEPKey_i_.set = wlc.wepkey.set
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_WEPKey_i_.commit = wlc.wepkey.commit
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_WEPKey_i_.revert = wlc.wepkey.revert

register(InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_WEPKey_i_)

--- Preshared Keys
local InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_PreSharedKey_i_ = {
    objectType = {
        name = "InternetGatewayDevice.LANInterfaces.WLANConfiguration.{i}.PreSharedKey.{i}.",
        access = "readOnly",
        minEntries = 1, -- TODO: understand why transformer complains about minEntries being 10 (see mapload.lua:84)
        maxEntries = 10,
        parameters = {
            PreSharedKey = {
                access = "readWrite",
                type = "string",
                max = "64",
            },
            KeyPassphrase = {
                access = "readWrite",
                type = "string",
                max = "63",
            },
            AssociatedDeviceMACAddress = {
                access = "readWrite",
                type = "string",
            }
        }
    }
}

local function presharedkey_cb(mapping, action, config, sectiontype, sectionname, option)
  if option == "wpa_psk_key" then
     -- see WLANConfigurationCommon.lua for the reason:
     -- 1) entriesPreSharedKey(), the key was composed of wifi-iface name(parentkey) + "_psk_" + [1-10]
     -- 2) getPreSharedKey["KeyPassphrase"], when set uci.wireless.wifi-ap.@?.wpa_psk_key
     --    all of InternetGatewayDevice.LANDevice.i.WLANConfiguration.i.PreSharedKey.?.KeyPassphrase,
     --    whose parentkey is this wifi-iface, will be changed
     local iface = getIfaceForAP(sectionname)
     if iface then
        local events = {}
        for i = 1,10 do
            events[#events + 1] = { key = iface.."_psk_"..tostring(i), paramname = "KeyPassphrase" }
        end
        return events
     end
  end
end

InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_PreSharedKey_i_.add_watchers = function(mapping)
  local uci_evsrc = eventsource("uci")
  uci_evsrc.watch(mapping, { set = presharedkey_cb }, "wireless", "wifi-ap", nil, "wpa_psk_key")
end

InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_PreSharedKey_i_.entries = wlc.psk.entries
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_PreSharedKey_i_.get =  wlc.psk.get
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_PreSharedKey_i_.set = wlc.psk.set
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_PreSharedKey_i_.commit = wlc.psk.commit
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_PreSharedKey_i_.revert = wlc.psk.revert

register(InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_PreSharedKey_i_)

--- Associated Devices
local InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_AssociatedDevice_i_ = {
    objectType = {
        name = "InternetGatewayDevice.LANInterfaces.WLANConfiguration.{i}.AssociatedDevice.{i}.",
        access = "readOnly",
        numEntriesParameter = "TotalAssociations",
        minEntries = 0,
        maxEntries = math.huge,
        parameters = {
            AssociatedDeviceMACAddress = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "string",
            },
            AssociatedDeviceIPAddress = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "string",
                max = "64",
            },
            AssociatedDeviceAuthenticationState = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "boolean",
            },
            LastRequestedUnicastCipher = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "string",
                max = "256",
            },
            LastRequestedMulticastCipher = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "string",
                max = "256",
            },
            LastPMKId = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "string",
                max = "256",
            },
            X_000E50_AssociatedDeviceRSSI = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "int",
            },
        }
    }
}

InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_AssociatedDevice_i_.entries = wlc.assoc.entries
InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_AssociatedDevice_i_.get = wlc.assoc.get

register(InternetGatewayDevice_LANInterfaces_WLANConfiguration_i_AssociatedDevice_i_)
