local cmd_output_file = "/var/nf_conn_output"
local nf_conn_file = "/proc/net/nf_conntrack"
local igmp_cache_file = "/proc/net/ip_mr_cache"
local process = require("tch.process")

local function readConnTrack()
  local output
  local file = io.open(nf_conn_file, "r")
  if file then
    output = file:read("*a")
    file:close()
  end
  return output or ""
end

local function getConnTrackData(pattern)
  local count = 0
  local data = readConnTrack()
  for line in data:gmatch("[^\n]+") do
    if line:match(pattern) then
      count = count + 1
    end
  end
  return tostring(count)
end

local function get_shell_cmd_output2(cmd)
  local line
  local output = ""

  os.execute(cmd)
  os.execute("sync")

  local file_handle = io.open(cmd_output_file, "r")
  if ( file_handle == nil ) then
    return ""
  end

  for line in file_handle:lines() do
    output = output .. line
  end

  file_handle:close()
  os.execute("rm " .. cmd_output_file)
  return output
end


-- Automatically generated from InternetGatewayDevice:1.4
-- using generator version 2.1
local InternetGatewayDevice_X_000E50_Connection_ = {
  objectType = {
    name = "InternetGatewayDevice.X_000E50_Connection.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
    }
  }
}


register(InternetGatewayDevice_X_000E50_Connection_)


-- Automatically generated from InternetGatewayDevice:1.3
-- using generator version 2.1
local InternetGatewayDevice_X_000E50_Connection_Stats_ = {
  objectType = {
    name = "InternetGatewayDevice.X_000E50_Connection.Stats.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      MaxNumber = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      Active = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      HalfOpen = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      Multicast = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
    }
  }
}

InternetGatewayDevice_X_000E50_Connection_Stats_.get = {
  MaxNumber = function(mapping)
    local maxValue = ""
    local fd = process.popen("sysctl", {"net.netfilter.nf_conntrack_max"})
    if fd then
      maxValue = fd:read("*a")
      maxValue = maxValue:match("(%d+)") or ""
      fd:close()
    end
    return tostring(maxValue)
  end,
  Active = function(mapping)
    return getConnTrackData("ASSURED")
  end,
  HalfOpen = function(mapping)
    return getConnTrackData("UNREPLIED")
  end,
  Multicast = function(mapping)
    return get_shell_cmd_output2("i=-1; cat " .. igmp_cache_file .." | while read LINE; do t=$(echo $LINE | awk '{print $4}'); [ \"$t\" != \"0\" ] && i=$((i+1)); echo $i > " .. cmd_output_file .. "; done")
  end,
}

register(InternetGatewayDevice_X_000E50_Connection_Stats_)


local InternetGatewayDevice_X_000E50_Connection_Stats_Protocol = {
  objectType = {
    name = "InternetGatewayDevice.X_000E50_Connection.Stats.Protocol.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      TCP = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      UDP = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      ICMP = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      Other = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
    }
  }
}

InternetGatewayDevice_X_000E50_Connection_Stats_Protocol.get = {
  TCP= function(mapping)
    return getConnTrackData("tcp")
  end,
  UDP = function(mapping)
    return getConnTrackData("udp")
  end,
  ICMP = function(mapping)
    return getConnTrackData("icmp")
  end,
  Other = function(mapping)
    local count = 0
    local data = readConnTrack()
    for line in data:gmatch("[^\n]+") do
      if not line:match("tcp") and not line:match("udp") and not line:match("icmp") then
        count = count + 1
      end
    end
    return tostring(count)
  end,
}

register(InternetGatewayDevice_X_000E50_Connection_Stats_Protocol)



local InternetGatewayDevice_X_000E50_Connection_Stats_TCP = {
  objectType = {
    name = "InternetGatewayDevice.X_000E50_Connection.Stats.TCP.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      TCPOpen = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      TCPEstablished = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      TCPClosing = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
    }
  }
}

InternetGatewayDevice_X_000E50_Connection_Stats_TCP.get = {
  TCPOpen= function(mapping)
    return getConnTrackData("tcp")
  end,
  TCPEstablished= function(mapping)
    local count = 0
    local data = readConnTrack()
    for line in data:gmatch("[^\n]+") do
      if line:match("tcp") and line:match("ESTABLISHED") then
        count = count + 1
      end
    end
    return tostring(count)
  end,
  TCPClosing= function(mapping)
    local count = 0
    local data = readConnTrack()
    for line in data:gmatch("[^\n]+") do
      if line:match("tcp") and line:match("TIME_WAIT") then
        count = count + 1
      end
    end
    return tostring(count)
  end,
}

register(InternetGatewayDevice_X_000E50_Connection_Stats_TCP)

