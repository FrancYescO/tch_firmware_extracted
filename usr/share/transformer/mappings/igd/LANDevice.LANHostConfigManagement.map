-- Automatically generated from InternetGatewayDevice:1.3
-- using generator version 2.1
local InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_ = {
  objectType = {
    name = "InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      MACAddress = {
        access = "readOnly",
        type = "string",
        max = "17",
      },
      DHCPServerConfigurable = {
        access = "readOnly",
        type = "boolean",
      },
      DHCPServerEnable = {
        access = "readWrite",
        type = "boolean",
      },
      DHCPRelay = {
        access = "readOnly",
        status = "deprecated",
        type = "boolean",
      },
      MinAddress = {
        access = "readWrite",
        type = "string",
      },
      MaxAddress = {
        access = "readWrite",
        type = "string",
      },
      ReservedAddresses = {
        access = "readOnly",
        list = true,
        max = "256",
        type = "string",
      },
      SubnetMask = {
        access = "readWrite",
        type = "string",
      },
      DNSServers = {
        access = "readWrite",
        list = true,
        maxItems = "3",
        max = "64",
        type = "string",
      },
      DomainName = {
        access = "readWrite",
        type = "string",
        max = "64",
      },
      IPRouters = {
        access = "readWrite",
        list = true,
        max = "64",
        type = "string",
      },
      DHCPLeaseTime = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
          },
        },
      },
      UseAllocatedWAN = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Normal",
          "UseAllocatedSubnet",
          "Passthrough",
        },
      },
      AssociatedConnection = {
        access = "readOnly",
        type = "string",
        max = "256",
      },
      PassthroughLease = {
        access = "readOnly",
        type = "unsignedInt",
      },
      PassthroughMACAddress = {
        access = "readOnly",
        type = "string",
      },
      AllowedMACAddresses = {
        access = "readWrite",
        list = true,
        max = "512",
        type = "string",
      },
      X_000E50_IPv6Enable = {
        access = "readWrite",
        type = "boolean",
      },
      X_0876FF_DNSProxyEnabled = {
        access = "readOnly",
        type = "boolean",
        description = "Enables or Disables DNSPROXY",
      },
      X_0876FF_VIPEnable = {
        access = "readWrite",
        type = "boolean",
        description = "Enable or disable VIP (Block of Static IP Addresses) in the CPE",
      },
      X_000E50_DNSProxyEnabled = {
        access = "readOnly",
        type = "boolean",
        description = "Enables or Disables DNSPROXY",
      },
      X_000E50_VIPEnable = {
        access = "readWrite",
        type = "boolean",
        description = "Enable or disable VIP (Block of Static IP Addresses) in the CPE",
      },
      -- IPInterfaceNumberOfEntries
      -- automatically created when InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.IPInterface.{i}. is loaded
    }
  }
}

local ipairs, mapper, commitapply = ipairs, mapper, commitapply
local math, register, string = math, register, string
local format, tonumber = string.format, tonumber
local uci_helper = mapper("ucihelper")
local bit = require("bit")
local min = require("math").min
local nwCommon = mapper("nwcommon")
local dhcp = require("transformer.shared.dhcp")
local network = require("transformer.shared.common.network")
local wifi_binding = {config = "wireless", sectionname = "wifi-iface"}
local inet = require("tch.inet")
local syspath = "/sys/class/net/"
local networkBinding = { config = "network", option = "ipaddr" }
local dhcpBinding = { config = "dhcp" }
local getFromUci = uci_helper.get_from_uci
local setOnUci = uci_helper.set_on_uci
local transactions = {}

local conditionalsection = {
   ["mac"] = true,
   ["vendorclass"] = true,
   ["userclass"] = true,
   ["host_client_id"] = true,
}
local cpoolpattern = "^tag:conditional"

local function getDNSMASQConfig(param)
    local result
    result = uci_helper.get_from_uci({
        extended = 1, config = "dhcp", sectionname = "@dnsmasq[0]", option = param
    })
    return result
end

--To read the DNSPROXYEnable param from the uci.
-- If enabled, gateway must return it's LAN IP Address as the primary DNS Server.
-- If set to False, Gateway LAN IP Address must not be automatically returned as the DNS Server,but the DNS Servers learnt/configured on the WAN must be returned to the LAN clients.
local function getDnsProxyEnable(mapping, param, key)
  networkBinding.sectionname = key
  local gwIP = getFromUci(networkBinding)
  dhcpBinding.option = "dhcp_option"
  dhcpBinding.sectionname = "lan"
  local dhcpOptions = getFromUci(dhcpBinding)
  if dhcpOptions == "" then
    return "1"
  end
  local dnsServer = ""
  for _, v in ipairs(dhcpOptions) do
    if v:find("^6,") == 1 then
      if dnsServer == "" then
        dnsServer = v:sub(3)
      else
        dnsServer = dnsServer .. "," .. v:sub(3)
      end
    end
  end
  if (dnsServer == "")  or (dnsServer ~= "" and dnsServer:match(gwIP)) then
    return "1"
  end
  return "0"
end

-- To set the value on uci config
-- @function setUciParam
-- @param #string option the option to be set in uci
-- @param #string value the value to be set in uci config
local function setUciValue(binding, option, value)
  binding.sectionname = "lan"
  binding.option = option
  setOnUci(binding, value, commitapply)
  transactions[binding.config] = true
end

--- get first non conditional pool on intf key
local function getDHCPConfigSectionForIntf(key)
    local result
    local binding = {config="dhcp",sectionname="dhcp"}
    uci_helper.foreach_on_uci(binding, function(s)
    -- iterate over the dhcp pools and take the first one that has the interface name (key) as the interface
    -- TODO once we add configuration of specific dhcp pools for given options, return the "generic" pool
    -- TODO (the one with no selection)
        if s['interface'] == key then
            local networkid = s['networkid']
            if networkid == nil or string.match(networkid,cpoolpattern) == nil then
                result = s['.name']
                return false
            end
        end
    end)
    return result
end

local function getDHCPConfigForSection(section, param, default)
    local result = uci_helper.get_from_uci({
        config = "dhcp", sectionname = section, option = param, default = default,
    })
    return result
end

-- For a given network name (lan for instance), return the wifi-iface sections associated with it in UCI
local function getIfacesForNetwork(network)
    local binding={config = "wireless", sectionname = "wifi-iface"}
    local ifaces = {}
    uci_helper.foreach_on_uci(binding, function(s)
    if s["network"] == network then
        ifaces[#ifaces + 1] = s[".name"]
    end
    end)
    return ifaces
end

local function getDHCPConfig(key, param, default)
    local section = getDHCPConfigSectionForIntf(key)
    if section == nil then
        return nil, "DHCP section not found"
    end
    return getDHCPConfigForSection(section, param, default)
end

local function setDHCPConfigForSection(section, param, value)
    uci_helper.set_on_uci({
        config = "dhcp", sectionname = section, option = param
    }, value, commitapply)
end

local function setDHCPConfig(key, param, value)
    local section = getDHCPConfigSectionForIntf(key)
    if section == nil then
        return nil, "DHCP section not found"
    end
    setDHCPConfigForSection(section, param, value)
end

local function getMACAddress(key)
    local macAddr
    local ifnames = uci_helper.get_from_uci({
            config = "network", sectionname = key, option = "ifname"
            })
    for ifname in string.gmatch(ifnames, "%S+") do -- split space separated
    --ifnames maybe in the format eth0 eth1 eh2 eth3
    --or in the format ptm0
    --or in the format vlan100 vlan200
        local file = syspath .. ifname .. "/address"
        macAddr = network.getFirstLine(file)
        if macAddr == "" then
            -- consider that getting the ifname from the vlan
            local ifnameFromVlan = uci_helper.get_from_uci({
            config = "network", sectionname = ifname, option = "ifname"
            })
            if ifnameFromVlan ~="" then
                file  = syspath .. ifnameFromVlan .. "/address"
                macAddr = network.getFirstLine(file)
            end
        end
        if macAddr ~= "" then
            break
        end
    end
    return macAddr or "00:00:00:00:00:00"
end

local function getDHCPdata(key)
    local network_cfg = uci_helper.getall_from_uci({
        config = "network", sectionname = key
    })
    local baseip = nwCommon.ipv4ToNum(network_cfg.ipaddr or '') or 0
    local netmask = nwCommon.ipv4ToNum(network_cfg.netmask or '') or 0
    local section = getDHCPConfigSectionForIntf(key)
    local dhcp_cfg
    if section then
        dhcp_cfg = uci_helper.getall_from_uci({
            config = "dhcp", sectionname = section
        })
    else
        dhcp_cfg = {}
    end
    local start = tonumber(dhcp_cfg[ "start"] or "100")
    local numips = tonumber(dhcp_cfg["limit"] or "150")
    local network = bit.band(baseip, netmask)
    local ipmin = network + 1
    local ipmax = bit.bor(network, bit.bnot(netmask)) - 1
    local ipstart = bit.bor(network, bit.band(start, bit.bnot(netmask)))
    local ipend = min(ipstart + numips - 1, network + 254)
    return {
        name = dhcp_cfg[".name"] or "",
        gw = baseip,
        network = network,
        ipmin = ipmin,
        ipmax = ipmax,
        ipstart = ipstart,
        ipend = ipend,
        start = start,
        numips = numips,
        leasetime = dhcp_cfg["leasetime"] or '-1',
        intf = dhcp_cfg["interface"],
        dhcpv4 = dhcp_cfg["dhcpv4"],
    }
end

-- To retrieve value from uci
-- @function getVIPEnable
-- @param #table dhcpBinding the binding table
-- @param #string sectionname the sectionname to retrieve from config
-- @param #string option the option to retrieve from config
-- If block of static IP is selected,update the X_0876FF_VIPEnable variable as enabled.
-- If enabled,need to send the Gateway IP address as DNS Server.
-- If VIPEnable is disabled,should adapt UCI configuration to ignore that section.
local function getVIPEnable(mapping, param, key)
    dhcpBinding.sectionname = "lan"
    dhcpBinding.option = "start"
    local dhcpStart = getFromUci(dhcpBinding)
    dhcpBinding.option = "limit"
    local dhcpLimit = getFromUci(dhcpBinding)
    return (dhcpStart == "" and dhcpLimit == "") and "1" or "0"
end

--function to setVIPEnable
--If VIP is enabled, dhcp option start and limit options should be ignored or set to empty. So that it will take default values from gateway.
--If VIP is disabled, dhcp options start and limit should be considered and set back to default values.
local function setVIPEnable(mapping, param, value, key)
    local data = getDHCPdata(key)
    if  value == "1" then
      setUciValue(dhcpBinding, "tch_map_start_backup", data.start)
      setUciValue(dhcpBinding, "tch_map_limit_backup", data.numips)
      setUciValue(dhcpBinding, "start", "")
      setUciValue(dhcpBinding, "limit", "")
    elseif value == "0" then
      local dhcpConfig = uci_helper.getall_from_uci(dhcpBinding)
      if(dhcpConfig["tch_map_start_backup"] and dhcpConfig["tch_map_limit_backup"]) then
        setUciValue(dhcpBinding, "start",dhcpConfig["tch_map_start_backup"])
        setUciValue(dhcpBinding, "limit", dhcpConfig["tch_map_limit_backup"])
        setUciValue(dhcpBinding, "tch_map_start_backup", "")
        setUciValue(dhcpBinding, "tch_map_limit_backup", "")
      end
        return false
    end
end

local InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_get = {
    DHCPServerConfigurable = "1",
    DHCPServerEnable = function(mapping, param, key)
        local intf = getDHCPConfig(key, "interface")
        local dhcpv4 = getDHCPConfig(key, "dhcpv4", "server")
        -- consider that the DHCP server is disabled if there is no IP pool defined for the interface or if the
        -- dhcpv4 parameter is set to disabled
        if intf == "" or dhcpv4 == "disabled" then
            return "0"
        else
            return "1"
        end
    end,
    DHCPRelay = "0", -- We don't want to be a DHCP relay
    MACAddress = function(mapping, param, key)
        return getMACAddress(key)
    end,

    MinAddress = function(mapping, param, key)
        local data = getDHCPdata(key)
        return nwCommon.numToIPv4(data.ipstart)
    end,
    MaxAddress = function(mapping, param, key)
        local data = getDHCPdata(key)
        return nwCommon.numToIPv4(data.ipend)
    end,
    ReservedAddresses = function(mapping, param, key)
        return ""
    end,
    SubnetMask = function(mapping, param, key)
        -- get that for the given interface from state in UCI
        local result = uci_helper.get_from_uci({
            config = "network", sectionname = key, option = "netmask"
        })
        return result or ""
    end,
    DNSServers = function(mapping, param, key)
        -- get gw address on given interface from network in UCI
        local ip_result = uci_helper.get_from_uci({
            config = "network", sectionname = key, option = "ipaddr"
        })
        local section = getDHCPConfigSectionForIntf(key) or key
        local result = uci_helper.get_from_uci({
            config = "dhcp", sectionname = section, option = "dhcp_option"
        })
        local dnsServer = ""
        if result == "" then
          return ip_result or ""
        end
        for i,v in ipairs(result) do
          if v:find("^6,") == 1 then
            if dnsServer == "" then
              dnsServer = v:sub(3)
            else
              dnsServer = dnsServer .. "," .. v:sub(3)
            end
          end
        end
        if dnsServer == "" then
          return ip_result
        else
          return dnsServer
        end
    end,
    DomainName = function(mapping, param, key)
        return getDNSMASQConfig("domain") or ""
    end,
    IPRouters = function(mapping, param, key)
        -- get route address from specified interface in dhcp config,
        -- if route address is not present in dhcp config then get from specified interface in network config
        local section = getDHCPConfigSectionForIntf(key) or key
        local dhcpList = uci_helper.get_from_uci({ config = "dhcp", sectionname = section, option = "dhcp_option" })
        local routeIP = dhcpList ~= "" and dhcp.getRouteIPAddress(dhcpList)
        if routeIP then
            return routeIP
        end
        local networkBinding = { config = "network", sectionname = key, option = "defaultroute" }
        local defaultRoute = uci_helper.get_from_uci(networkBinding)
        if defaultRoute == "1" or defaultRoute == "" then
            networkBinding.option = "ipaddr"
            return uci_helper.get_from_uci(networkBinding)
        end
        return ""
    end,
    DHCPLeaseTime = function(mapping, param, key)
        return dhcp.convertTimeStringToSeconds(getDHCPConfig(key, "leasetime"))
    end,
    UseAllocatedWAN = "Normal",
    AssociatedConnection = function(mapping, param, key)
        return "" -- TODO need to discuss with Dirk since this raises the exact problem he mentioned
    end,
    PassthroughLease = "600",
    PassthroughMACAddress = "",
    --only support getting from WLAN interface
    AllowedMACAddresses = function(mapping, param, key)
        local macList = {}
        local result
        local ifaces = getIfacesForNetwork(key)
        for _,iface in ipairs(ifaces) do
            wifi_binding.sectionname = network.getAPForIface(iface)
            wifi_binding.option = "acl_accept_list"
            result = uci_helper.get_from_uci(wifi_binding)
            if result ~= "" then
                for _,v in ipairs(result) do
                    local isMACExist = "0"
                    for i =1,#macList do
                        if macList[i] == v then
                            isMACExist = "1"
                            break
                        end
                    end
                    if isMACExist == "0" then
                        macList[#macList+1] = v
                    end
                 end
            end
        end
        return  table.concat(macList, ',') or ""
    end,
    X_000E50_IPv6Enable = function(mapping, param, key)
      local ipv6Enable
      dhcpBinding.sectionname = "dhcp"
      uci_helper.foreach_on_uci(dhcpBinding, function(s)
        if s.interface == key then
          ipv6Enable = s.dhcpv6 == "server" and s.ra == "server" and "1" or "0"
          return false
        end
      end)
      return ipv6Enable and ipv6Enable or "0"
    end,
    X_0876FF_DNSProxyEnabled = getDnsProxyEnable,
    X_0876FF_VIPEnable = getVIPEnable,
    X_000E50_DNSProxyEnabled = getDnsProxyEnable,
    X_000E50_VIPEnable = getVIPEnable,
}


local function InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_getall(mapping, key)
    local network_cfg = uci_helper.getall_from_uci({
        config = "network", sectionname = key
    })
    local dhcp_data = getDHCPdata(key)
    -- consider that the DHCP server is disabled if there is no IP pool defined for the interface or if the
    -- dhcpv4 parameter is set to disabled
    local DHCPServerEnable
    if not dhcp_data['intf'] or dhcp_data['dhcpv4'] == "disabled" then
       DHCPServerEnable = '0'
    else
       DHCPServerEnable = '1'
    end
    local section = getDHCPConfigSectionForIntf(key) or key
    local dhcpList = uci_helper.get_from_uci({
         config = "dhcp", sectionname = section, option = "dhcp_option"
    })
    local dnsServer = ""
    local routeIP
    if dhcpList ~= "" then
      for _,v in ipairs(dhcpList) do
        if v:find("^6,") == 1 then
          if dnsServer == "" then
            dnsServer = v:sub(3)
          else
            dnsServer = dnsServer .. "," .. v:sub(3)
          end
        end
      end
      routeIP = dhcp.getRouteIPAddress(dhcpList)
    end
    if dnsServer == "" then
      dnsServer = network_cfg["ipaddr"]
    end
    local macAddressList
    local macList = {}
    local result
    local ifaces = getIfacesForNetwork(key)
    for _,iface in ipairs(ifaces) do
        wifi_binding.sectionname = network.getAPForIface(iface)
        wifi_binding.option = "acl_accept_list"
        result = uci_helper.get_from_uci(wifi_binding)
        if result ~= "" then
            for _,v in ipairs(result) do
                local isMACExist = "0"
                for i =1,#macList do
                    if macList[i] == v then
                        isMACExist = "1"
                        break
                    end
                end
                if isMACExist == "0" then
                    macList[#macList+1] = v
                end
            end
        end
   end
    macAddressList = table.concat(macList, ',') or ""

    return {
        DHCPServerConfigurable = "1",
        DHCPRelay = "0", -- We don't want to be a DHCP relay
        MinAddress = nwCommon.numToIPv4(dhcp_data.ipstart),
        MaxAddress = nwCommon.numToIPv4(dhcp_data.ipend),
        MACAddress = getMACAddress(key),
        ReservedAddresses = "",
        SubnetMask = network_cfg["netmask"] or '',
        DNSServers = dnsServer or '',
        IPRouters = routeIP or (network_cfg["defaultroute"] == "1" or not network_cfg["defaultroute"]) and network_cfg["ipaddr"] or "",
        DHCPLeaseTime = dhcp.convertTimeStringToSeconds(getDHCPConfig(key, "leasetime")),
        UseAllocatedWAN = "Normal",
        AssociatedConnection = "",
        PassthroughLease = "600",
        PassthroughMACAddress = "",
        AllowedMACAddresses = macAddressList or "",
        DHCPServerEnable = DHCPServerEnable,

    }
end

local InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_set = {
    DHCPServerEnable = function(mapping, param, value, key)
        if value == "1" then
            value = "server"
        else
            value = "disabled"
        end
        setDHCPConfig(key, "dhcpv4", value)
    end,
    MinAddress = function(mapping, param, value, key)
        local res, err = network.setDHCPMinAddress(key, value, commitapply)
        if res then
            transactions["dhcp"] = true
            return true
        end
        return nil, err
    end,
    MaxAddress = function(mapping, param, value, key)
        local res, err = network.setDHCPMaxAddress(key, value, commitapply)
        if res then
            transactions["dhcp"] = true
            return true
        end
        return nil, err
    end,
    SubnetMask = function(mapping, param, value, key)
        uci_helper.set_on_uci({
            config = "network", sectionname = key, option = "netmask"
        }, value, commitapply)
    end,
    DNSServers = function(mapping, param, value, key)
        for word in string.gmatch(value, '([^,]+)') do
          if not inet.isValidIPv4(word) then
            return nil, "Invalid IPV4 Address"
          end
        end
        local section = getDHCPConfigSectionForIntf(key) or key
        local binding = { config = "dhcp", sectionname = section, option = "dhcp_option"}
        local result = uci_helper.get_from_uci(binding)
        local dnsServers = {}
        if result ~= "" then
          for _,v in ipairs(result) do
            if not (v:find("^6,") == 1) then
              dnsServers[#dnsServers + 1] = v
            end
          end
        end
        dnsServers[#dnsServers + 1] = "6," .. value
        uci_helper.set_on_uci(binding, dnsServers, commitapply)
    end,
    DomainName = function(mapping, param, value, key)
        uci_helper.set_on_uci({
            extended = 1, config = "dhcp", sectionname = "@dnsmasq[0]", option = "domain"
        }, value, commitapply)
    end,
    DHCPLeaseTime = function(mapping, param, value, key)
      if value == '-1' then
        value = "infinite" -- set infinite lease time.
      elseif tonumber(value) < 120 then
        return nil, "minimum lease time must be 120 seconds"
      elseif tonumber(value) > 1814400 then
        return nil, "maximum lease time must be 1814400 seconds"
      end
      setDHCPConfig(key, "leasetime", value)
    end,
    X_000E50_IPv6Enable = function(mapping, param, value, key)
      local result = value == "1" and "server" or "disabled"
      dhcpBinding.sectionname = "dhcp"
      uci_helper.foreach_on_uci(dhcpBinding, function(s)
        if s.interface == key then
          dhcpBinding.sectionname = s[".name"]
          dhcpBinding.option = "dhcpv6"
          setOnUci(dhcpBinding, result, commitapply)
          dhcpBinding.option = "ra"
          setOnUci(dhcpBinding, result, commitapply)
          transactions[dhcpBinding.config] = true
          return false
        end
      end)
    end,
    IPRouters = function(mapping, param, value, key)
	local section = getDHCPConfigSectionForIntf(key) or key
        if inet.isValidIPv4(value) then
            dhcp.setDefaultRoute(value, section)
        else
            return nil, format("%s is not a valid IPv4 Address",value)
        end
    end,
    X_0876FF_VIPEnable = setVIPEnable,
    X_000E50_VIPEnable = setVIPEnable,
    --only support setting to WLAN interface
    AllowedMACAddresses = function(mapping, param, value, key)
        local macList = {}
        local ifaces = getIfacesForNetwork(key)
        for mac in string.gmatch(value, '([^,]+)') do
            if nwCommon.isMAC(mac) then
                table.insert(macList,mac)
            else
                 return nil, "Invalid MAC address; cannot set"
            end
        end
        for _,iface in ipairs(ifaces) do
            wifi_binding.sectionname = network.getAPForIface(iface)
            wifi_binding.option = "acl_accept_list"
            uci_helper.set_on_uci(wifi_binding, macList, commitapply)
        end
    end
}

local function commit()
    uci_helper.commit({config = "wireless"})
    uci_helper.commit({config = "dhcp"})
    uci_helper.commit({config = "network"})
end

local function revert()
    uci_helper.commit({config = "wireless"})
    uci_helper.revert({config = "network"})
    uci_helper.revert({config = "dhcp"})
end

local logger = require("transformer.logger")

local function translate_cb(mapping, action, config, sectiontype, sectionname, option)
    logger:debug("translate_cb called")
    if option == "dhcpv4" then
        return { { key = sectionname, paramname = "DHCPServerEnable" } }
    elseif option == "leasetime" then
        return { { key = sectionname, paramname = "DHCPLeaseTime" } }
    end
end

InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.add_watchers = function(mapping)
  logger:debug("add_watchers called")
  local uci_evsrc = eventsource("uci")
  uci_evsrc.watch(mapping, { set = translate_cb }, "dhcp", "dhcp", nil, "dhcpv4")
  uci_evsrc.watch(mapping, { set = translate_cb }, "dhcp", "dhcp", nil, "leasetime")
end

InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.get = InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_get
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.getall= InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_getall
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.set = InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_set
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.commit = commit
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.revert = revert

register(InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_)

local InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_ = {
  objectType = {
    name = "InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.DHCPConditionalServingPool.{i}.",
    access = "readWrite",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      PoolOrder = {
        access = "readOnly",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
      SourceInterface = {
        --access = "readWrite",
        access = "readOnly",
        type = "string",
        max = "1024",
        default = "",
      },
      VendorClassID = {
        access = "readWrite",
        type = "string",
        max = "256",
        default = "",
      },
      ClientID = {
        access = "readWrite",
        type = "string",
        max = "256",
        default = "",
      },
      UserClassID = {
        access = "readWrite",
        type = "string",
        max = "256",
        default = "",
      },
      Chaddr = {
        access = "readWrite",
        type = "string",
        default = "",
      },
      ChaddrMask = {
        --access = "readWrite",
        access = "readOnly",
        type = "string",
        default = "",
      },
      LocallyServed = {
        --access = "readWrite",
        access = "readOnly",
        type = "boolean",
        default = "true",
      },
      MinAddress = {
        access = "readWrite",
        type = "string",
      },
      MaxAddress = {
        access = "readWrite",
        type = "string",
      },
      ReservedAddresses = {
        access = "readOnly",
        list = true,
        max = "512",
        type = "string",
      },
      SubnetMask = {
        access = "readWrite",
        type = "string",
      },
      DNSServers = {
        access = "readWrite",
        list = true,
        max = "64",
        type = "string",
      },
      DomainName = {
        access = "readWrite",
        type = "string",
        max = "64",
      },
      IPRouters = {
        --access = "readWrite",
        access = "readOnly",
        list = true,
        max = "64",
        type = "string",
      },
      DHCPLeaseTime = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
          },
        },
      },
      DHCPServerIPAddress = {
        --access = "readWrite",
        access = "readOnly",
        type = "string",
      },
    }
  }
}

local function getConditionalDHCPdata(parentkey, key)
    local network_cfg = uci_helper.getall_from_uci({config = "network", sectionname = parentkey})
    local baseip = nwCommon.ipv4ToNum(network_cfg.ipaddr or '') or 0
    local netmask = nwCommon.ipv4ToNum(network_cfg.netmask or '') or 0
    local dhcp_cfg
    if key then
        dhcp_cfg = uci_helper.getall_from_uci({config = "dhcp", sectionname = key})
    else
        dhcp_cfg = {}
    end
    local network = bit.band(baseip, netmask)
    local ipmin = network + 1
    local ipmax = bit.bor(network, bit.bnot(netmask)) - 1
    local start = tonumber(dhcp_cfg[ "start"] or ipmin)
    local numips = tonumber(dhcp_cfg["limit"] or 1)
    local ipstart = bit.bor(network, bit.band(start, bit.bnot(netmask)))
    local ipend = min(ipstart + numips - 1, network + 254)

    return {
        gw = baseip,
        network = network,
        ipmin = ipmin,
        ipmax = ipmax,
        ipstart = ipstart,
        ipend = ipend,
        start = start,
        numips = numips,
        leasetime = dhcp_cfg["leasetime"] or '-1',
        intf = dhcp_cfg["interface"],
        dhcpv4 = dhcp_cfg["dhcpv4"],
    }
end

local networkids = {}
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.entries = function(mapping, parentkey)
    local dhcpEntries = {}
    local binding = {config = "dhcp", sectionname = "dhcp"}
    uci_helper.foreach_on_uci(binding, function(s)
        local networkid = s.networkid
        if s.interface == parentkey and networkid then
            local tag = networkid:match("^tag:(.+)")
            if tag then
                dhcpEntries[#dhcpEntries + 1] = s['.name']
                networkids[s['.name']] = tag
            end
        end
    end)
    return dhcpEntries
end

local binding = {config = "dhcp", sectionname ="", option = ""}
local getconditional = {
    Enable = function(mapping, param, key)
        binding.option = "enable"
        binding.sectionname = key
        binding.default = "0"
        return uci_helper.get_from_uci(binding)
    end,
    PoolOrder = "0",
    SourceInterface = "",
    VendorClassID = function(mapping, param, key)
        binding.sectionname = nil
        local vendorclassid = ""
        local cur_networkid = "set:" .. networkids[key]
        uci_helper.foreach_on_uci(binding, function(s)
            if s['networkid'] == cur_networkid and s['.type'] == "vendorclass" then
                vendorclassid = s['vendorclass']
                return false
            end
        end)
        return vendorclassid
    end,
    ClientID = function(mapping, param, key)
        binding.sectionname = nil
        local cur_networkid = "set:" .. networkids[key]
        local hostclassid = ""
        uci_helper.foreach_on_uci(binding, function(s)
            if s['networkid'] == cur_networkid and s['.type'] == "host_client_id" then
                hostclassid = s['clientid']
                return false
            end
        end)
        return hostclassid
    end,
    UserClassID = function(mapping, param, key)
        binding.sectionname = nil
        local userclassid = ""
        local cur_networkid = "set:" .. networkids[key]
        uci_helper.foreach_on_uci(binding, function(s)
            if s['networkid'] == cur_networkid and s['.type'] == "userclass" then
                userclassid = s['userclass']
                return false
            end
        end)
        return userclassid
    end,
    Chaddr = function(mapping, param, key)
        binding.sectionname = nil
        local chaddr =""
        local cur_networkid = "set:" .. networkids[key]
        uci_helper.foreach_on_uci(binding, function(s)
            if s['networkid'] == cur_networkid and s['.type'] == 'mac' then
                chaddr = s['mac']
                return false
            end
        end)
        return chaddr
    end,
    ChaddrMask = "",
    LocallyServed = "1",
    MinAddress = function(mapping, param, key, parentkey)
        local data = getConditionalDHCPdata(parentkey,key)
        return nwCommon.numToIPv4(data.ipstart)
    end,
    MaxAddress = function(mapping, param, key, parentkey)
        local data = getConditionalDHCPdata(parentkey,key)
        return nwCommon.numToIPv4(data.ipend)
    end,
    ReservedAddresses = "",
    SubnetMask = function(mapping, param, key,parentkey)
         -- get that for the given interface from state in UCI
        local result = uci_helper.get_from_uci({
            config = "network", sectionname = parentkey, option = "netmask"
        })
        return result or ""
    end,
    DNSServers = function(mapping, param, key,parentkey)
        -- get gw address on given interface from network in UCI
        local ip_result = uci_helper.get_from_uci({
            config = "network", sectionname = parentkey, option = "ipaddr"
        })
        local result = uci_helper.get_from_uci({
            config = "dhcp", sectionname = parentkey, option = "dhcp_option"
        })
        local dnsServer = ""
        if result == "" then
          return ip_result or ""
        end
        for i,v in ipairs(result) do
          if v:find("^6,") == 1 then
            if dnsServer == "" then
              dnsServer = v:sub(3)
            else
              dnsServer = dnsServer .. "," .. v:sub(3)
            end
          end
        end
        if dnsServer == "" then
          return ip_result
        else
          return dnsServer
        end
    end,
    DomainName = function(mapping, param, key)
        return getDNSMASQConfig("domain") or ""
    end,
    IPRouters = function(mapping, param, key,parentkey)
         -- get gw address on given interface from network in UCI
         local result = uci_helper.get_from_uci({
             config = "network", sectionname = parentkey, option = "ipaddr"
         })
         return result or ""
    end,
    DHCPLeaseTime = function(mapping, param, key)
        binding.sectionname = key
        binding.option = 'leasetime'
        return dhcp.convertTimeStringToSeconds(uci_helper.get_from_uci(binding))
    end,
    DHCPServerIPAddress = "",
}

local setconditional = {
    Enable = function(mapping, param, value, key)
        uci_helper.set_on_uci({config = "dhcp", sectionname = key, option = "enable"}, value, commitapply)
    end,
    VendorClassID = function(mapping, param, value, key)
        binding.sectionname = nil
        local cur_networkid = "set:" .. networkids[key]
        local found = 0
        uci_helper.foreach_on_uci(binding, function(s)
             if s['networkid'] == cur_networkid and s['.type'] == "vendorclass" then
                 uci_helper.set_on_uci({config = "dhcp", sectionname = s['.name'], option = "vendorclass"}, value, commitapply)
                 found = 1
                 return false
             end
        end)
        if found == 0 then
            local name = uci_helper.add_on_uci({config = "dhcp",sectionname = "vendorclass", option = "",default = ""},commitapply)
            if name then
                uci_helper.set_on_uci({config = "dhcp", sectionname = name, option = "vendorclass"}, value, commitapply)
                uci_helper.set_on_uci({config = "dhcp", sectionname = name, option = "networkid"}, cur_networkid, commitapply)
            end
        end
    end,
    ClientID = function(mapping, param, value, key)
        binding.sectionname = nil
        local cur_networkid = "set:" .. networkids[key]
        local found = 0
        uci_helper.foreach_on_uci(binding, function(s)
          if s['networkid'] == cur_networkid and s['.type'] == "host_client_id" then
              uci_helper.set_on_uci({config = "dhcp", sectionname = s['.name'], option = "clientid"}, value, commitapply)
              found = 1
              return false
          end
        end)
        if found == 0 then
            local name = uci_helper.add_on_uci({config = "dhcp",sectionname = "host_client_id", option = "",default = ""},commitapply)
            if name then
                uci_helper.set_on_uci({config = "dhcp", sectionname = name, option = "clientid"}, value, commitapply)
                uci_helper.set_on_uci({config = "dhcp", sectionname = name, option = "networkid"}, cur_networkid, commitapply)
            end
        end
    end,
    UserClassID = function(mapping, param, value, key)
        binding.sectionname = nil
        local cur_networkid = "set:" .. networkids[key]
        local found = 0
        uci_helper.foreach_on_uci(binding, function(s)
            if s['networkid'] == cur_networkid and s['.type'] == "userclass" then
                uci_helper.set_on_uci({config = "dhcp", sectionname = s['.name'], option = "userclass"}, value, commitapply)
                found = 1
                return false
            end
        end)
        if found == 0 then
            local name = uci_helper.add_on_uci({config = "dhcp",sectionname = "userclass", option = "",default = ""},commitapply)
            if name then
                uci_helper.set_on_uci({config = "dhcp", sectionname = name, option = "userclass"}, value, commitapply)
                uci_helper.set_on_uci({config = "dhcp", sectionname = name, option = "networkid"}, cur_networkid, commitapply)
            end
        end
    end,
    Chaddr = function(mapping, param, value, key)
        binding.sectionname = nil
        local cur_networkid = "set:" .. networkids[key]
        local found = 0
        uci_helper.foreach_on_uci(binding, function(s)
            if s['networkid'] == cur_networkid and s['.type'] == 'mac' then
                uci_helper.set_on_uci({config = "dhcp", sectionname = s['.name'], option = "mac"}, value, commitapply)
                found = 1
                return false
            end
        end)
        if found == 0 then
            local name = uci_helper.add_on_uci({config = "dhcp",sectionname = "mac", option = "",default = ""},commitapply)
            if name then
                uci_helper.set_on_uci({config = "dhcp", sectionname = name, option = "mac"}, value, commitapply)
                uci_helper.set_on_uci({config = "dhcp", sectionname = name, option = "networkid"}, cur_networkid, commitapply)
            end
        end
    end,
    MinAddress = function(mapping, param, value, key, parentkey)
        local newstart = nwCommon.ipv4ToNum(value)
        if newstart == nil then
            return nil, "Please input correct ip address"
        end
        local data = getConditionalDHCPdata(parentkey, key)
        if newstart < data.ipmin or newstart >= data.ipend then
            return nil, "Invalid start address"
        end
        local result ,errmsg = overlapCheck(data.network, key, newstart - data.network, data.ipend - newstart + 1)
        if result ~= nil then
            uci_helper.set_on_uci({config = "dhcp", sectionname = key, option = "start"}, newstart - data.network, commitapply)
            uci_helper.set_on_uci({config = "dhcp", sectionname = key, option = "limit"}, data.ipend - newstart + 1, commitapply)
        else
            return result, errmsg
        end
    end,
    MaxAddress = function(mapping, param, value, key, parentkey)
        local newend = nwCommon.ipv4ToNum(value)
        if newend == nil then
            return nil, "Please input correct ip address"
        end
        local data = getConditionalDHCPdata(parentkey, key)
        if newend < data.ipstart or newend > data.ipmax + 1 then
            return nil, "Invalid end address"
        end
        local newvalue = newend - data.ipstart + 1
        local result ,errmsg = overlapCheck(data.network, key, data.ipstart - data.network, newvalue)
        if result ~= nil then
            uci_helper.set_on_uci({config = "dhcp", sectionname = key, option = "limit"}, newvalue, commitapply)
        else
            return result , errmsg
        end
    end,
    SubnetMask = function(mapping, param, value, key, parentkey)
        uci_helper.set_on_uci({config = "network", sectionname = parentkey, option = "netmask"}, value, commitapply)
    end,
    DNSServers = function(mapping, param, value, key, parentkey)
        local binding = { config = "dhcp", sectionname = parentkey, option = "dhcp_option"}
        local result = uci_helper.get_from_uci(binding)
        local dnsIndex = 0
        local lastIndex = 0
        local dnsServers = {}
        if result ~= "" then
            for i,v in ipairs(result) do
                dnsServers[#dnsServers + 1] = v
                if v:find("^6,") == 1 then
                    dnsIndex = dnsIndex + 1
                    lastIndex = i
                end
            end
        end
        local dns = {}
        for word in string.gmatch(value, '([^,]+)') do
            dns[#dns + 1] = word
        end
        if #dns > 3 then
            return nil,"maximum three comma seperated values allowed"
        end
        if dnsIndex == 0 then
            dnsServers[#dnsServers + 1] = "6," .. value
            uci_helper.set_on_uci(binding, dnsServers, commitapply)
        else
            dnsServers[lastIndex] = "6," .. value
            uci_helper.set_on_uci(binding, dnsServers, commitapply)
        end
    end,
    DomainName = function(mapping, param, value, key)
        uci_helper.set_on_uci({extended = 1, config = "dhcp", sectionname = "@dnsmasq[0]", option = "domain"}, value, commitapply)
    end,
    DHCPLeaseTime = function(mapping, param, value, key)
      if value == '-1' then
        value = "infinite" -- set infinite lease time.
      end
      uci_helper.set_on_uci({config = "dhcp", sectionname = key, option = "leasetime"}, value, commitapply)
    end,
}

-- get available network id for the new created conditional pool
-- conditional pool network id should be in range of [1, ...]
local function getavailablelid()
    local binding = {config="dhcp",}
    local cid = 0
    uci_helper.foreach_on_uci(binding, function(s)
        local networkid = s['networkid']
        if s[".type"] == "dhcp" and networkid and string.match(networkid,cpoolpattern) ~= nil then
            local id = string.match(networkid,"^tag:conditional_(%d)")
            if id and cid < tonumber(id) then
              cid = tonumber(id)
            end
        end
    end)
    return cid + 1
end

local function addconditionalpool(mapping, parentkey)
    local sectionname = uci_helper.add_on_uci({config = "dhcp",sectionname = "dhcp", option = "",default = ""},commitapply)
    uci_helper.set_on_uci({config = "dhcp", sectionname = sectionname, option = "interface"}, parentkey, commitapply)
    local networkid = "tag:conditional_" .. getavailablelid()
    uci_helper.set_on_uci({config = "dhcp", sectionname = sectionname, option = "networkid"}, networkid, commitapply)
    return sectionname
end

InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.get = getconditional
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.set = setconditional
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.delete = function(mapping,key)
    local binding = {config="dhcp",}
    binding.sectionname = key
    binding.option = nil
    uci_helper.delete_on_uci(binding, commitapply)
    binding.sectionname = nil
    local cur_networkid = networkids[key]
    uci_helper.foreach_on_uci(binding, function(s)
        if s['networkid'] == ("set:" .. cur_networkid) and s['.type'] and conditionalsection[s['.type']] then
            local delbinding = {config = "dhcp", sectionname = s[".name"]}
            uci_helper.delete_on_uci(delbinding, commitapply)
        end
    end)
    return true
end

InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.add = addconditionalpool
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.commit = commit
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.revert = revert
register(InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_)

