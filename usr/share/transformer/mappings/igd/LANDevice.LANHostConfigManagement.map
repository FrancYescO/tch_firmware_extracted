-- Automatically generated from InternetGatewayDevice:1.3
-- using generator version 2.1
local InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_ = {
  objectType = {
    name = "InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      MACAddress = {
        access = "readOnly",
        type = "string",
        max = "17",
      },
      DHCPServerConfigurable = {
        access = "readOnly",
        type = "boolean",
      },
      DHCPServerEnable = {
        access = "readWrite",
        type = "boolean",
      },
      DHCPRelay = {
        access = "readOnly",
        status = "deprecated",
        type = "boolean",
      },
      MinAddress = {
        access = "readWrite",
        type = "string",
      },
      MaxAddress = {
        access = "readWrite",
        type = "string",
      },
      ReservedAddresses = {
        access = "readOnly",
        list = true,
        max = "256",
        type = "string",
      },
      SubnetMask = {
        access = "readWrite",
        type = "string",
      },
      DNSServers = {
        access = "readWrite",
        list = true,
        maxItems = "3",
        max = "64",
        type = "string",
      },
      DomainName = {
        access = "readWrite",
        type = "string",
        max = "64",
      },
      IPRouters = {
        access = "readWrite",
        list = true,
        max = "64",
        type = "string",
      },
      DHCPLeaseTime = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
          },
        },
      },
      UseAllocatedWAN = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Normal",
          "UseAllocatedSubnet",
          "Passthrough",
        },
      },
      AssociatedConnection = {
        access = "readOnly",
        type = "string",
        max = "256",
      },
      PassthroughLease = {
        access = "readOnly",
        type = "unsignedInt",
      },
      PassthroughMACAddress = {
        access = "readOnly",
        type = "string",
      },
      AllowedMACAddresses = {
        access = "readWrite",
        list = true,
        max = "512",
        type = "string",
      },
      X_000E50_IPv6Enable = {
        access = "readWrite",
        type = "boolean",
        description = "Enable or disable IPv6 address assignment on LAN interface via DHCPv6/RA",
      },
      X_0876FF_DNSProxyEnabled = {
        access = "readOnly",
        type = "boolean",
        description = "Enables or Disables DNSPROXY",
      },
      X_0876FF_VIPEnable = {
        access = "readWrite",
        type = "boolean",
        description = "Enable or disable VIP (Block of Static IP Addresses) in the CPE",
      },
      X_000E50_DNSProxyEnabled = {
        access = "readOnly",
        type = "boolean",
        description = "Enables or Disables DNSPROXY",
      },
      X_000E50_VIPEnable = {
        access = "readWrite",
        type = "boolean",
        description = "Enable or disable VIP (Block of Static IP Addresses) in the CPE",
      },
      X_EDNS0 = {
        access = "readWrite",
        type = "boolean",
        description = "Enable or disable EDNS0 option to the DNS queries (from LAN devices)",
      },
      X_000E50_AddMAC = {
        access = "readWrite",
        type = "string",
        description = "Add the MAC address of the requester to DNS queries",
      },
      -- IPInterfaceNumberOfEntries
      -- automatically created when InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.IPInterface.{i}. is loaded
    }
  }
}

local ipairs, mapper, commitapply = ipairs, mapper, commitapply
local math, register, string = math, register, string
local format, tonumber = string.format, tonumber
local uci_helper = mapper("ucihelper")
local bit = require("bit")
local min = require("math").min
local nwCommon = mapper("nwcommon")
local dhcp = require("transformer.shared.dhcp")
local network = require("transformer.shared.common.network")
local wirelessBinding = { config = "wireless" }
local inet = require("tch.inet")
local syspath = "/sys/class/net/"
local networkBinding = { config = "network" }
local dhcpBinding = { config = "dhcp" }
local getFromUci = uci_helper.get_from_uci
local setOnUci = uci_helper.set_on_uci
local forEachOnUci = uci_helper.foreach_on_uci
local dnsmasqInstance = "secondarydnsmasq"
local transactions = {}

local conditionalsection = {
   ["mac"] = true,
   ["vendorclass"] = true,
   ["userclass"] = true,
   ["host_client_id"] = true,
}
local cpoolpattern = "^tag:conditional"

local function getUciValue(binding, section, option, default, extended)
  binding.sectionname = section
  if option then
    binding.option = option
    binding.default = default
    binding.extended = extended
    return getFromUci(binding)
  end
  return uci_helper.getall_from_uci(binding)
end

local function getDNSMASQConfig(param)
  local disabled = getUciValue(dhcpBinding, "secondarydnsmasq", "disabled")
  if disabled == "0" then
    return getUciValue(dhcpBinding, "secondarydnsmasq", param)
  end
  return getUciValue(dhcpBinding, "@dnsmasq[0]", param, nil, 1)
end

--To read the DNSPROXYEnable param from the uci.
-- If enabled, gateway must return it's LAN IP Address as the primary DNS Server.
-- If set to False, Gateway LAN IP Address must not be automatically returned as the DNS Server,but the DNS Servers learnt/configured on the WAN must be returned to the LAN clients.
local function getDnsProxyEnable(mapping, param, key)
  local gwIP = getUciValue(networkBinding, key, "ipaddr")
  local dhcpOptions = getUciValue(dhcpBinding, "lan", "dhcp_option")
  if dhcpOptions == "" then
    return "1"
  end
  local dnsServer = ""
  for _, v in ipairs(dhcpOptions) do
    if v:find("^6,") == 1 then
      if dnsServer == "" then
        dnsServer = v:sub(3)
      else
        dnsServer = dnsServer .. "," .. v:sub(3)
      end
    end
  end
  if (dnsServer == "")  or (dnsServer ~= "" and dnsServer:match(gwIP)) then
    return "1"
  end
  return "0"
end

-- To set the value on uci config
-- @function setUciParam
-- @param #string option the option to be set in uci
-- @param #string value the value to be set in uci config
local function setUciValue(binding, section, option, value, extended)
  binding.sectionname = section
  binding.option = option
  binding.extended = extended
  setOnUci(binding, value, commitapply)
  transactions[binding.config] = true
end

--- get first non conditional pool on intf key
local function getDHCPConfigSectionForIntf(key)
    local result
    dhcpBinding.sectionname = "dhcp"
    forEachOnUci(dhcpBinding, function(s)
    -- iterate over the dhcp pools and take the first one that has the interface name (key) as the interface
    -- TODO once we add configuration of specific dhcp pools for given options, return the "generic" pool
    -- TODO (the one with no selection)
        if s['interface'] == key then
            local networkid = s['networkid']
            if networkid == nil or string.match(networkid,cpoolpattern) == nil then
                result = s['.name']
                return false
            end
        end
    end)
    return result
end

-- For a given network name (lan for instance), return the wifi-iface sections associated with it in UCI
local function getIfacesForNetwork(network)
    wirelessBinding.sectionname = "wifi-iface"
    local ifaces = {}
    forEachOnUci(wirelessBinding, function(s)
        if s["network"] == network then
            ifaces[#ifaces + 1] = s[".name"]
        end
    end)
    return ifaces
end

local function getDHCPConfig(key, param, default)
    local section = getDHCPConfigSectionForIntf(key)
    if section == nil then
        return nil, "DHCP section not found"
    end
    return getUciValue(dhcpBinding, section, param, default)
end

local function setDHCPConfig(key, param, value)
    local section = getDHCPConfigSectionForIntf(key)
    if section == nil then
        return nil, "DHCP section not found"
    end
    return setUciValue(dhcpBinding, section, param, value)
end

local function getMACAddress(key)
    local macAddr
    local ifnames = getUciValue(networkBinding, key, "ifname")
    for ifname in string.gmatch(ifnames, "%S+") do -- split space separated
    --ifnames maybe in the format eth0 eth1 eh2 eth3
    --or in the format ptm0
    --or in the format vlan100 vlan200
        local file = syspath .. ifname .. "/address"
        macAddr = network.getFirstLine(file)
        if macAddr == "" then
            -- consider that getting the ifname from the vlan
            local ifnameFromVlan = getUciValue(networkBinding, ifname, "ifname")
            if ifnameFromVlan ~="" then
                file  = syspath .. ifnameFromVlan .. "/address"
                macAddr = network.getFirstLine(file)
            end
        end
        if macAddr ~= "" then
            break
        end
    end
    return macAddr or "00:00:00:00:00:00"
end

local function getDHCPdata(key)
    local network_cfg = getUciValue(networkBinding, key)
    local baseip = nwCommon.ipv4ToNum(network_cfg.ipaddr or '') or 0
    local netmask = nwCommon.ipv4ToNum(network_cfg.netmask or '') or 0
    local section = getDHCPConfigSectionForIntf(key)
    local dhcp_cfg
    if section then
        dhcp_cfg = getUciValue(dhcpBinding, section)
    else
        dhcp_cfg = {}
    end
    local start = tonumber(dhcp_cfg[ "start"] or "100")
    local numips = tonumber(dhcp_cfg["limit"] or "150")
    local network = bit.band(baseip, netmask)
    local ipmin = network + 1
    local ipmax = bit.bor(network, bit.bnot(netmask)) - 1
    local ipstart = bit.bor(network, bit.band(start, bit.bnot(netmask)))
    local ipend = min(ipstart + numips - 1, network + 254)
    return {
        name = dhcp_cfg[".name"] or "",
        gw = baseip,
        network = network,
        ipmin = ipmin,
        ipmax = ipmax,
        ipstart = ipstart,
        ipend = ipend,
        start = start,
        numips = numips,
        leasetime = dhcp_cfg["leasetime"] or '-1',
        intf = dhcp_cfg["interface"],
        dhcpv4 = dhcp_cfg["dhcpv4"],
    }
end

-- To retrieve value from uci
-- @function getVIPEnable
-- @param #table dhcpBinding the binding table
-- @param #string sectionname the sectionname to retrieve from config
-- @param #string option the option to retrieve from config
-- If block of static IP is selected,update the X_0876FF_VIPEnable variable as enabled.
-- If enabled,need to send the Gateway IP address as DNS Server.
-- If VIPEnable is disabled,should adapt UCI configuration to ignore that section.
local function getVIPEnable(mapping, param, key)
    local dhcpStart = getDHCPConfig(key, "start")
    local dhcpLimit = getDHCPConfig(key, "limit")
    return (dhcpStart == "" and dhcpLimit == "") and "1" or "0"
end

--function to setVIPEnable
--If VIP is enabled, dhcp option start and limit options should be ignored or set to empty. So that it will take default values from gateway.
--If VIP is disabled, dhcp options start and limit should be considered and set back to default values.
local function setVIPEnable(mapping, param, value, key)
    local section = getDHCPConfigSectionForIntf(key)
    if not section then
        return nil, "DHCP section not found"
    end
    local data = getDHCPdata(key)
    if  value == "1" then
      setDHCPConfig(key, "tch_map_start_backup", data.start)
      setDHCPConfig(key, "tch_map_limit_backup", data.numips)
      setDHCPConfig(key, "start", "")
      setDHCPConfig(key, "limit", "")
    elseif value == "0" then
      setDHCPConfig(key, "start", data.start)
      setDHCPConfig(key, "limit", data.numips)
      setDHCPConfig(key, "tch_map_start_backup", "")
      setDHCPConfig(key, "tch_map_limit_backup", "")
    end
end

local function setEDNS0(value)
  if value == "0" then
    dhcpBinding.sectionname = "dnsmasq"
    forEachOnUci(dhcpBinding, function(s)
      if s[".name"] ~= dnsmasqInstance then
        setUciValue(dhcpBinding, s[".name"], "notinterface", "")
      end
    end)
    setUciValue(dhcpBinding, "lan", "instance", "")
    setUciValue(dhcpBinding, dnsmasqInstance, "disabled", "1")
    setUciValue(dhcpBinding, dnsmasqInstance, "addmac", "")
    setUciValue(dhcpBinding, dnsmasqInstance, "cachesize", "")
  else
    setUciValue("lan", "instance", dnsmasqInstance, dhcpBinding)
    dhcpBinding.sectionname = "dnsmasq"
    forEachOnUci(dhcpBinding, function(s)
      if s[".name"] ~= dnsmasqInstance then
        setUciValue(dhcpBinding, s[".name"], "notinterface", { "lan" })
      end
    end)
    setUciValue(dhcpBinding, dnsmasqInstance, "disabled", "0")
    setUciValue(dhcpBinding, dnsmasqInstance, "addmac", "text")
    setUciValue(dhcpBinding, dnsmasqInstance, "cachesize", "0")
  end
end

local function setDhcpBinding(key)
  dhcpBinding.sectionname = "dhcp"
  local isInstance = false
  forEachOnUci(dhcpBinding, function(s)
    if s.instance then
      isInstance = true
      return false
    end
  end)
  if isInstance then
    dhcpBinding.sectionname = "dnsmasq_" .. key
  else
    dhcpBinding.sectionname = "dnsmasq"
  end
  dhcpBinding.option = "addmac"
end

local function getAddmac(mapping, param, key)
   setDhcpBinding(key)
   return getFromUci(dhcpBinding)
end

local function setAddmac(mapping, param, value, key)
   setDhcpBinding(key)
   if value == "1" or value == "0" or value == "text" or value == "base64" then
     setUciValue(dhcpBinding, dhcpBinding.sectionname, dhcpBinding.option, value)
   end
   dhcpBinding.option = "cachesize"
   if value == "1" or value == "text" or value == "base64"  then
     setUciValue(dhcpBinding, dhcpBinding.sectionname, dhcpBinding.option, "0")
   elseif value == "0" then
     setUciValue(dhcpBinding, dhcpBinding.sectionname, dhcpBinding.option, "")
   end
end

local InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_get = {
    DHCPServerConfigurable = "1",
    DHCPServerEnable = function(mapping, param, key)
        local intf = getDHCPConfig(key, "interface")
        local dhcpv4 = getDHCPConfig(key, "dhcpv4", "server")
        -- consider that the DHCP server is disabled if there is no IP pool defined for the interface or if the
        -- dhcpv4 parameter is set to disabled
        if intf == "" or dhcpv4 == "disabled" then
            return "0"
        else
            return "1"
        end
    end,
    DHCPRelay = "0", -- We don't want to be a DHCP relay
    MACAddress = function(mapping, param, key)
        return getMACAddress(key)
    end,

    MinAddress = function(mapping, param, key)
        local data = getDHCPdata(key)
        return nwCommon.numToIPv4(data.ipstart)
    end,
    MaxAddress = function(mapping, param, key)
        local data = getDHCPdata(key)
        return nwCommon.numToIPv4(data.ipend)
    end,
    ReservedAddresses = function(mapping, param, key)
        return ""
    end,
    SubnetMask = function(mapping, param, key)
        -- get that for the given interface from state in UCI
        return getUciValue(networkBinding, key, "netmask")
    end,
    DNSServers = function(mapping, param, key)
        -- get gw address on given interface from network in UCI
        local ip_result = getUciValue(networkBinding, key, "ipaddr")
        local section = getDHCPConfigSectionForIntf(key) or key
        local result = getUciValue(dhcpBinding, section, "dhcp_option")
        local dnsServer = ""
        if result == "" then
          return ip_result or ""
        end
        for i,v in ipairs(result) do
          if v:find("^6,") == 1 then
            if dnsServer == "" then
              dnsServer = v:sub(3)
            else
              dnsServer = dnsServer .. "," .. v:sub(3)
            end
          end
        end
        if dnsServer == "" then
          if type(ip_result) == "table" then
            return ip_result[1]
          end
          return ip_result
        else
          return dnsServer
        end
    end,
    DomainName = function(mapping, param, key)
        return getDNSMASQConfig("domain")
    end,
    IPRouters = function(mapping, param, key)
        -- get route address from specified interface in dhcp config,
        -- if route address is not present in dhcp config then get from specified interface in network config
        local section = getDHCPConfigSectionForIntf(key) or key
        local dhcpList = getUciValue(dhcpBinding, section, "dhcp_option")
        local routeIP = dhcpList ~= "" and dhcp.getRouteIPAddress(dhcpList)
        if routeIP then
            return routeIP
        end
        local defaultRoute = getUciValue(networkBinding, key, "defaultroute")
        if defaultRoute == "1" or defaultRoute == "" then
            return getUciValue(networkBinding, key, "ipaddr")
        end
        return ""
    end,
    DHCPLeaseTime = function(mapping, param, key)
        return dhcp.convertTimeStringToSeconds(getDHCPConfig(key, "leasetime"))
    end,
    UseAllocatedWAN = "Normal",
    AssociatedConnection = function(mapping, param, key)
        return "" -- TODO need to discuss with Dirk since this raises the exact problem he mentioned
    end,
    PassthroughLease = "600",
    PassthroughMACAddress = "",
    --only support getting from WLAN interface
    AllowedMACAddresses = function(mapping, param, key)
        local macList = {}
        local result
        local ifaces = getIfacesForNetwork(key)
        for _,iface in ipairs(ifaces) do
            result = getUciValue(wirelessBinding, network.getAPForIface(iface), "acl_accept_list")
            if result ~= "" then
                for _,v in ipairs(result) do
                    local isMACExist = "0"
                    for i =1,#macList do
                        if macList[i] == v then
                            isMACExist = "1"
                            break
                        end
                    end
                    if isMACExist == "0" then
                        macList[#macList+1] = v
                    end
                 end
            end
        end
        return  table.concat(macList, ',') or ""
    end,
    X_000E50_IPv6Enable = function(mapping, param, key)
        local ipv6Enable = "0"
        dhcpBinding.sectionname = "dhcp"
        forEachOnUci(dhcpBinding, function(s)
            if s.interface == key then
                if s.dhcpv6 == "server" and s.ra == "server" then
                    ipv6Enable = "1"
                end
                return false
            end
        end)
        return ipv6Enable
    end,
    X_0876FF_DNSProxyEnabled = getDnsProxyEnable,
    X_0876FF_VIPEnable = getVIPEnable,
    X_000E50_DNSProxyEnabled = getDnsProxyEnable,
    X_000E50_VIPEnable = getVIPEnable,
    X_000E50_AddMAC = getAddmac,
    X_EDNS0 = function (mapping, paramname)
      local EDNS0_intf = getUciValue(dhcpBinding, dnsmasqInstance, "disabled")
      if EDNS0_intf == "0" then
        return "1"
      end
      return "0"
    end
}


local function InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_getall(mapping, key)
    local network_cfg = getUciValue(networkBinding, key)
    local dhcp_data = getDHCPdata(key)
    -- consider that the DHCP server is disabled if there is no IP pool defined for the interface or if the
    -- dhcpv4 parameter is set to disabled
    local DHCPServerEnable
    if not dhcp_data['intf'] or dhcp_data['dhcpv4'] == "disabled" then
       DHCPServerEnable = '0'
    else
       DHCPServerEnable = '1'
    end
    local section = getDHCPConfigSectionForIntf(key) or key
    local dhcpList = getUciValue(dhcpBinding, section, "dhcp_option")
    local dnsServer = ""
    local routeIP
    if dhcpList ~= "" then
      for _,v in ipairs(dhcpList) do
        if v:find("^6,") == 1 then
          if dnsServer == "" then
            dnsServer = v:sub(3)
          else
            dnsServer = dnsServer .. "," .. v:sub(3)
          end
        end
      end
      routeIP = dhcp.getRouteIPAddress(dhcpList)
    end
    if dnsServer == "" then
      dnsServer = network_cfg["ipaddr"]
    end
    local macAddressList
    local macList = {}
    local result
    local ifaces = getIfacesForNetwork(key)
    for _,iface in ipairs(ifaces) do
        result = getUciValue(wirelessBinding, network.getAPForIface(iface), "acl_accept_list")
        if result ~= "" then
            for _,v in ipairs(result) do
                local isMACExist = "0"
                for i =1,#macList do
                    if macList[i] == v then
                        isMACExist = "1"
                        break
                    end
                end
                if isMACExist == "0" then
                    macList[#macList+1] = v
                end
            end
        end
   end
    macAddressList = table.concat(macList, ',') or ""

    return {
        DHCPServerConfigurable = "1",
        DHCPRelay = "0", -- We don't want to be a DHCP relay
        MinAddress = nwCommon.numToIPv4(dhcp_data.ipstart),
        MaxAddress = nwCommon.numToIPv4(dhcp_data.ipend),
        MACAddress = getMACAddress(key),
        ReservedAddresses = "",
        SubnetMask = network_cfg["netmask"] or '',
        DNSServers = dnsServer or '',
        IPRouters = routeIP or (network_cfg["defaultroute"] == "1" or not network_cfg["defaultroute"]) and network_cfg["ipaddr"] or "",
        DHCPLeaseTime = dhcp.convertTimeStringToSeconds(getDHCPConfig(key, "leasetime")),
        UseAllocatedWAN = "Normal",
        AssociatedConnection = "",
        PassthroughLease = "600",
        PassthroughMACAddress = "",
        AllowedMACAddresses = macAddressList or "",
        DHCPServerEnable = DHCPServerEnable,

    }
end

local InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_set = {
    DHCPServerEnable = function(mapping, param, value, key)
        local dhcpEnable = value == "1" and "server" or "disabled"
        return setDHCPConfig(key, "dhcpv4", dhcpEnable)
    end,
    MinAddress = function(mapping, param, value, key)
        local res, err = network.setDHCPMinAddress(key, value, commitapply)
        if res then
            transactions[dhcpBinding.config] = true
            return true
        end
        return nil, err
    end,
    MaxAddress = function(mapping, param, value, key)
        local res, err = network.setDHCPMaxAddress(key, value, commitapply)
        if res then
            transactions[dhcpBinding.config] = true
            return true
        end
        return nil, err
    end,
    SubnetMask = function(mapping, param, value, key)
	setUciValue(networkBinding, key, "netmask", value)
    end,
    DNSServers = function(mapping, param, value, key)
        for word in string.gmatch(value, '([^,]+)') do
          if not inet.isValidIPv4(word) then
            return nil, "Invalid IPV4 Address"
          end
        end
        local section = getDHCPConfigSectionForIntf(key) or key
        local result = getUciValue(dhcpBinding, section, "dhcp_option")
        local dnsServers = {}
        if result ~= "" then
          for _,v in ipairs(result) do
            if not (v:find("^6,") == 1) then
              dnsServers[#dnsServers + 1] = v
            end
          end
        end
        dnsServers[#dnsServers + 1] = "6," .. value
        setUciValue(dhcpBinding, section, "dhcp_option", dnsServers)
    end,
    DomainName = function(mapping, param, value, key)
        local allValues = getUciValue(dhcpBinding, "secondarydnsmasq")
        -- set domain name to secondarydnsmasq only if the section is available
        if next(allValues) and allValues.disabled == "0" then
            setUciValue(dhcpBinding, "secondarydnsmasq", "domain", value)
        end
        setUciValue(dhcpBinding, "@dnsmasq[0]", "domain", value, 1)
    end,
    DHCPLeaseTime = function(mapping, param, value, key)
      if value == '-1' then
        value = "infinite" -- set infinite lease time.
      elseif tonumber(value) < 120 then
        return nil, "minimum lease time must be 120 seconds"
      elseif tonumber(value) > 1814400 then
        return nil, "maximum lease time must be 1814400 seconds"
      end
      return setDHCPConfig(key, "leasetime", value)
    end,
    X_000E50_IPv6Enable = function(mapping, param, value, key)
      local sectionFound = false
      local result = value == "1" and "server" or "disabled"
      dhcpBinding.sectionname = "dhcp"
      forEachOnUci(dhcpBinding, function(s)
        if s.interface == key then
          sectionFound = true
          setUciValue(dhcpBinding, s[".name"], "dhcpv6", result)
          setUciValue(dhcpBinding, s[".name"], "ra", result)
          return false
        end
      end)
      if value == "1" and not sectionFound then
        return nil, "Cannot set value as corresponding DHCP section is not available"
      end
    end,
    IPRouters = function(mapping, param, value, key)
        local section = getDHCPConfigSectionForIntf(key)
        if not section then
            return nil, "DHCP section not found"
        elseif inet.isValidIPv4(value) then
            dhcp.setDefaultRoute(value, section)
            transactions[dhcpBinding.config] = true
        else
            return nil, format("%s is not a valid IPv4 Address",value)
        end
    end,
    X_0876FF_VIPEnable = setVIPEnable,
    X_000E50_VIPEnable = setVIPEnable,
    X_000E50_AddMAC = setAddmac,
    --only support setting to WLAN interface
    AllowedMACAddresses = function(mapping, param, value, key)
        local macList = {}
        local ifaces = getIfacesForNetwork(key)
        for mac in string.gmatch(value, '([^,]+)') do
            if nwCommon.isMAC(mac) then
                macList[#macList + 1] = mac
            else
                 return nil, "Invalid MAC address; cannot set"
            end
        end
        for _,iface in ipairs(ifaces) do
             setUciValue(wirelessBinding, network.getAPForIface(iface), "acl_accept_list", macList)
        end
    end,
    X_EDNS0 = function(mapping, param, value)
      setEDNS0(value)
    end
}

local commit = function()
  for config in pairs(transactions) do
    uci_helper.commit({config = config})
  end
  transactions = {}
end

local revert = function()
  for config in pairs(transactions) do
    uci_helper.revert({config = config})
  end
  transactions = {}
end

local function translate_cb(mapping, action, config, sectiontype, sectionname, option)
    if option == "dhcpv4" then
        return { { key = sectionname, paramname = "DHCPServerEnable" } }
    elseif option == "leasetime" then
        local intf = getUciValue(dhcpBinding, sectionname, "interface")
        return { { key = intf , paramname = "DHCPLeaseTime" } }
    end
end

InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.add_watchers = function(mapping)
  local uci_evsrc = eventsource("uci")
  uci_evsrc.watch(mapping, { set = translate_cb }, "dhcp", "dhcp", nil, "dhcpv4")
  uci_evsrc.watch(mapping, { set = translate_cb }, "dhcp", "dhcp", nil, "leasetime")
end

InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.get = InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_get
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.getall= InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_getall
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.set = InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_set
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.commit = commit
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_.revert = revert

register(InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_)

local InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_ = {
  objectType = {
    name = "InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.DHCPConditionalServingPool.{i}.",
    access = "readWrite",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
        default = "false",
      },
      PoolOrder = {
        access = "readOnly",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
      SourceInterface = {
        --access = "readWrite",
        access = "readOnly",
        type = "string",
        max = "1024",
        default = "",
      },
      VendorClassID = {
        access = "readWrite",
        type = "string",
        max = "256",
        default = "",
      },
      ClientID = {
        access = "readWrite",
        type = "string",
        max = "256",
        default = "",
      },
      UserClassID = {
        access = "readWrite",
        type = "string",
        max = "256",
        default = "",
      },
      Chaddr = {
        access = "readWrite",
        type = "string",
        default = "",
      },
      ChaddrMask = {
        --access = "readWrite",
        access = "readOnly",
        type = "string",
        default = "",
      },
      LocallyServed = {
        --access = "readWrite",
        access = "readOnly",
        type = "boolean",
        default = "true",
      },
      MinAddress = {
        access = "readWrite",
        type = "string",
      },
      MaxAddress = {
        access = "readWrite",
        type = "string",
      },
      ReservedAddresses = {
        access = "readOnly",
        list = true,
        max = "512",
        type = "string",
      },
      SubnetMask = {
        access = "readWrite",
        type = "string",
      },
      DNSServers = {
        access = "readWrite",
        list = true,
        max = "64",
        type = "string",
      },
      DomainName = {
        access = "readWrite",
        type = "string",
        max = "64",
      },
      IPRouters = {
        --access = "readWrite",
        access = "readOnly",
        list = true,
        max = "64",
        type = "string",
      },
      DHCPLeaseTime = {
        access = "readWrite",
        type = "int",
        range = {
          {
            min = "-1",
          },
        },
      },
      DHCPServerIPAddress = {
        --access = "readWrite",
        access = "readOnly",
        type = "string",
      },
    }
  }
}

local function getConditionalDHCPdata(parentkey, key)
    local network_cfg = getUciValue(networkBinding, parentkey)
    local baseip = nwCommon.ipv4ToNum(network_cfg.ipaddr or '') or 0
    local netmask = nwCommon.ipv4ToNum(network_cfg.netmask or '') or 0
    local dhcp_cfg
    if key then
        dhcp_cfg = getUciValue(dhcpBinding, key)
    else
        dhcp_cfg = {}
    end
    local network = bit.band(baseip, netmask)
    local ipmin = network + 1
    local ipmax = bit.bor(network, bit.bnot(netmask)) - 1
    local start = tonumber(dhcp_cfg[ "start"] or ipmin)
    local numips = tonumber(dhcp_cfg["limit"] or 1)
    local ipstart = bit.bor(network, bit.band(start, bit.bnot(netmask)))
    local ipend = min(ipstart + numips - 1, network + 254)

    return {
        gw = baseip,
        network = network,
        ipmin = ipmin,
        ipmax = ipmax,
        ipstart = ipstart,
        ipend = ipend,
        start = start,
        numips = numips,
        leasetime = dhcp_cfg["leasetime"] or '-1',
        intf = dhcp_cfg["interface"],
        dhcpv4 = dhcp_cfg["dhcpv4"],
    }
end

local function getOptionAndSection(key, type, option)
    dhcpBinding.sectionname = nil
    local optionValue, section
    local cur_networkid = "set:" .. networkids[key]
    forEachOnUci(dhcpBinding, function(s)
        if s['networkid'] == cur_networkid and s['.type'] == type then
            section, optionValue = s['.name'], s[option]
            return false
        end
    end)
    return optionValue, section
end

local networkids = {}
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.entries = function(mapping, parentkey)
    local dhcpEntries = {}
    dhcpBinding.sectionname = "dhcp"
    forEachOnUci(dhcpBinding, function(s)
        local networkid = s.networkid
        if s.interface == parentkey and networkid then
            local tag = networkid:match("^tag:(.+)")
            if tag then
                dhcpEntries[#dhcpEntries + 1] = s['.name']
                networkids[s['.name']] = tag
            end
        end
    end)
    return dhcpEntries
end

local getconditional = {
    Enable = function(mapping, param, key)
        return getUciValue(dhcpBinding, key, "enable", "0")
    end,
    PoolOrder = "0",
    SourceInterface = "",
    VendorClassID = function(mapping, param, key)
        local _, vendorclassid = getOptionAndSection(key, "vendorclass", "vendorclass")
        return vendorclassid or ""
    end,
    ClientID = function(mapping, param, key)
        local _, hostclassid = getOptionAndSection(key, "host_client_id", "clientid")
        return hostclassid or ""
    end,
    UserClassID = function(mapping, param, key)
        local _, userclassid = getOptionAndSection(key, "userclass", "userclass")
        return userclassid or ""
    end,
    Chaddr = function(mapping, param, key)
        local _, chaddr = getOptionAndSection(key, "mac", "mac")
        return chaddr or ""
    end,
    ChaddrMask = "",
    LocallyServed = "1",
    MinAddress = function(mapping, param, key, parentkey)
        local data = getConditionalDHCPdata(parentkey,key)
        return nwCommon.numToIPv4(data.ipstart)
    end,
    MaxAddress = function(mapping, param, key, parentkey)
        local data = getConditionalDHCPdata(parentkey,key)
        return nwCommon.numToIPv4(data.ipend)
    end,
    ReservedAddresses = "",
    SubnetMask = function(mapping, param, key,parentkey)
         -- get that for the given interface from state in UCI
        return getUciValue(networkBinding, parentkey, "netmask")
    end,
    DNSServers = function(mapping, param, key,parentkey)
        -- get gw address on given interface from network in UCI
        local ip_result = getUciValue(networkBinding, parentkey, "ipaddr")
        local result = getUciValue(dhcpBinding, parentkey, "dhcp_option")
        local dnsServer = ""
        if result == "" then
          return ip_result or ""
        end
        for i,v in ipairs(result) do
          if v:find("^6,") == 1 then
            if dnsServer == "" then
              dnsServer = v:sub(3)
            else
              dnsServer = dnsServer .. "," .. v:sub(3)
            end
          end
        end
        if dnsServer == "" then
          return ip_result
        else
          return dnsServer
        end
    end,
    DomainName = function(mapping, param, key)
        return getDNSMASQConfig("domain")
    end,
    IPRouters = function(mapping, param, key,parentkey)
         -- get gw address on given interface from network in UCI
         return getUciValue(networkBinding, parentkey, "ipaddr")
    end,
    DHCPLeaseTime = function(mapping, param, key)
        return dhcp.convertTimeStringToSeconds(getUciValue(dhcpBinding, key, "leasetime"))
    end,
    DHCPServerIPAddress = "",
}

local function createDHCPSection(key, section, type, option, value)
    if section then
        return setUciValue(dhcpBinding, section, option, value)
    end
    local cur_networkid = "set:" .. networkids[key]
    dhcpBinding.sectionname = type
    dhcpBinding.option = ""
    dhcpBinding.default = ""
    local name = uci_helper.add_on_uci(dhcpBinding, commitapply)
    if name then
        setUciValue(dhcpBinding, name, option, value)
        setUciValue(dhcpBinding, name, "networkid", cur_networkid)
    end
end

local setconditional = {
    Enable = function(mapping, param, value, key)
        setUciValue(dhcpBinding, key, enable, value)
    end,
    VendorClassID = function(mapping, param, value, key)
        local vendorSection = getOptionAndSection(key, "vendorclass", "vendorclass")
        return createDHCPSection(key, vendorSection, "vendorclass", "vendorclass", value)
    end,
    ClientID = function(mapping, param, value, key)
        local clientSection = getOptionAndSection(key, "host_client_id", "clientid")
        return createDHCPSection(key, clientSection, "host_client_id", "clientid", value)
    end,
    UserClassID = function(mapping, param, value, key)
        local userclassSection = getOptionAndSection(key, "userclass", "userclass")
        return createDHCPSection(key, userclassSection, "userclass", "userclass", value)
    end,
    Chaddr = function(mapping, param, value, key)
        local macSection = getOptionAndSection(key, "mac", "mac")
        return createDHCPSection(key, macSection, "mac", "mac", value)
    end,
    MinAddress = function(mapping, param, value, key, parentkey)
        local newstart = nwCommon.ipv4ToNum(value)
        if newstart == nil then
            return nil, "Please input correct ip address"
        end
        local data = getConditionalDHCPdata(parentkey, key)
        if newstart < data.ipmin or newstart >= data.ipend then
            return nil, "Invalid start address"
        end
        local result ,errmsg = overlapCheck(data.network, key, newstart - data.network, data.ipend - newstart + 1)
        if result ~= nil then
	    setUciValue(dhcpBinding, key, "start", newstart - data.network)
	    setUciValue(dhcpBinding, key, "limit", data.ipend - newstart + 1)
        else
            return result, errmsg
        end
    end,
    MaxAddress = function(mapping, param, value, key, parentkey)
        local newend = nwCommon.ipv4ToNum(value)
        if newend == nil then
            return nil, "Please input correct ip address"
        end
        local data = getConditionalDHCPdata(parentkey, key)
        if newend < data.ipstart or newend > data.ipmax + 1 then
            return nil, "Invalid end address"
        end
        local newvalue = newend - data.ipstart + 1
        local result ,errmsg = overlapCheck(data.network, key, data.ipstart - data.network, newvalue)
        if result ~= nil then
	    setUciValue(dhcpBinding, key, "limit", newvalue)
        else
            return result , errmsg
        end
    end,
    SubnetMask = function(mapping, param, value, key, parentkey)
	setUciValue(networkBinding, parentkey, "netmask", value)
    end,
    DNSServers = function(mapping, param, value, key, parentkey)
        local result = getUciValue(dhcpBinding, parentkey, "dhcp_option")
        local dnsIndex = 0
        local lastIndex = 0
        local dnsServers = {}
        if result ~= "" then
            for i,v in ipairs(result) do
                dnsServers[#dnsServers + 1] = v
                if v:find("^6,") == 1 then
                    dnsIndex = dnsIndex + 1
                    lastIndex = i
                end
            end
        end
        local dns = {}
        for word in string.gmatch(value, '([^,]+)') do
            dns[#dns + 1] = word
        end
        if #dns > 3 then
            return nil,"maximum three comma seperated values allowed"
        end
        if dnsIndex == 0 then
            dnsServers[#dnsServers + 1] = "6," .. value
	    setUciValue(dhcpBinding, parentkey, "dhcp_option", dnsServers)
        else
            dnsServers[lastIndex] = "6," .. value
	    setUciValue(dhcpBinding, parentkey, "dhcp_option", dnsServers)
        end
    end,
    DomainName = function(mapping, param, value, key)
        local allValues = getUciValue(dhcpBinding, "secondarydnsmasq")
        -- set domain name to secondarydnsmasq only if the section is available
        if next(allValues) and allValues.disabled == "0" then
            setUciValue(dhcpBinding, "secondarydnsmasq", "domain", value)
        end
        setUciValue(dhcpBinding, "@dnsmasq[0]", "domain", value, 1)
    end,
    DHCPLeaseTime = function(mapping, param, value, key)
      if value == '-1' then
        value = "infinite" -- set infinite lease time.
      end
      setUciValue(dhcpBinding, key, "leasetime", value)
    end,
}

-- get available network id for the new created conditional pool
-- conditional pool network id should be in range of [1, ...]
local function getavailablelid()
    local cid = 0
    dhcpBinding.sectionname = nil
    forEachOnUci(dhcpBinding, function(s)
        local networkid = s['networkid']
        if s[".type"] == "dhcp" and networkid and string.match(networkid,cpoolpattern) ~= nil then
            local id = string.match(networkid,"^tag:conditional_(%d)")
            if id and cid < tonumber(id) then
              cid = tonumber(id)
            end
        end
    end)
    return cid + 1
end

local function addconditionalpool(mapping, parentkey)
    local sectionname = uci_helper.add_on_uci({config = "dhcp",sectionname = "dhcp", option = "",default = ""},commitapply)
    setUciValue(dhcpBinding, sectionname, "interface", parentkey)
    local networkid = "tag:conditional_" .. getavailablelid()
    setUciValue(dhcpBinding, sectionname, "networkid", networkid)
    return sectionname
end

InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.get = getconditional
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.set = setconditional
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.delete = function(mapping,key)
    dhcpBinding.sectionname = key
    dhcpBinding.option = nil
    uci_helper.delete_on_uci(dhcpBinding, commitapply)
    dhcpBinding.sectionname = nil
    local cur_networkid = networkids[key]
    uci_helper.foreach_on_uci(dhcpBinding, function(s)
        if s['networkid'] == ("set:" .. cur_networkid) and s['.type'] and conditionalsection[s['.type']] then
            dhcpBinding.sectionname = s[".name"]
            dhcpBinding.option = nil
            uci_helper.delete_on_uci(dhcpBinding, commitapply)
        end
    end)
    transactions[dhcpBinding.config] = true
    return true
end

InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.add = addconditionalpool
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.commit = commit
InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_.revert = revert
register(InternetGatewayDevice_LANDevice_i_LANHostConfigManagement_DHCPConditionalServingPool_i_)

