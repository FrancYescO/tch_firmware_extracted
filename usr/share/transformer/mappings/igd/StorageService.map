-- Automatically generated from StorageService:1.3
-- using generator version 2.3
local Multi_Storage_i_ = {
  objectType = {
    name = "#ROOT.StorageService.{i}.",
    access = "readOnly",
    numEntriesParameter = "StorageServiceNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
      },
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
      },
      -- PhysicalMediumNumberOfEntries
      -- automatically created when StorageService.{i}.PhysicalMedium.{i}. is loaded
    }
  }
}

local uciHelper = mapper("ucihelper")
local open = io.open
local sambaBinding = { config = "samba", sectionname = "samba" }
local dlnadBinding = { config = "dlnad", sectionname = "config" }
local transactions = {}

local function getUciValue(binding, section, option)
  binding.sectionname = section
  binding.option = option
  return uciHelper.get_from_uci(binding)
end

local function setUciValue(binding, section, option, value)
  binding.sectionname = section
  binding.option = option
  uciHelper.set_on_uci(binding, value, commitapply)
  transactions[binding.config] = true
end

Multi_Storage_i_.entries = function()
  local entries = {}
  local samba = uciHelper.getall_from_uci(sambaBinding)
  local dlnad = uciHelper.getall_from_uci(dlnadBinding)
  if next(samba) and next(dlnad) then
    -- At most one entry should be formed which represents our CPE
    entries[#entries + 1] = "storage"
  end
  return entries
end

Multi_Storage_i_.get = function()
  local sambaEnable = getUciValue(sambaBinding, "samba", "enabled")
  local filesharing = getUciValue(sambaBinding, "samba", "filesharing")
  local dlnaEnabled = getUciValue(dlnadBinding, "config", "enabled")
  if sambaEnable == "1" and filesharing == "1" and dlnaEnabled == "1" then
    return "1"
  else
    return "0"
  end
end

Multi_Storage_i_.set = function(mapping, param, value)
  setUciValue(sambaBinding, "samba", "enabled", value)
  setUciValue(sambaBinding, "samba", "filesharing", value)
  setUciValue(dlnadBinding, "config", "enabled", value)
end

Multi_Storage_i_.commit = function()
  local binding = {}
  for config in pairs(transactions) do
    binding.config = config
    uciHelper.commit(binding)
  end
  transactions = {}
end

Multi_Storage_i_.revert = function()
  local binding = {}
  for config in pairs(transactions) do
    binding.config = config
    uciHelper.revert(binding)
  end
  transactions = {}
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Multi_Storage_i_, "#ROOT", {"InternetGatewayDevice", "Device"})
for _, dupli in ipairs(duplicates) do
  register(dupli)
end

local Multi_PhysicalMedium_i_ = {
  objectType = {
    name = "#ROOT.StorageService.{i}.PhysicalMedium.{i}.",
    access = "readOnly",
    numEntriesParameter = "PhysicalMediumNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    aliasParameter = "Alias",
    parameters = {
      Alias = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "string",
      },
--[[ TODO:
      Name = {
        access = "readWrite",
        type = "string",
        max = "64",
      },
--]]
      Vendor = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
      Model = {
        access = "readOnly",
        type = "string",
        max = "128",
      },
      SerialNumber = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
--[[ TODO:
      FirmwareVersion = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
      ConnectionType = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "USB 1.1",
          "USB 2.0",
          "USB 3.0",
          "USB 3.1",
          "IEEE1394",
          "IEEE1394b",
          "IDE",
          "EIDE",
          "ATA/33",
          "ATA/66",
          "ATA/100",
          "ATA/133",
          "SATA/150",
          "SATA/300",
          "SATA/600",
          "SATA/1969",
          "SCSI-1",
          "Fast SCSI",
          "Fast-Wide SCSI",
          "Ultra SCSI",
          "Ultra Wide SCSI",
          "Ultra2 SCSI",
          "Ultra2 Wide SCSI",
          "Ultra3 SCSI",
          "Ultra-320 SCSI",
          "Ultra-640 SCSI",
          "SAS-1",
          "SAS-2",
          "SAS-3",
          "SAS-4",
          "SSA",
          "SSA-40",
          "Fibre Channel",
        },
      },
      Type = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "HDD",
          "SSD",
          "SSHD",
        },
      },
      Removable = {
        access = "readOnly",
        type = "boolean",
      },
      Capacity = {
        access = "readOnly",
        type = "unsignedInt",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Online",
          "Standby",
          "Offline",
        },
      },
      Uptime = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      SMARTCapable = {
        access = "readOnly",
        type = "boolean",
      },
      Health = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "OK",
          "Failing",
          "Error",
        },
      },
      HotSwappable = {
        access = "readOnly",
        type = "boolean",
      },
--]]
    }
  }
}

local usbDevicesPath = "/sys/bus/usb/devices/"
local lfs = require("lfs")

local paramMap = {
  Vendor       = "manufacturer",
  Model        = "product",
  SerialNumber = "serial"
}

local function getParamValue(file, param)
  local paramValue
  local variant = paramMap[param]
  local path = usbDevicesPath .. file .. "/" .. variant
  local fd = open(path)
  if fd then
    local value = fd:read("*l")
    fd:close()
    paramValue = value
  end
  return paramValue or ""
end

Multi_PhysicalMedium_i_.entries = function()
  local entries = {}
  for file in lfs.dir(usbDevicesPath) do
    if file:match("^%d+-[%d%.]+$") then
      local storageService = false
      local fileName = usbDevicesPath .. file .. "/"
      for usbpath in lfs.dir(fileName) do
        if usbpath:match("^%d+-[%d%.]+:[%d]%.[%d]$") then
          local fd = open(fileName .. usbpath .. "/bInterfaceClass")
          if fd then
            local value = fd:read("*l")
            if value == "08" then
              storageService = true
              break
            end
            fd:close()
          end
        end
      end
      if storageService then
        entries[#entries+1] = file
      end
    end
  end
  return entries
end

Multi_PhysicalMedium_i_.get = function(mapping, param, key)
  return getParamValue(key, param)
end

duplicates = duplicator(Multi_PhysicalMedium_i_, "#ROOT", {"InternetGatewayDevice", "Device"})
for _, dupli in ipairs(duplicates) do
  register(dupli)
end
