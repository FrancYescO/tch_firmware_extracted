local config_cwmpd = "cwmpd"

-- uci.cwmpd
local uci_cwmpd = mapper("uci_1to1").createConfigMap(config_cwmpd)
register(uci_cwmpd)

-- uci.cwmpd.config
local cwmpd_config = {
  config = config_cwmpd,
  section = "cwmpd_config",
  options = { "state", "acs_url", "acs_user", "acs_pass", "periodicinform_enable",
              "periodicinform_interval", "periodicinform_time",
              "connectionrequest_username", "connectionrequest_password",
              "connectionrequest_auth", "connectionrequest_port", "connectionrequest_allowedips",
              "interface", "upgradesmanaged", "upgrade_switchovertype", "upgrade_rollback_timeout",
              "rollback_cwmpd", "rollback_delayed", "rollback_gui", "rollback_unknown",
              "namespace_version", "ssl_castore", "ssl_clientfile", "ssl_ciphersuite",
              "ssl_hostnamecheck", "ssl_verifypeer", "backoff_minwait", "backoff_multiplier",
              "datamodel"
            },
  lists = { 
    "notifications", "forcedactives", "forcedinforms"
  }
}

local uci_cwmpd_config = mapper("uci_1to1").createSimpleMap(cwmpd_config)

local uci = require("uci")
local function removeFromState(option)
  local cursor = uci.cursor(nil,"/var/state") -- Can not use ucihelper, because it does not contain this kind of cursor.
  cursor:revert(cwmpd_config.config, cwmpd_config.section, option)
  cursor:close()
end

local original_set = uci_cwmpd_config.set
local new_set = {}
local metatable = {}
metatable.__index = function(table, key)
  table[key] = function(...)
    removeFromState(key)
    return original_set[key](...)
  end
  return table[key]
end
setmetatable(new_set, metatable)
uci_cwmpd_config.set = new_set

register(uci_cwmpd_config)

mapper("uci_1to1").registerSubmaps(uci_cwmpd_config.submappings)

-- Temporary workaround to have the proper TR-069 events when
-- external IP changes or diagnostics have completed: the backend
-- subscribes on these parameters and external scripts do a set.
register({
  objectType = {
    name = "uci.cwmpd.events.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      ExternalIP = {
        access = "readWrite",
        type = "boolean",
      },
      DiagnosticsComplete = {
        access = "readWrite",
        type = "boolean",
      }
    }
  },
  get = function()
    return "0"
  end,
  set = function()
  end
})
