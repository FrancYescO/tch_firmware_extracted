local Multi_X_000E50_Syslog_ = {
  objectType = {
    name = "#ROOT.",
    access = "readOnly",
    description = "To log messages in syslog server",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      LogFilterIP = {
        access = "readWrite",
        type = "string",
        max = 64,
        description = "IP address of a syslog server to which the log messages should be sent",
      },
      LogFilter = {
        access = "readWrite",
        type = "string",
        list = "true",
        maxItems = "32",
        description = "The log filter entries are used to filter out only the wanted messages",
      },
      LogPort = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
            max = "65535"
          },
        },
        description = "Port number of the remote syslog server specified",
      },
      LogSize = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
        description = "Size of the file or circular memory buffer in KiB",
      },
      LogBufferSize = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
        description = "Size of the log buffer in KiB",
      },
      LogIP = {
        access = "readWrite",
        type = "string",
        max = 64,
        description = "IP address of a syslog server to which the log messages should be sent in addition to the local destination",
      },
      LogFile = {
        access = "readOnly", --The access has been changed to read only for security purposes.
        type = "string",
        max = 64,
        description = "Acts as a reference to the log file that stores Syslog messages",
      },
      LogToFile = {
        access = "readWrite",
        type = "boolean",
        default = "false",
        description = "Write Syslog messages to file, instead of circular memory buffer",
      },
      LogPersistent = {
        access = "readWrite",
        type = "boolean",
        default = "false",
        description = "Filtered Syslog messages are stored persistently",
      },
      LogFilterFile = {
        access = "readOnly", --The access has been changed to read only for security purposes.
        type = "string",
        max = 64,
        description = "Acts as a reference to the log filter file that stores filtered Syslog messages",
      },
      LogFilterLevel = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "8",
          },
        },
        description = "Filter log messages with severity lower then level (=more urgent) only",
      },
      LogHostName = {
        access = "readOnly",
        type = "string",
        max = 64,
        description = "Hostname used in all log messages",
      },
      LogPrefix = {
        access = "readWrite",
        type = "string",
        max = 64,
        description = "Adds a prefix to all log messages send over network",
      },
      LogRemote = {
        access = "readWrite",
        type = "boolean",
        default = "false",
        description = "Enable remote logging",
      },
      LogProto = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "udp",
          "tcp",
        },
        description = "Protocol type for network remote logging",
      },
    }
  }
}

local mapper, ipairs = mapper, ipairs
local uci_helper = mapper("ucihelper")
local binding={config="system", sectionname="@system[0]", option="", default="", extended=true}
local inet = require "tch.inet"
local network = require("transformer.shared.common.network")

local options = {
  LogFilterIP = {"log_filter_ip", ""},
  LogFilter = {"log_filter", {}},
  LogPort = {"log_port", "514"},
  LogSize = {"log_size", "16"},
  LogBufferSize = {"log_buffer_size", "64"},
  LogIP = {"log_ip", ""},
  LogFile = {"log_file", ""},
  LogFilterFile = {"log_filter_file", "/var/log/filt_msg"},
  LogFilterLevel = {"filterloglevel", "8"},
  LogHostName = {"log_hostname", ""},
  LogPrefix = {"log_prefix", ""},
  LogRemote = {"log_remote", "1"},
  LogProto = {"log_proto", "udp"},
}

local function getBinding(pname)
  local option = options[pname]
  if option then
    binding.option = option[1]
    binding.default = option[2]
  else
    binding.option = ""
    binding.default = ""
  end
  return binding
end

local function serializeIfNeeded(value)
  if type(value) == 'table' then
    return table.concat(value, ',')
  end
  return value
end

Multi_X_000E50_Syslog_.get = function(mapping, pname)
  if pname == "LogToFile" then
     local log_file=uci_helper.get_from_uci(getBinding("LogFile"))
     return log_file == "" and "0" or "1"
  elseif pname == "LogPersistent" then
     local log_filter_file=uci_helper.get_from_uci(getBinding("LogFilterFile"))
     return (log_filter_file:find("^/var/") or log_filter_file:find("^/tmp/")) and "0" or "1"
  end
  return serializeIfNeeded(uci_helper.get_from_uci(getBinding(pname)))
end

Multi_X_000E50_Syslog_.getall = function()
  local uci_cfg = uci_helper.getall_from_uci(binding)
  local values = {}
  for param, info in pairs(options) do
    values[param] = serializeIfNeeded(uci_cfg[info[1]] or info[2])
  end
  return values
end

local function validateLogIps(pname, value)
  if value ~= "" then
    -- Value must be an IPv4 address or dns name for LogFilterIP param.
    -- Value must be an IPv4 address for LogIP param.
    if pname == "LogFilterIP" and not (inet.isValidIPv4(value) or network.domainValidation(value)) then
      return nil, "Not a valid IPv4 address or DNS name for " .. pname
    elseif pname == "LogIP" and not inet.isValidIPv4(value) then
      return nil, "Not a valid IPv4 address for " .. pname
    end
    -- LogFilterIP and LogIP must used mutually exclusive, i.e. only one of both may be set.
    -- This is a measure to avoid duplicate syslog messages if both would be set.
    if pname == "LogFilterIP" and uci_helper.get_from_uci(getBinding("LogIP")) ~= "" then
      return nil, "Cannot set LogFilterIP while LogIP is set"
    elseif pname == "LogIP" and uci_helper.get_from_uci(getBinding("LogFilterIP")) ~= "" then
      return nil, "Cannot set LogIP while LogFilterIP is set"
    end
  end
  return true
end

local validators =
{
  LogIP = validateLogIps,
  LogFilterIP = validateLogIps,
}

local lastLogFileName

Multi_X_000E50_Syslog_.set = function(mapping, pname, value)
  local validator = validators[pname]
  if validator then
    local valid, msg = validator(pname, value)
    if not valid then
      return valid, msg
    end
  end
  if pname == "LogFilter" then
    local logfilter = {}
    for v in value:gmatch("([^,]+)") do
      logfilter[#logfilter + 1] = v
    end
    value = logfilter
  elseif pname == "LogToFile" then
    local log_file=uci_helper.get_from_uci(getBinding("LogFile"))
    if log_file ~= "" then
	   lastLogFileName=log_file
	end
    pname = "LogFile"
    value = value == "1" and (lastLogFileName or "/var/log/messages") or ""
  elseif pname == "LogPersistent" then
    local log_filter_file=uci_helper.get_from_uci(getBinding("LogFilterFile"))
    pname = "LogFilterFile"
    log_filter_file=log_filter_file:gsub("^/([^/]+)/", { var = "", tmp = "", etc = "" })
    log_filter_file=log_filter_file:gsub("^/","")
    if value == "1" then
	  log_filter_file="/etc/" .. log_filter_file
	else
	  log_filter_file="/var/" .. log_filter_file
	end
	value=log_filter_file
  end
  return uci_helper.set_on_uci(getBinding(pname), value, commitapply)
end

Multi_X_000E50_Syslog_.commit = function()
  uci_helper.commit(binding)
end

Multi_X_000E50_Syslog_.revert = function()
  uci_helper.revert(binding)
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Multi_X_000E50_Syslog_, "#ROOT", {"InternetGatewayDevice.X_000E50_Syslog", "Device.X_000E50_Syslog", "Device.X_BELGACOM_Syslog"})
for _, dupli in ipairs(duplicates) do
  register(dupli)
end
