-- Manually generated
local Multi_X_TELSTRA_DumaOS_ = {
  objectType = {
    name = "Device.Services.X_TELSTRA_DumaOS.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    description = "Configuration of the DumaOS.",
    parameters = {
      Enable = {
        access = "readWrite",
        type = "boolean",
        default = "0",
        description = "Enables and disables the DumaOS service.",
      },
      Status = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Enabled",
          "Disabled",
        },
        description = "DumaOS capability has been enabled or disabled by the ACS.",
      },
      FastPath = {
--        access = "readWrite", -- If "HARDWARE" is not supported then this parameter should be read-only
        access = "readOnly",
        type = "string",
        enumeration = {
          "Software",
          "Hardware",
        },
        description = "Software or Hardware FastPath for QoS.",
      },
      DownstreamPlanRate = {
        access = "readOnly",
        type = "unsignedInt",
        description = "Downstream subscriber plan rate in Kbps(0 means unknown).",
      },
      UpstreamPlanRate = {
        access = "readOnly",
        type = "unsignedInt",
        description = "Upstream subscriber plan rate in Kbps(0 means unknown).",
      },
      AntiBufferbloatEnable = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "Enabled_Always",
          "Enabled_Trigger",
          "Disabled",
        },
        -- User configurable in the GUI:
        -- Anti-bufferbloat always enabled
        -- Anti-bufferbloat enabled when high priority traffic is detected
        -- Anti-bufferbloat always disabled
        description = "User configurable Anti-bufferbloat.",
      },
      DownstreamThrottlingRate = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "100",
          },
        },
        -- User configurable in the GUI.
        description = "The users downstream throttling rate expressed as a percentage of their downstream plan rate. i.e. Downstream aggregate shaping rate = ThrottlingRate x DSPlanRate / 100",
      },
      UpstreamThrottlingRate = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "100",
          },
        },
        -- User configurable in the GUI.
        description = "The users upstream throttling rate expressed as a percentage of their upstream plan rate. i.e. Upstream aggregate shaping rate = ThrottlingRate x DSPlanRate / 100",
      },
    },
  }
}

local log = require("tch.logger").new("dumaos_mapping", 6)
local uci = mapper("ucihelper")
local execute, open = os.execute, io.open
local conn = mapper("ubus").connect()
local set_on_uci = uci.set_on_uci
local get_from_uci = uci.get_from_uci
local dumaos_ubus = "com.netdumasoftware.qos"
local binding = { config = "dumaos", sectionname = "tr69", option = "", default = "0" }
local dumaos_status = { }
local f_getall = false

local transactions = {}

local status_map = {
  ["0"] = "Disabled",
  ["1"] = "Enabled"
}

local anti_bufferbloat_get_map = {
  ["1"] = "Enabled_Always",
  ["2"] = "Enabled_Trigger",
  ["3"] = "Disabled"
}

local anti_bufferbloat_set_map = {
  Enabled_Always = "1",
  Enabled_Trigger = "2",
  Disabled = "3"
}

local get_rpc_map = {
  -- default index is number = 1
  FastPath = { rpc = "get_acceleration" },
  UpstreamPlanRate = { rpc = "get_bandwidth", idx = 1 },
  DownstreamPlanRate = { rpc = "get_bandwidth", idx = 2 },
  AntiBufferbloatEnable = { rpc = "auto_throttling" },
  UpstreamThrottlingRate = { rpc = "get_link_throttle", idx = 1 },
  DownstreamThrottlingRate = { rpc = "get_link_throttle", idx = 2 },
}

local set_rpc_map = {
  -- default index is string as key = "1"
  FastPath = { rpc = "set_acceleration" },
  AntiBufferbloatEnable = { rpc = "auto_throttling" },
  UpstreamThrottlingRate = { rpc = "set_link_throttle", idx = "1" },
  DownstreamThrottlingRate = { rpc = "set_link_throttle", idx = "2" },
}

local function pathexists(path)
  local file = open(path, "rb")
  if file then
    file:close()
    return true
  end
  return false
end

local function get_param(param, raw)
  if param == "Enable" then
    binding.option = "dumaos_enabled"
    return get_from_uci(binding)
  elseif param == "Status" then
    binding.option = "dumaos_started"
    return status_map[get_from_uci(binding)]
  elseif param == "FastPath" then
    return "Software" -- HardCode
  elseif get_rpc_map[param] and get_rpc_map[param]["rpc"] then
    local get_proc_t = { proc = get_rpc_map[param]["rpc"] }
    local data = conn:call(dumaos_ubus, "rpc", get_proc_t)
    if data and data["result"] then
      if raw then
        return data["result"][1], data["result"][2]
      else
        local idx =  get_rpc_map[param]["idx"] or 1
        if data["result"][idx] then
          if param == "AntiBufferbloatEnable" then
            return anti_bufferbloat_get_map[(data["result"][idx])]
          else
            return tostring(data["result"][idx])
          end
        end
      end
    end
  end

  return ""
end

local function set_param(param, v1, v2)
  local set_proc_t = { proc = set_rpc_map[param]["rpc"] }
  local idx =  set_rpc_map[param]["idx"] or "1"

  if param == "AntiBufferbloatEnable" then
    v1 = anti_bufferbloat_set_map[v1]
  end
  set_proc_t["1"] = v1

  if v2 and v2 ~= "" then
    set_proc_t["2"] = v2
  end

  local data = conn:call(dumaos_ubus, "rpc", set_proc_t)
  if type(data) == "table" then
    return true
  else
    return false
  end

end

local function get_all()
  f_getall = true
  dumaos_status = { Status = "Disabled", FastPath = "Software", DownstreamPlanRate = "", UpstreamPlanRate = "", AntiBufferbloatEnable = "", DownstreamThrottlingRate = "", UpstreamThrottlingRate = "" }

  dumaos_status["Enable"] = get_param("Enable")
  if dumaos_status["Enable"] == "1" then
    local bandwidth_1, bandwidth_2 = get_param("DownstreamPlanRate", true)
    local link_throttle_1, link_throttle_2 = get_param("DownstreamThrottlingRate", true)

    dumaos_status["Status"] = get_param("Status")
    dumaos_status["UpstreamPlanRate"] = tonumber(bandwidth_1) and tostring(bandwidth_1 / 1000) or "" -- kbps
    dumaos_status["DownstreamPlanRate"] = tonumber(bandwidth_2) and tostring(bandwidth_2 / 1000) or "" -- kbps
    dumaos_status["AntiBufferbloatEnable"] = get_param("AntiBufferbloatEnable")
    dumaos_status["UpstreamThrottlingRate"] = tonumber(link_throttle_1) and tostring(link_throttle_1 * 100) or "" -- %
    dumaos_status["DownstreamThrottlingRate"] = tonumber(link_throttle_2) and tostring(link_throttle_2 * 100) or "" -- %
  end
  return dumaos_status
end


Multi_X_TELSTRA_DumaOS_.get = function(mapping, param, value)
  if f_getall == true then
    f_getall = false
  else
    get_all()
  end
  return dumaos_status[param] or ""
end

Multi_X_TELSTRA_DumaOS_.getall = function(mapping, key)
  f_getall = true
  return get_all()
end

Multi_X_TELSTRA_DumaOS_.set = function(mapping, param, value)
  if param ~= "Enable" then
    binding.option = "dumaos_enabled"
    if get_from_uci(binding) == "0" then
      return nil, param .. " not configurable when dumaos is disabled"
    end
  end
  if param == "Enable" then
    binding.option = "dumaos_enabled"
    set_on_uci(binding,value,commitapply)
    transactions[binding] = true
  elseif param == "AntiBufferbloatEnable" then
    return set_param(param, value)
  else
    local v1, v2,_
    if param == "UpstreamThrottlingRate" then
      v1 = tostring(value / 100)
      _, v2 = get_param("DownstreamThrottlingRate", true)
    elseif param == "DownstreamThrottlingRate" then
      v1 = get_param("DownstreamThrottlingRate", true)
      v2 = tostring(value / 100)
    end
    return set_param(param, v1, v2)
  end
  return true
end

Multi_X_TELSTRA_DumaOS_.commit = function()
  for binding in pairs(transactions) do
    uci.commit(binding)
  end
  transactions = {}
end

Multi_X_TELSTRA_DumaOS_.revert = function()
  for binding in pairs(transactions) do
    uci.revert(binding)
  end
  transactions = {}
end

local Multi_X_TELSTRA_DumaOS_APPLICATIONS_ = {
  objectType = {
    name = "Device.Services.X_TELSTRA_DumaOS.Applications.{i}.",
    access = "readOnly",
    minEntries = 0,
    maxEntries = math.huge,
    description = "The application based bandwidth allocation rules configured on DumaOS",
    parameters = {
      Name = {
        access = "readOnly",
        type = "string",
        description = "Description of the bandwidth allocation rule.",
      },
      Weight = {
        access = "readOnly",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "100",
          },
        },
        description = "Weight configured for the bandwidth allocation rule for downstream.",
      },
    },
  }
}

local Multi_X_TELSTRA_DumaOS_DEVICES_ = {
  objectType = {
    name = "Device.Services.X_TELSTRA_DumaOS.Devices.{i}.",
    access = "readOnly",
    minEntries = 0,
    maxEntries = math.huge,
    description = "The device based bandwidth allocation rules configured on DumaOS",
    parameters = {
      Name = {
        access = "readOnly",
        type = "string",
        description = "Description of the bandwidth allocation rule.",
      },
      Weight = {
        access = "readOnly",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "100",
          },
        },
        description = "Weight configured for the bandwidth allocation rule for downstream.",
      },
    },
  }
}

local app_weights = {}
local dev_weights = {}
local function app_dev_entries(device)
  local rule_entries = {}
  local data = conn:call(dumaos_ubus, "rpc", { proc = "get_bandwidth_dist_tree" })

  if data and data["result"] and data["result"][2] then  -- index 2 : downstream; index 1 : upstream
    local s =  data["result"][2]
    if string.match(s, "devices") and device then
      log:notice("Found device")
      dev_weights = {}
    elseif string.match(s, "applications") and device == false then
      app_weights = {}
      log:notice("Found applications")
    else
      return {}
    end

    -- convert string to table:
    -- {"share_excess":true,"domain":"devices","children":[{"id":1,"normprop":0.5},{"id":2,"normprop":0.5}]}
    -- {share_excess=true,domain=devices,children={{id=1,normprop=0.5},{id=2,normprop=0.5}}}
    s = string.gsub(s, '\"', '')
    s = string.gsub(s, ':', '=')
    s = string.gsub(s, '%[{', "{{")
    s = string.gsub(s, "%]}", '}}')
    local t = loadstring("return " .. s)
    local child = t()["children"]

    if child then
      for k, v in pairs(child) do
        for i, j in pairs(v) do
          if i == "id" then
            rule_entries[#rule_entries+1] = tostring(j)
          elseif i == "normprop" then
            if device then
              dev_weights[tostring(v["id"])] = tostring(j * 100)
            else
              app_weights[tostring(v["id"])] = tostring(j * 100)
            end
          end
        end
      end
    end
  end
  return rule_entries
end

local function app_dev_get(device, param, key)
  if param == "Name" then
    return key
  elseif param == "Weight" then
    if device then
      return dev_weights[key]
    else
      return app_weights[key]
    end
  end
  return ""
end

Multi_X_TELSTRA_DumaOS_APPLICATIONS_.entries = function()
  return app_dev_entries(false)
end
Multi_X_TELSTRA_DumaOS_APPLICATIONS_.get = function(mapping, param, key)
  return app_dev_get(false, param, key)
end

Multi_X_TELSTRA_DumaOS_DEVICES_.entries = function()
  return app_dev_entries(true)
end
Multi_X_TELSTRA_DumaOS_DEVICES_.get = function(mapping, param, key)
  return app_dev_get(true, param, key)
end

local objects = { Multi_X_TELSTRA_DumaOS_, Multi_X_TELSTRA_DumaOS_APPLICATIONS_, Multi_X_TELSTRA_DumaOS_DEVICES_ }
for _, object in ipairs(objects) do
  register(object)
end
