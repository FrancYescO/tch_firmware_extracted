local lfs = require("lfs")

if lfs.attributes("/etc/config/mmpbx", "mode") ~= "file" then
    return
end

local tr104Helper = require("transformer.shared.tr104helper")
local commitapply, table = commitapply, table
local serviceBinding = { config = "mmpbx", sectionname = "service" }
local incomingBinding = { config = "mmpbx", sectionname = "incoming_map" }
local uciHelper = mapper("ucihelper")
local networkBinding = { config = "mmpbxrvsipnet" }
local setOnUci = uciHelper.set_on_uci
local foreachOnUci = uciHelper.foreach_on_uci
local addOnUci = uciHelper.add_on_uci
local serviceDefault = require("transformer.shared.servicedefault")
local namedParameter = serviceDefault.services.named_service_section
local addService = serviceDefault.services.add
local tmpBinding = {}
local addBinding = {}
local binding = {}
local transactions = {}

-- Automatically generated from VoiceService:2.0 using generator version 2.3 - START
local Multi_Services_VoiceService_i_CallControl_CallingFeatures_ = {
    objectType = {
        name = "#ROOT.Services.VoiceService.{i}.CallControl.CallingFeatures.",
        access = "readOnly",
        minEntries = 1,
        maxEntries = 1,
        parameters = {
            -- SetNumberOfEntries
            -- automatically created when VoiceService.{i}.CallControl.CallingFeatures.Set.{i}. is loaded
        }
    }
}
-- Automatically generated from VoiceService:2.0 using generator version 2.3 - END

tr104Helper.registerObject("Multi_Services_VoiceService_i_CallControl_CallingFeatures_", Multi_Services_VoiceService_i_CallControl_CallingFeatures_, register)

-- Automatically generated from VoiceService:2.0 using generator version 2.3 - START
local Multi_Services_VoiceService_i_CallControl_CallingFeatures_Set_i_ = {
    objectType = {
        name = "#ROOT.Services.VoiceService.{i}.CallControl.CallingFeatures.Set.{i}.",
        access = "readOnly",
        numEntriesParameter = "SetNumberOfEntries",
        minEntries = 0,
        maxEntries = math.huge,
        parameters = {
            --[[ Alias = {
                access = "readWrite",
                activeNotify = "canDeny",
                type = "string",
            },]]--
            CallerIDEnable = {
                access = "readWrite",
                type = "boolean",
                description = "Enable or disable the transmission of caller ID information on incoming calls (CLIP)",
            },
            --[[ TO DO
            CallerIDNameEnable = {
                  access = "readWrite",
                type = "boolean",
            },]]--
            CallWaitingEnable = {
                access = "readWrite",
                type = "boolean",
                description = "Enables or disables call waiting in the Endpoint",
            },
            --[[ TO DO
            CallForwardUnconditionalEnable = {
                access = "readWrite",
                type = "boolean",
            },
            CallForwardUnconditionalNumber = {
                access = "readWrite",
                type = "string",
                max = "32",
            },
            CallForwardOnBusyEnable = {
                access = "readWrite",
                type = "boolean",
            },
            CallForwardOnBusyNumber = {
                access = "readWrite",
                type = "string",
                max = "32",
            },
            CallForwardOnBusyRingTimeout = {
                access = "readWrite",
                type = "unsignedInt",
            },
            CallForwardOnNoAnswerEnable = {
                access = "readWrite",
                type = "boolean",
            },
            CallForwardOnNoAnswerNumber = {
                access = "readWrite",
                type = "string",
                max = "32",
            },
            CallForwardOnNoAnswerRingTimeout = {
                access = "readWrite",
                type = "unsignedInt",
            },
            CallTransferEnable = {
                access = "readWrite",
                type = "boolean",
            },
            MWIEnable = {
                access = "readWrite",
                type = "boolean",
            },
            VMWIEnable = {
                access = "readWrite",
                type = "boolean",
            },
            LineMessagesWaiting = {
                access = "readOnly",
                type = "unsignedInt",
            },
            AnonymousCallRejectionEnable = {
                access = "readWrite",
                type = "boolean",
            },
            AnonymousCallEnable = {
                access = "readWrite",
                type = "boolean",
            },
            DoNotDisturbEnable = {
                access = "readWrite",
                type = "boolean",
            },
            RepeatDialEnable = {
                access = "readWrite",
                type = "boolean",
            },
            VoiceMailEnable = {
                access = "readWrite",
                type = "boolean",
            },
            CallPickUpEnable = {
               access = "readWrite",
               type = "boolean",
            },
            CCBSEnable = {
                access = "readWrite",
                type = "boolean",
            },
            IIFCEnable = {
               access = "readWrite",
               type = "boolean",
            },
            BlockForwardEnable = {
                access = "readWrite",
                type = "boolean",
            },
            SecretForwarderEnable = {
                access = "readWrite",
                type = "boolean",
            },
            FollowMeEnable = {
                access = "readWrite",
                type = "boolean",
            },]]--
            -- CFTNumberOfEntries
            -- automatically created when VoiceService.{i}.CallControl.CallingFeatures.Set.{i}.CFT.{i}. is loaded
            -- SCFNumberOfEntries
            -- automatically created when VoiceService.{i}.CallControl.CallingFeatures.Set.{i}.SCF.{i}. is loaded
            -- SCREJNumberOfEntries
            -- automatically created when VoiceService.{i}.CallControl.CallingFeatures.Set.{i}.SCREJ.{i}. is loaded
            -- FollowMeNumberOfEntries
            -- automatically created when VoiceService.{i}.CallControl.CallingFeatures.Set.{i}.FollowMe.{i}. is loaded
        }
    }
}
-- Automatically generated from VoiceService:2.0 using generator version 2.3 - END

local configs = {
    {"mmpbxrvsipnet", "profile", "SIPUA"}
}

local function callingFeaturesCommit()
    for config in pairs(transactions) do
        uciHelper.commit({config = config})
    end
    transactions = {}
end

local function callingFeaturesRevert()
    for config in pairs(transactions) do
        uciHelper.revert({config = config})
    end
    transactions = {}
end

Multi_Services_VoiceService_i_CallControl_CallingFeatures_Set_i_.entries = function(mapping, parentKey)
    local entries = {}
    for _, value in pairs(configs) do
        if value[3] == parentKey then
            networkBinding.config = value[1]
            networkBinding.sectionname = value[2]
            foreachOnUci(networkBinding, function(s)
                entries[#entries + 1] = s['.name']
            end)
        end
    end
    return entries
end

Multi_Services_VoiceService_i_CallControl_CallingFeatures_Set_i_.get = {
    CallerIDEnable = function(mapping, param, key, parentKey)
        local enableValue = "0"
        foreachOnUci(serviceBinding, function(s)
            if s["type"] == "CLIP" then
                if s.profile and type(s.profile) == "table" and table.concat(s.profile, " "):match(key) then
                    enableValue = s["activated"] or "0"
                end
            end
        end)
        return enableValue
    end,
    CallWaitingEnable = function(mapping, param, key, parentKey)
        local device = ""
        local callWaitingValue = "0"
        foreachOnUci(serviceBinding, function(s)
            if s["type"] == "CALL_WAITING" then
                if s.device and type(s.device) == "table" then
                    local callWaitingDevice = table.concat(s.device, " ")
                    foreachOnUci(incomingBinding, function(m)
                        if m.profile and m.profile == key and type(m.device) == "table" then
                            device = table.concat(m.device, " ")
                        end
                    end)
                    if #s.device == 1 then
                        if device:match(callWaitingDevice) then
                            callWaitingValue = s["activated"] or "0"
                        end
                    else
                        for deviceName in device:gmatch("%S+") do
                            if callWaitingDevice:match(deviceName) then
                                callWaitingValue = s["activated"] or "0"
                            else
                                callWaitingValue = "0"
                            end
                        end
                    end
                end
            end
        end)
        return callWaitingValue
    end
}

Multi_Services_VoiceService_i_CallControl_CallingFeatures_Set_i_.set = {
    CallerIDEnable = function(mapping, param, value, key, parentKey)
        foreachOnUci(serviceBinding, function(s)
            if s['type'] == "CLIP" then
                if addService["CLIP"] ~= nil and s.profile and #s.profile > 1 then
                    -- particular profile is deleted from existing service section and new section created
                    -- instead of enabling/disabling a service for all sip profiles
                    tmpBinding.config = "mmpbx"
                    tmpBinding.sectionname = s['.name']
                    tmpBinding.option = "profile"
                    local newProfileList = {}
                    if (#s.profile > 1) then
                        for _, value in ipairs(s.profile) do
                            if value ~= key then
                                newProfileList[#newProfileList + 1] = value
                            end
                        end
                        if #s.profile ~= #newProfileList then
                            setOnUci(tmpBinding, newProfileList, commitapply)
                            transactions[tmpBinding.config] = true
                            s.profile = newProfileList
                            addBinding.config = "mmpbx"
                            if namedParameter then
                                addBinding.sectionname = s['.name'].."_"..key
                                addBinding.option = nil
                                setOnUci(addBinding, "service", commitapply)
                            else
                                addBinding.sectionname = "service"
                                local sectionname = addOnUci(addBinding)
                                addBinding.sectionname = sectionname
                            end
                            addBinding.option = "profile"
                            local profileList = {key}
                            setOnUci(addBinding, profileList, commitapply)
                            -- existing parameters from old section are copied into new section
                            for parameter, oldValue in pairs(s) do
                                addBinding.option = parameter
                                if not parameter:match("^[%._]") and parameter ~= "profile" then
                                    setOnUci(addBinding, oldValue, commitapply)
                                end
                            end
                            addBinding.option = "activated"
                            setOnUci(addBinding, value, commitapply)
                            transactions[addBinding.config] = true
                        end
                    end
                else
                    if s.profile and type(s.profile) == "table" and table.concat(s.profile, " "):match(key) then
                        binding.config = "mmpbx"
                        binding.sectionname = s['.name']
                        binding.option = "activated"
                        setOnUci(binding, value, commitapply)
                        transactions[binding.config] = true
                    end
                end
            end
        end)
    end,
    CallWaitingEnable = function(mapping, param, value, key, parentKey)
        foreachOnUci(serviceBinding, function(s)
            if s['type'] == "CALL_WAITING" then
                local device = ""
                foreachOnUci(incomingBinding, function(m)
                    if m.profile and m.profile == key and type(m.device) == "table" then
                        device = table.concat(m.device, " ")
                    end
                end)
                local deviceBinding = { config = "mmpbx", sectionname = s['.name'], option = "activated" }
                if s.device and type(s.device == "table") then
                    local callWaitingDevice = table.concat(s.device, " ")
                    if #s.device == 1 then
                        if device:match(callWaitingDevice) then
                            setOnUci(deviceBinding, value, commitapply)
                            transactions[deviceBinding.config] = true
                        end
                    else
                        for deviceName in device:gmatch("%S+") do
                            if callWaitingDevice:match(deviceName) then
                                setOnUci(deviceBinding, value, commitapply)
                                transactions[deviceBinding.config] = true
                            else
                                return "0"
                            end
                        end
                    end
                end
            end
        end)
    end
}

Multi_Services_VoiceService_i_CallControl_CallingFeatures_Set_i_.commit = callingFeaturesCommit
Multi_Services_VoiceService_i_CallControl_CallingFeatures_Set_i_.revert = callingFeaturesRevert

tr104Helper.registerObject("Multi_Services_VoiceService_i_CallControl_CallingFeatures_Set_i_", Multi_Services_VoiceService_i_CallControl_CallingFeatures_Set_i_, register)
