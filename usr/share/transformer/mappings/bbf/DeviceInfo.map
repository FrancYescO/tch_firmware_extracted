-- Automatically generated from InternetGatewayDevice:1.3 and Device:2.10
-- using generator version 2.3
local Multi_DeviceInfo_ = {
  objectType = {
    name = "#ROOT.DeviceInfo.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      DeviceCategory = {
        access = "readOnly",
        list = true,
        type = "string",
      },
      Manufacturer = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
      ManufacturerOUI = {
        access = "readOnly",
        type = "string",
        min = "6",
        max = "6",
      },
      ModelName = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "string",
        max = "64",
      },
      ModelNumber = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
      Description = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "string",
        max = "256",
      },
      ProductClass = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
      SerialNumber = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
      HardwareVersion = {
        access = "readOnly",
        forcedInform = "true",
        type = "string",
        max = "64",
      },
      SoftwareVersion = {
        access = "readOnly",
        activeNotify = "forceEnabled",
        forcedInform = "true",
        type = "string",
        max = "64",
      },
      AdditionalHardwareVersion = {
        access = "readOnly",
        list = true,
        max = "64",
        type = "string",
      },
      AdditionalSoftwareVersion = {
        access = "readOnly",
        list = true,
        max = "64",
        type = "string",
      },
      ProvisioningCode = {
        access = "readWrite",
        activeNotify = "forceEnabled",
        forcedInform = "true",
        type = "string",
        max = "64",
      },
      UpTime = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "unsignedInt",
      },
      FirstUseDate = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "dateTime",
      },
      X_000E50_ScheduledReboot = {
        access = "readWrite",
        type = "boolean",
        description = "Enables/disables the scheduled reboot",
      },
      X_000E50_BootloaderVersion = {
        access = "readOnly",
        type = "string",
        description = "Displays the Bootloader version of the CPE",
      },
      X_000E50_ReturnToFactoryDefaultsSoft = {
        access = "readWrite",
        type = "boolean",
        description = "Control to set the default configurations in the device",
      },
      X_000E50_FactoryReset_Wireless = {
        access = "readWrite",
        type = "boolean",
        description = "Resetting the Wireless configurations to default",
      },
      X_000E50_TotalSWReboot = {
        access = "readOnly",
        type = "unsignedInt",
        description = "Counts the number of reboot done via CRASH, BOOTP, CLI, GUI, CWMP, STS, UERR, TR64 and resets the counter when the reboot reason is UPGRADE, ROLLBACK, SWOVER",
      },
      X_000E50_TotalHWReboot = {
        access = "readOnly",
        type = "unsignedInt",
        description = "Counts the number of cold boot (reboot via power off) and resets the counter when the reboot reason is UPGRADE, ROLLBACK, SWOVER",
      },
      X_000E50_Customer = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "residential",
          "business",
        },
        description = "Specifies the type of customer whether residential or business",
        default = "Enterprise",
      },
      X_000E50_RebootCause = {
        access = "readOnly",
        type = "string",
        description = "Reboot Cause of the CPE",
      },
      X_000E50_RebootTime = {
        access = "readWrite",
        type = "dateTime",
        description = "Schedule a reboot at the specified date and time if X_000E50_ScheduledReboot is enabled",
      },
      X_000E50_NewSoftwareBank = {
        access = "readWrite",
        type = "string",
        pathRef = true,
        description = "Switch over to the specified software bank",
      },
      X_000E50_SwitchtoPassiveBank = {
        access = "readWrite",
        type = "boolean",
        description = "Control to switch to passive bank",
      },
      X_000E50_VerifyLatestSoftwareVersion = {
        access = "readWrite",
        type = "string",
        activeNotify = "forceEnabled",
        enumeration = {
          "LatestVersion",
          "VerifyVersion",
          "NewVersionAvailable"
        },
        default = "LatestVersion",
        description = "Check whether the latest version is available for online upgrade",
      },
    }
  }
}

local mapper = mapper
local io = io
local string = string
local floor = math.floor
local open = io.open
local process = require 'tch.process'
local pcall, tokey = pcall, tokey
local lfs = require("lfs")
local uciHelper = mapper("ucihelper")
local nwCommon = mapper("nwcommon")
local ubusConnection = mapper("ubus").connect()
local getFromUci = uciHelper.get_from_uci
local forEachOnUci = uciHelper.foreach_on_uci
local setOnUci = uciHelper.set_on_uci
local banktable = require "transformer.shared.banktable"
local commitApply = commitapply
local transactions = {}
local networkBinding = { config = "network" }
local envBinding = { config = "env" }
local ledBinding = { config = "smartled", sectionname = "dnstxtrecord" }
local versionBinding = { config = "versioncusto" }
local cwmpBinding = { config = "cwmpd" }
local sysBinding = { config = "system" }
local systemBinding = { config = "system", sectionname = "@system[0]", extended = true }
local rebootHelper = require("transformer.shared.reboot_helper")
local rip_entry_Refurbished = "c100"
local rip_entry_SSIDPrefix = "c101"

local valueMap = {
  ["0"] = "PWR",
  ["1"] = "CRASH",
  ["2"] = "BOOTP",
  ["3"] = "CLI",
  ["4"] = "GUI",
  ["5"] = "CWMP",
  ["6"] = "STS",
  ["7"] = "UERR",
  ["8"] = "UPGRADE",
  ["9"] = "ROLLBACK",
  ["10"] = "SWOVER",
  ["11"] = "TR64",
  ["12"] = "RTFD"
}

local function firstline(filename, nb)
  local fd = open(filename)
  if not fd then
    -- you could return nil and and error message but that will abort
    -- iterating over all parameters.
    -- so here I opt to just return an empty string.
    return ""
  end
  local result = fd:read(nb or "*l")
  fd:close()
  return result
end

local function getUciValue(binding, section, option, default)
  binding.sectionname = section
  binding.option = option
  binding.default = default
  return getFromUci(binding)
end

local function friendlyName(mapping)
  local value = getUciValue(envBinding, "var", "prod_description")
  if value == "" then
    value = firstline("/proc/rip/0040")
  end
  mapping.get.Description = value
  return value
end

local function switchOverToNewSoftwareBank(mapping,param,value)
  local path = param:match("X_000E50_") and "Device.DeviceInfo.X_000E50_SoftwareBank.{i}." or "Device.DeviceInfo.SoftwareBank.{i}."
  local error, key = pcall(tokey, value, path)
  if not error then
    return nil, "invalid value"
  elseif key ~= "notbooted" then
    return nil, "Cannot Switch Over"
  end
  commitApply:newset("switchOver")
end

Multi_DeviceInfo_.get = {
  DeviceCategory = "",
  Manufacturer = function(mapping)
    local value = getUciValue(envBinding, "var", "company_name")
    if value == "" then
      value = "Technicolor"
    end
    mapping.get.Manufacturer = value
    return value
  end,
  ManufacturerOUI = function(mapping)
    local value = getUciValue(envBinding, "var", "oui_override_igd")
    if value == "" then
      value = getUciValue(envBinding, "var", "oui")
    end
    mapping.get.ManufacturerOUI = value
    return value
  end,
  ModelName = function()
    return getUciValue(envBinding, "var", "prod_friendly_name")
  end,
  ModelNumber = function(mapping)
    local value = getUciValue(envBinding, "var", "prod_number")
    mapping.get.ModelNumber = value
    return value
  end,
  Description = function(mapping)
    return friendlyName(mapping)
  end,
  ProductClass = function(mapping)
    local value = getUciValue(envBinding, "var", "prod_number")
    mapping.get.ProductClass = value
    return value
  end,
  SerialNumber = function(mapping)
    local value = getUciValue(envBinding, "var", "serial")
    mapping.get.SerialNumber = value
    return value
  end,
  HardwareVersion = function(mapping)
    local value = getUciValue(envBinding, "var", "hardware_version")
    mapping.get.HardwareVersion = value
    return value
  end,
  SoftwareVersion = function(mapping)
    local fwVersion = getUciValue(envBinding, "var", "firmware_version")
    if fwVersion ~= "" then
      return fwVersion
    end
    local value = getUciValue(envBinding, "var", "friendly_sw_version_activebank")
    local newvalue = value:match("^([^-]+%-[^-]+)")
    if newvalue then
      value = newvalue
    end
    local fwp = getUciValue(versionBinding, "override", "fwversion_prefix")
    local fws = getUciValue(versionBinding, "override", "fwversion_suffix")
    local fwover = getUciValue(versionBinding, "override", "fwversion_override")
    if fwover ~= "" and fwover ~= "override1" then
      value = fwover
    end
    value = fwp .. value .. fws
    local seperator = getUciValue(versionBinding, "override", "fwversion_seperator")
    if seperator ~= "" then
      value = value:gsub("%.", seperator)
    end
    mapping.get.SoftwareVersion = value
    return value
  end,
  AdditionalSoftwareVersion = function(mapping)
    local value = getUciValue(envBinding, "var", "friendly_sw_version_activebank")
    local newvalue = value:match("([%x]+)$")
    if newvalue then
      value = newvalue
    end
    mapping.get.AdditionalSoftwareVersion = value
    return value
  end,
  AdditionalHardwareVersion = "",
  ProvisioningCode = function()
    return getUciValue(envBinding, "var", "provisioning_code")
  end,
  UpTime = function()
    local fd, msg = open("/proc/uptime")
    if not fd then
      return fd, msg
    end
    local uptime = fd:read("*n")
    fd:close()
    return tostring(math.floor(uptime))
  end,
  FirstUseDate = function()
    local value = getUciValue(cwmpBinding, "cwmpd_config", "firstusedate")
    return value ~= "" and value or "0001-01-01T00:00:00Z"
  end,
  X_000E50_ScheduledReboot = function()
    return rebootHelper.getRebootOptions("enabled", "0")
  end,
  X_000E50_BootloaderVersion = function()
    return getUciValue(envBinding, "var", "bootloader_version")
  end,
  X_000E50_Customer = function()
    return getUciValue(envBinding, "var", "customer")
  end,
  X_000E50_RebootCause = function()
    return valueMap[getUciValue(sysBinding, "warmboot", "reboot")] or ""
  end,
  X_000E50_RebootTime = function()
    return rebootHelper.getRebootOptions("time", "0001-01-01T00:00:00Z")
  end,
  X_000E50_TotalSWReboot = function()
    systemBinding.option = "sw_reboot_count"
    systemBinding.default = "0"
    return getFromUci(systemBinding)
  end,
  X_000E50_TotalHWReboot = function()
    systemBinding.option = "hw_reboot_count"
    systemBinding.default = "0"
    return getFromUci(systemBinding)
  end,
  X_000E50_SwitchtoPassiveBank = "0",
  X_000E50_NewSoftwareBank = "",
  X_000E50_ReturnToFactoryDefaultsSoft = function()
    return getUciValue(envBinding, "var", "rtfds", "0")
  end,
  X_000E50_FactoryReset_Wireless = "0",
  X_000E50_ReturnToFactoryDefaultsSoft = function()
    return getUciValue(envBinding, "var", "rtfds", "0")
  end,
  X_000E50_VerifyLatestSoftwareVersion = function()
    local softwareVersion = getUciValue(envBinding, "var", "verifysoftwareversion")
    return softwareVersion ~= "" and softwareVersion or "LatestVersion"
  end,
}

local function setRebootTime(value)
  local ok, errmsg = rebootHelper.setRebootOptions("time", value)
  if not ok then
    return nil, errmsg
  end
  commitapply:newset("scheduledReboot")
  return true
end

local function setUciValue(binding, section, option, value)
  binding.sectionname = section
  binding.option = option
  setOnUci(binding, value, commitApply)
  transactions[binding.config] = true
end

Multi_DeviceInfo_.set = {
    ProvisioningCode = function(mapping,param,value)
    envBinding.option = "provisioning_code"
    setUciValue(envBinding, "var", "provisioning_code", value)
  end,
  X_000E50_FactoryReset_Wireless = function(mapping, param, value)
    if value == "1" then
      commitApply:newset("rpc.resetconfig.wireless.trigger")
    end
  end,
  X_000E50_ReturnToFactoryDefaultsSoft = function(mapping,param,value)
    setUciValue(envBinding, "var", "rtfds", value)
  end,
  X_000E50_ScheduledReboot = function(mapping, param, value)
    rebootHelper.setRebootOptions("enabled", value)
  end,
  X_000E50_Customer = function(mapping, param, value)
    setUciValue(envBinding, "var", "customer", value)
  end,
  X_000E50_RebootTime = function(mapping, param, value)
    return setRebootTime(value)
  end,
  X_000E50_NewSoftwareBank = switchOverToNewSoftwareBank,
  X_000E50_SwitchtoPassiveBank = function(mapping,param,value)
    if banktable.isOtherBankValid() then
      commitApply:newset("switchOver")
    else
      return nil, "No software in passive bank"
    end
  end,
  X_000E50_VerifyLatestSoftwareVersion = function(mapping,param,value)
    setUciValue(envBinding, "var", "verifysoftwareversion", value)
  end,
}

Multi_DeviceInfo_.commit = function()
  rebootHelper.uci_system_commit()
  for config in pairs(transactions) do
    uciHelper.commit({config = config})
  end
  transactions = {}
end

Multi_DeviceInfo_.revert = function()
  rebootHelper.uci_system_revert()
  for config in pairs(transactions) do
    uciHelper.revert({config = config})
  end
  transactions = {}
end

local function setUciEventProvisioningCode(mapping, action, config, sectionType, sectionName, option)
  return { { key = "", paramname = "ProvisioningCode" } }
end

local function setUciEventVersionUpdate(mapping, action, config, sectionType, sectionName, option, versioncheckevent)
  if versioncheckevent == "VerifyVersion" then
    return { { key = "", paramname = "X_000E50_VerifyLatestSoftwareVersion" } }
  end
end

Multi_DeviceInfo_.add_watchers = function(mapping)
  local uciEventSource = eventsource("uci")
  uciEventSource.watch(mapping, { set = setUciEventProvisioningCode }, "env", "envvars", nil, "provisioning_code")
  uciEventSource.watch(mapping, { set = setUciEventVersionUpdate }, "env", "envvars", nil, "verifysoftwareversion")
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Multi_DeviceInfo_, "#ROOT", {"InternetGatewayDevice", "Device"})
for _, dupli in ipairs(duplicates) do
  register(dupli)
end

