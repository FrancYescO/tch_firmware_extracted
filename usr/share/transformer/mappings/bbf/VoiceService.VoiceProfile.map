local lfs = require("lfs")
local gsub, sub, match, len, find = string.gsub, string.sub, string.match, string.len, string.find

if lfs.attributes("/etc/config/mmpbx", "mode") ~= "file" then
  return
end

local brcmfxsBinding = { config = "mmpbxbrcmfxsdev" }
local uciHelper = mapper("ucihelper")
local tr104Helper = require("transformer.shared.tr104helper")
local faxHelper = require("transformer.shared.fax_helper")
local voiceHelper = require("transformer.shared.voice_helper")
local digitmapHelper = require("transformer.shared.digitmap_helper")

local Multi_Services_VoiceService_i_VoiceProfile_i_ = {
    objectType = {
        name = "#ROOT",
        access = "readWrite",
        minEntries = 0,
        maxEntries = math.huge,
        numEntriesParameter = "VoiceProfileNumberOfEntries",
        enableParameter = "Enable",
        parameters = {
            Enable = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "Disabled",
                    "Quiescent",
                    "Enabled",
                },
                default = "Disabled",
            },
            Reset = {
                access = "readWrite",
                type = "boolean",
                default = "false",
            },
            --      -- NumberOfLines
            --      -- automatically created when Multi.Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}. is loaded
            Name = {
                access = "readWrite",
                type = "string",
                max = "64",
                default = "",
            },
            SignalingProtocol = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "SIP",
                    "MGCP",
                    "H323",
                },
                default = "",
            },
            MaxSessions = {
                access = "readWrite",
                type = "unsignedInt",
                default = "0",
            },
            DTMFMethod = {
                access = "readWrite",
                type = "string",
                max = "64",
                enumeration = {
                     "InBand",
                     "RFC2833",
                     "SIPInfo",
                },
                default = "InBand",
            },
            DTMFMethodG711 = {
                access = "readWrite",
                type = "string",
                max = "64",
                enumeration = {
                    "InBand",
                    "RFC2833",
                    "SIPInfo",
                },
                default = "",
            },
            Region = {
                access = "readWrite",
                type = "string",
            },
            DigitMap = {
                access = "readWrite",
                type = "string",
                max = "2048",
                default = "",
            },
            DigitMapEnable = {
                access = "readWrite",
                type = "boolean",
                default = "true",
            },
            --      STUNEnable = {
            --        access = "readWrite",
            --        type = "boolean",
            --        default = "false",
            --      },
            --      STUNServer = {
            --        access = "readWrite",
            --        type = "string",
            --        max = "256",
            --        default = "",
            --      },
            --      NonVoiceBandwidthReservedUpstream = {
            --        access = "readWrite",
            --        type = "unsignedInt",
            --        default = "0",
            --      },
            --      NonVoiceBandwidthReservedDownstream = {
            --        access = "readWrite",
            --        type = "unsignedInt",
            --        default = "0",
            --      },
            PSTNFailOver = {
                access = "readWrite",
                type = "boolean",
                default = "false",
            },
            FaxPassThrough = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "Disable",
                    "Auto",
                    "Force",
                },
                default = "Auto",
            },
            ModemPassThrough = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "Disable",
                    "Auto",
                    "Force",
                },
                default = "Auto",
            },
            X_000E50_FNN = {
                access = "readWrite",
                type = "string",
                default = "",
                description = "Choose SIP/PSTN network based on this value",
            },
            X_000E50_Interface = {
                access = "readWrite",
                type = "string",
                description = "Allows to configure the network interface to be used for voice",
                default = "",
            },
	    X_000E50_ResetCode = {
	       access = "readWrite",
	       type = "string",
               description = "Reset code to reset the sip network",
	       default = "*#101",
	    },

	    X_000E50_InterDigitTimer = {
	       access = "readWrite",
	       type = "unsignedInt",
               description = "open inter-digit timer value",
	       default = "6",
	    },

	    X_000E50_ShortInterDigitTimer = {
	       access = "readWrite",
	       type = "unsignedInt",
               description = "closed inter digit timer value",
	       default = "0",
	    },
            X_000E50_SubRegion = {
               access = "readWrite",
               type = "unsignedInt",
               description = "To specify the country specific settings for SLIC(FXS), DAA(FXO), Voice drivers, and DSP",
               range = {
                  {
                     min = "0",
                     max = "10",
                  },
               },
            },
            X_FASTWEB_TimerT_RING = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Watchdog for maximum duration of ringing event when CPE is the called party",
            },
        }
    }
}

local uci_helper = mapper("ucihelper")
local common = mapper('nwcommon')
local split_key = common.split_key
local findLanWanInterfaces = common.findLanWanInterfaces
local wanconn = require("transformer.shared.wanconnection")
local conn = mapper("ubus").connect()
local calls = {}
local profile_helper = require("transformer.shared.profile_helper")
local voiceHelper = require("transformer.shared.voice_helper")
local numOfFxs, numOfDect, numOfSipdev
local regionBinding = { config = "mmpbxbrcmcountry", sectionname = "global", option = "region" }
local regionExists = uci_helper.get_from_uci(regionBinding)

local enablestatus = {
    ['0'] = "Disabled",
    ['1'] = "Enabled",
    ['Enabled'] = "1",
    ['Disabled'] = "0",
}

local countryCode = {
    ['SE'] = "sweden",
    ['DK'] = "denmark",
    ['LT'] = "etsi",
    ['EE'] = "etsi"
}

local binding = {}
local dialplanbinding = { config = "mmpbx", sectionname = "dial_plan_generic", option = "digit_map", default = "0" }
local transactions = {}

-- Array Items:
-- 1. config file name
-- 2. specific seciton type for getting sectionnames
-- 3. parent key for filter
local configs = {
    {"mmpbxrvsipnet", "network", "SIPUA"},
    {"mmpbxrvsipdev", "server", "INTUA"},
    {"mmpbxmobilenet", "network", "SIPUA"},
}

local function countryTR104(val, countryType)
    if calls and type(calls) == "table" then
        for country,code in pairs(calls) do
            if countryType == "tr104" and country == val then
                return code["ISOStandard"]
            elseif countryType == "country" and code["ISOStandard"] == val then
                return country
            end
        end
    end
end

local function mapCountryAndCode(val)
    for code,country in pairs(countryCode) do
        if val == code then
            for _,region in ipairs(regionExists) do
                if val == region then
                    return country
                end
            end
        end
    end
end

local function getCountry()
    return uci_helper.get_from_uci({ config = "mmpbxbrcmcountry", sectionname = "global", option = "country", default = "" })
end

local function subRegion(value)
    local country = getCountry()
    local region = countryTR104(country, "tr104")
    local subregion = tonumber(value)
    if region then
        if calls and type(calls) == "table" then
            for i,j in pairs(calls) do
                if region == j["ISOStandard"] and subregion == j["subRegion"] then
                    return i
                end
            end
        end
    end
    return ""
end

local dtmfGetMap = setmetatable({
    auto     = "RFC2833",
    rfc2833  = "RFC2833",
    sipinfo  = "SIPInfo",
    disabled = "InBand",
}, { __index = function() return "" end })

Multi_Services_VoiceService_i_VoiceProfile_i_.entries = function(mapping, parentkey)
    local entries = {}
    if mapping.objectType.name:match("^rpc.") then
        entries = { "1" }
    else
        calls = conn:call("mmbrcm.countries", "get", {}) or {}
        for _,v in pairs(configs) do
            if v[3] == parentkey then
                binding.config = v[1]
                binding.sectionname = v[2]
                uci_helper.foreach_on_uci(binding, function(s)
                    entries[#entries + 1] = v[1] .. "|" .. s['.name']
                end)
            end
        end
    end

    numOfFxs, numOfDect, numOfSipdev = profile_helper.find_device_support(parentkey)

    return entries
end

Multi_Services_VoiceService_i_VoiceProfile_i_.get = {
    Enable = function ()
        binding.config = "mmpbx"
        binding.sectionname = "global"
        binding.option = "enabled"
        local res = uci_helper.get_from_uci(binding)
        return enablestatus[res]
    end,
    Name = function(mapping, paramname, key)
        local config, sectionname = key:match("(.*)|(.*)")
        binding.config = config
        binding.sectionname = sectionname
        binding.option = "user_friendly_name"
        return uci_helper.get_from_uci(binding)
    end,
    SignalingProtocol = function(mapping, paramname, key)
        if key:match("mmpbxmobilenet") then
            return "X_0005E_VoLTE"
        end
        return "SIP"
    end,
    MaxSessions = voiceHelper.getMaxSessions,
    Region = function()
        local country = getCountry()
        if #regionExists > 0 then
            if country ~= "" then
                local region = uci_helper.get_from_uci(regionBinding)
                return region and region[1]
            else
                return ""
            end
        end
        local tr104 = countryTR104(country, "tr104")
        if tr104 then
            return tr104
        else
            return ""
        end
    end,
    DigitMap = function(mapping, paramname, key)
        if key:match("mmpbxmobilenet") then
            return ""
        end
        binding.config = "mmpbx"
        binding.sectionname = "dial_plan_generic"
        binding.option = "digit_map"
        local digitMapState = uci_helper.get_from_uci(binding)
        if digitMapState == "1" then
            return digitmapHelper.getDigitMap()
        else
            return ""
        end
    end,
    DigitMapEnable = function()
        return uci_helper.get_from_uci(dialplanbinding)
    end,
    FaxPassThrough = function(mapping, paramname, key)
        if key:match("mmpbxmobilenet") then
            return ""
        end
        return faxHelper.getFaxPassThrough()
    end,
    ModemPassThrough = "Auto",
    PSTNFailOver = "false",
    DTMFMethod = function(mapping, paramname, key)
        if key:match("mmpbxmobilenet") then
            return ""
        end
        return dtmfGetMap[voiceHelper.getDtmfMethod()] or ""
    end,
    DTMFMethodG711 = function(mapping, paramname, key)
        if key:match("mmpbxmobilenet") then
            return ""
        end
        return dtmfGetMap[voiceHelper.getDtmfMethod()] or ""
    end,
    X_000E50_FNN = function(mapping, paramname, key)
        binding.config = "mmpbxbrcmfxonet"
        binding.sectionname = "fxo_profile"
        binding.option = "enabled"
        local fxo_profile_enabled = uci_helper.get_from_uci(binding)
        if (fxo_profile_enabled == "0") then
            binding.config = "mmpbxrvsipnet"
            binding.sectionname = "sip_profile_0"
            binding.option = "uri"
            return uci_helper.get_from_uci(binding)
        end
        return ""
    end,
    X_000E50_Interface = function(mapping, paramname, key)
        local config, sectionname = key:match("(.*)|(.*)")
        binding.config = config
        binding.sectionname = sectionname
        binding.option = "interface"
        local value =  uci_helper.get_from_uci(binding)
        if mapping.objectType.name:match('^Device%.') then
            return resolve('Device.IP.Interface.{i}.', value) or ""
        end
        local path = ""
        local lanInterfaces = findLanWanInterfaces(false)
        local isLan = false
        for _,j in pairs(lanInterfaces) do
            if (value == j) then
                isLan = true
                break
            end
        end
        if (isLan) then
            path = resolve('InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.IPInterface.{i}.', value)
        else
            local wanport = wanconn.get_connection_key(value)
            path = resolve('InternetGatewayDevice.WANDevice.{i}.WANConnectionDevice.{i}.WANPPPConnection.{i}.', wanport) or resolve('InternetGatewayDevice.WANDevice.{i}.WANConnectionDevice.{i}.WANIPConnection.{i}.', wanport)
        end
        return path or ""
    end,
    Reset = "0",
    X_000E50_ResetCode = function (mapping, paramname, key)
       binding.config = "mmpbx"
       binding.sectionname = "scc_entry"
       local val
       uci_helper.foreach_on_uci(binding, function(s)
         if (s["service_type"] == "RESET_NETWORK") then
	    val = s["pattern"]
	 end
       end)
       return val or "*#101"
    end,
    X_000E50_InterDigitTimer = function (mapping, paramname, key)
       binding.config = "mmpbx"
       if key:match("mmpbxmobilenet") then
           binding.sectionname = "dial_plan_mobile"
       else
           binding.sectionname = "dial_plan_generic"
       end
       binding.option = "open_inter_digit_timer"
       return uci_helper.get_from_uci(binding)
    end,
    X_000E50_ShortInterDigitTimer = function (mapping, paramname, key)
       binding.config = "mmpbx"
       if key:match("mmpbxmobilenet") then
           binding.sectionname = "dial_plan_mobile"
       else
           binding.sectionname = "dial_plan_generic"
       end
       binding.option = "closed_inter_digit_timer"
       return uci_helper.get_from_uci(binding)
    end,
    X_FASTWEB_TimerT_RING = function (mapping, paramname, key)
       binding.config = "mmpbx"
       binding.sectionname = "global"
       binding.option = "no_answer_timeout"
       return uci_helper.get_from_uci(binding)
    end,
    X_000E50_SubRegion = function()
       local country = getCountry()
       if calls and type(calls) == "table" then
          for i,j in pairs(calls) do
             if i == country then
                return tostring(j["subRegion"])
             end
          end
       end
       return ""
     end
}

Multi_Services_VoiceService_i_VoiceProfile_i_.set = {
    Enable = function (mapping, paramname, paramvalue, key)
        binding.config = "mmpbx"
        binding.sectionname = "global"
        binding.option = "enabled"
        local val = "0"
        if paramvalue == "Quiescent" then
            paramvalue = "Disabled"
        end
        val = enablestatus[paramvalue]
        if uci_helper.get_from_uci(binding) ~= val then
            uci_helper.set_on_uci(binding, val, commitapply)
            transactions[binding.config] = true
        end
    end,
    Name = function(mapping, paramname, paramvalue, key)
        local config, sectionname = key:match("(.*)|(.*)")
        binding.config = config
        binding.sectionname = sectionname
        binding.option = "user_friendly_name"
        uci_helper.set_on_uci(binding, paramvalue, commitapply)
        transactions[binding.config] = true
    end,
    SignalingProtocol = function (mapping, paramname, paramvalue, key)
        if paramvalue == "SIP" then
            return
        end
        return nil, "Only support SIP"
    end,
    MaxSessions = function (mapping, paramName, paramValue, key)
        return voiceHelper.setMaxSessions(paramValue, transactions, commitapply)
    end,
    Region = function(mapping, paramname, paramvalue, key)
        if #regionExists > 0 then
            local region_helper = require("transformer.shared.regionhelper")
            local countryFixed = getCountry()
            local country = mapCountryAndCode(paramvalue)
            if country then
                if countryFixed == "" then
	            region_helper.region_set(paramvalue, transactions, commitapply)
                end
            else
                return nil, "the country code is invalid"
            end
            return true
        end
        local country = countryTR104(paramvalue, "country")
        if country then
            paramvalue = country
        else
            return nil, "the country code is invalid"
        end
        binding.config = "mmpbxbrcmcountry"
        binding.sectionname = "global"
        binding.option = "country"
        uci_helper.set_on_uci(binding, paramvalue, commitapply)
        transactions[binding.config] = true
        return true
    end,
    DigitMap = function(mapping, paramname, paramvalue, key)
        local digitMapState = uci_helper.get_from_uci(dialplanbinding)
        if digitMapState == "1" then
            if digitmapHelper.validateDigitMapString(paramvalue) then
                return digitmapHelper.setDigitMap(paramname, paramvalue, transactions, commitapply)
            else
                return nil, "Invalid DigitMap String"
            end
        end
        return nil, "DigitMap is not supported"
    end,
    DigitMapEnable = function(mapping, paramname, paramvalue, key)
        uci_helper.set_on_uci(dialplanbinding, paramvalue, commitapply)
        binding.config = "mmpbx"
        binding.sectionname = "dial_plan_generic"
        binding.option = "no_match_action"
        if paramvalue == "1" then
            uci_helper.set_on_uci(binding, "reject", commitapply)
        else
            uci_helper.set_on_uci(binding, "allow", commitapply)
        end
        transactions[dialplanbinding.config] = true
        transactions[binding.config] = true
        return true
    end,
    FaxPassThrough = function (mapping, paramname, paramvalue, key)
        if key:match("mmpbxmobilenet") then
            return nil, "read only, can not set for mobile_net"
        end
        if paramvalue == "Force" then
            return nil, "can not set 'Force' for FaxPassThrough"
        else
            return faxHelper.setFaxPassThrough(paramvalue, transactions, commitapply)
        end
    end,
    PSTNFailOver = function (mapping, paramname, paramvalue, key)
        if paramvalue ~= "false" and paramvalue ~= "0" then
            return nil, "invalid value"
        end
    end,
    ModemPassThrough  = function ()
        return true   -- Hardcoded to set only the value "Auto"
    end,
    DTMFMethodG711 = function (mapping, paramname, paramvalue, key)
        if key:match("mmpbxmobilenet") then
            return nil, "read only, can not set for mobile_net"
        end
        voiceHelper.setDtmfMethod(paramvalue, transactions, commitapply)
    end,
    DTMFMethod  = function (mapping, paramname, paramvalue, key)
        if key:match("mmpbxmobilenet") then
            return nil, "read only, can not set for mobile_net"
        end
        voiceHelper.setDtmfMethod(paramvalue, transactions, commitapply)
    end,
    X_000E50_FNN = function (mapping, paramname, paramvalue, key)
        binding.config = "mmpbxbrcmfxonet"
        binding.sectionname = "fxo_profile"
        binding.option = "enabled"
        local fxo_profile_enabled = uci_helper.get_from_uci(binding)
        if (fxo_profile_enabled == "0") then
            binding.config = "mmpbxrvsipnet"
            binding.sectionname = "sip_profile_0"
            binding.option = "uri"
            uci_helper.set_on_uci(binding, paramvalue, commitapply)
            transactions[binding.config] = true
        elseif (fxo_profile_enabled == "1") then
            return nil, "It does not implemented for PSTN mode!"
        else
            return nil, "It is not SIP or PSTN mode"
        end
    end,
    X_000E50_Interface = function(mapping, paramname, paramvalue, key)
        -- Convert path to key; this is always the UCI/UBUS interface name, like wan, lan, ...
        local intf = ""
        if string.find(paramvalue,"InternetGatewayDevice.LANDevice.-") or string.find(paramvalue, "InternetGatewayDevice.WANDevice.-") or string.find(paramvalue, "Device.IP.Interface.-")then
        local value = tokey(paramvalue,
            "InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.IPInterface.{i}.",
            "InternetGatewayDevice.WANDevice.{i}.WANConnectionDevice.{i}.WANIPConnection.{i}.",
            "InternetGatewayDevice.WANDevice.{i}.WANConnectionDevice.{i}.WANPPPConnection.{i}.",
            "Device.IP.Interface.{i}."
        )
        if value and value:match("|") then
            -- Interface name is the first part of the WANDevice.WANConnectionDevice.WANIP/WANPPP key
            -- Interface name is the second part of the WANDevice.WANConnectionDevice.WANIP/WANPPP key for active devices
            paramvalue, intf = split_key(value)
        else
            paramvalue = value
        end
        if (not paramvalue) then
            return nil, "Invalid value"
        end
        local config, sectionname = key:match("(.*)|(.*)")
        binding.config = config
        binding.sectionname = sectionname
        binding.option = "interface"
        if paramvalue == "ACTIVE" then
          uci_helper.set_on_uci(binding, intf, commitapply)
        else
          uci_helper.set_on_uci(binding, paramvalue, commitapply)
        end
        transactions[binding.config] = true
        else
            return nil, "given is not a valid interface"
        end
    end,
    Reset = function(mapping, paramname, paramvalue, key)
        if paramvalue == "1" then
            commitapply:newset("Services.VoiceService.{i}.VoiceProfile.{i}.Reset")
        else
            return nil, "can not reset voice profile when reset value is not 1"
        end
    end,
    X_000E50_ResetCode = function (mapping, paramname, paramvalue, key)
       binding.config = "mmpbx"
       binding.sectionname = "scc_entry"

       if (not paramvalue) then
	  return nil, "Invalid value"
       end

       local success
       uci_helper.foreach_on_uci(binding, function(s)
         if (s["service_type"] == "RESET_NETWORK") then
	    binding.sectionname = s['.name']
	    uci_helper.set_on_uci(binding, paramvalue, commitapply)
	    transactions[binding.config] = true
	    success = "1"
	 end
       end)
       if success == "1" then
	  return true
       else
	  return nil, "can not set reset code to reset_network service, check if the service is provisioned"
       end
    end,
    X_000E50_InterDigitTimer = function (mapping, paramname, paramvalue, key)
       if (not paramvalue) then
	  return nil, "Invalid value"
       end

       binding.config = "mmpbx"
       if key:match("mmpbxmobilenet") then
           binding.sectionname = "dial_plan_mobile"
       else
           binding.sectionname = "dial_plan_generic"
       end
       binding.option = "open_inter_digit_timer"
       uci_helper.set_on_uci(binding, paramvalue, commitapply)
       transactions[binding.config] = true
    end,
    X_000E50_ShortInterDigitTimer = function (mapping, paramname, paramvalue, key)
       if (not paramvalue) then
	  return nil, "Invalid value"
       end

       binding.config = "mmpbx"
       if key:match("mmpbxmobilenet") then
           binding.sectionname = "dial_plan_mobile"
       else
           binding.sectionname = "dial_plan_generic"
       end
       binding.option = "closed_inter_digit_timer"
       uci_helper.get_from_uci(binding, paramvalue, commitapply)
       transactions[binding.config] = true
    end,
    X_FASTWEB_TimerT_RING = function (mapping, paramname, paramvalue, key)
       binding.config = "mmpbx"
       binding.sectionname = "global"
       binding.option = "no_answer_timeout"
       uci_helper.set_on_uci(binding, paramvalue, commitapply)
       transactions[binding.config] = true
       return true
    end,
    X_000E50_SubRegion = function(mapping, paramname, paramvalue, key)
       local subregion = subRegion(paramvalue)
       local country = getCountry()
       if subregion ~= "" then
          if subregion == country then
             return nil, "Subregion already exist"
          else
             paramvalue = subregion
          end
       else
          return nil, "the value is invalid"
       end
       binding.config = "mmpbx"
       binding.sectionname = "global"
       binding.option = "country"
       uci_helper.set_on_uci(binding, paramvalue, commitapply)
       transactions[binding.config] = true
       return true
    end,
}

Multi_Services_VoiceService_i_VoiceProfile_i_.commit = function()
    local binding = {}
    for config in pairs(transactions) do
        binding.config = config
        uci_helper.commit(binding)
    end
    transactions = {}
end

Multi_Services_VoiceService_i_VoiceProfile_i_.revert = function()
    local binding = {}
    for config in pairs(transactions) do
        binding.config = config
        uci_helper.revert(binding)
    end
    transactions = {}
end


Multi_Services_VoiceService_i_VoiceProfile_i_.add = function ()
    error ("not implemented")
end

Multi_Services_VoiceService_i_VoiceProfile_i_.delete = function ()
    error ("not implemented")
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Multi_Services_VoiceService_i_VoiceProfile_i_, "#ROOT", {"InternetGatewayDevice.Services.VoiceService.{i}.VoiceProfile.{i}.", "Device.Services.VoiceService.{i}.VoiceProfile.{i}."})
for _, dupli in ipairs(duplicates) do
  register(dupli)
end

local Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_ = {
    objectType = {
      name = "#ROOT.Services.VoiceService.{i}.VoiceProfile.{i}.FaxT38.",
      access = "readOnly",
      minEntries = 1,
      maxEntries = 1,
      parameters = {
        Enable = {
          access = "readWrite",
          type = "boolean",
        },
        HighSpeedRedundancy = {
          access = "readWrite",
          type = "unsignedInt",
          range = {
              {
                  min = "0",
                  max = "3",
              },
          },
        },
        LowSpeedRedundancy = {
          access = "readWrite",
          type = "unsignedInt",
          range = {
              {
                  min = "0",
                  max = "3",
              },
          },
        },
        BitRate = {
          access = "readOnly",    -- ReadWrite not supported.
          type = "unsignedInt",
        },
        TCFMethod = {
          access = "readOnly",    -- ReadWrite not supported.
          type = "string",
          enumeration = {
            "Local",
            "Network"
          },
          default = "",
        },
        HighSpeedPacketRate = {
          access = "readOnly",    -- ReadWrite not supported.
          type = "unsignedInt",
        },
      }
    }
}

local function commit()
    for config in pairs(transactions) do
        uciHelper.commit({config = config})
    end
    transactions = {}
end

local function revert()
    for config in pairs(transactions) do
        uciHelper.revert({config = config})
    end
    transactions = {}
end

local setFaxParam = {
    Enable = function(mapping, paramName, paramValue, key)
        return faxHelper.setFaxT38Enable(mapping, paramName, paramValue, key, transactions, commitapply)
    end,
    HighSpeedRedundancy = function(mapping, paramName, paramValue, key)
        return faxHelper.setT38Redundancy(mapping, paramName, paramValue, key, transactions, commitapply)
    end,
    LowSpeedRedundancy = function(mapping, paramName, paramValue, key)
        return faxHelper.setT38Redundancy(mapping, paramName, paramValue, key, transactions, commitapply)
    end
}

local function setParam(mapping, param, value, key)
    return function(mapping, param, value, key)
        if setFaxParam[param] then
            setFaxParam[param](mapping, param, value, key)
            transactions[brcmfxsBinding.config] = true
            return true
        else
            return nil, "Write not supported"
        end
    end
end

Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.get = faxHelper.getFaxParam(mapping, param, key)
Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.set = setParam(mapping, param, value, key)
Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.commit = commit
Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.revert = revert

Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.add = function()
    error ("Not implemented")
end

Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.delete = function()
    error ("Not implemented")
end

tr104Helper.registerObject("Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_", Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_, register)
