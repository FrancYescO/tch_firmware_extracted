-- Automatically generated from InternetGatewayDevice:1.3 and Device:2.10
-- using generator version 2.3
local Multi_DownloadDiagnostics_ = {
  objectType = {
    name = "#ROOT.DownloadDiagnostics.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      DiagnosticsState = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "None",
          "Requested",
          "Completed",
          "Error_CannotResolveHostName",
          "Error_NoRouteToHost",
          "Error_InitConnectionFailed",
          "Error_NoResponse",
          "Error_TransferFailed",
          "Error_PasswordRequestFailed",
          "Error_LoginFailed",
          "Error_NoTransferMode",
          "Error_NoPASV",
          "Error_IncorrectSize",
          "Error_Timeout",
          "Error_Internal",
          "Error_Other",
        },
      },
      Interface = {
        access = "readWrite",
        type = "string",
        max = "256",
        pathRef = true,
      },
      DownloadURL = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      DownloadTransports = {
        access = "readOnly",
        list = true,
        type = "string",
        enumeration = {
          "HTTP",
          "FTP",
        },
      },
      DownloadDiagnosticMaxConnections = {
        access = "readOnly",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
      DownloadDiagnosticsMaxIncrementalResult = {
        access = "readOnly",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
      DSCP = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "63",
          },
        },
      },
      EthernetPriority = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "7",
          },
        },
      },
--[[ TODO:
      TimeBasedTestDuration = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "999",
          },
        },
      },
      TimeBasedTestMeasurementInterval = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "999",
          },
        },
      },
      TimeBasedTestMeasurementOffset = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "0",
            max = "255",
          },
        },
      },
      ProtocolVersion = {
        access = "readWrite",
        type = "string",
        enumeration = {
          "Any",
          "IPv4",
          "IPv6",
        },
      },
      NumberOfConnections = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
--]]
      IPAddressUsed = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "string",
      },
      ROMTime = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "dateTime",
      },
      BOMTime = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "dateTime",
      },
      EOMTime = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "dateTime",
      },
      TestBytesReceived = {
        access = "readOnly",
        type = "unsignedInt",
      },
      TotalBytesReceived = {
        access = "readOnly",
        type = "unsignedInt",
      },
--[[ TODO:
      TotalBytesSent = {
        access = "readOnly",
        type = "unsignedInt",
      },
      TestBytesReceivedUnderFullLoading = {
        access = "readOnly",
        type = "unsignedInt",
      },
      TotalBytesReceivedUnderFullLoading = {
        access = "readOnly",
        type = "unsignedInt",
      },
      TotalBytesSentUnderFullLoading = {
        access = "readOnly",
        type = "unsignedInt",
      },
      PeriodOfFullLoading = {
        access = "readOnly",
        type = "unsignedInt",
      },
--]]
      TCPOpenRequestTime = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "dateTime",
      },
      TCPOpenResponseTime = {
        access = "readOnly",
        activeNotify = "canDeny",
        type = "dateTime",
      },
      -- PerConnectionResultNumberOfEntries
      -- automatically created when Device.IP.Diagnostics.DownloadDiagnostics.PerConnectionResult.{i}. is loaded
--[[ TODO:
      EnablePerConnectionResults = {
        access = "readWrite",
        activeNotify = "canDeny",
        type = "boolean",
      },
--]]
      -- IncrementalResultNumberOfEntries
      -- automatically created when Device.IP.Diagnostics.DownloadDiagnostics.IncrementalResult.{i}. is loaded
    }
  }
}

local config = "downloaddiag"
local section

local function getSectionName(mapping)
  if mapping.objectType.name:match("^InternetGatewayDevice") then
    return "igd"
  else
    return "device2"
  end
end

local helper = require("transformer.shared.tr143helper")

Multi_DownloadDiagnostics_.get = function(mapping, pname)
  section = getSectionName(mapping)
  return helper.tr143_get(config, section, pname)
end

Multi_DownloadDiagnostics_.set = function(mapping, pname, pvalue)
  section = getSectionName(mapping)
  return helper.tr143_set(config, section, pname, pvalue, commitapply)
end

Multi_DownloadDiagnostics_.getall = function(mapping)
  section = getSectionName(mapping)
  return helper.tr143_getall(config, section)
end

Multi_DownloadDiagnostics_.commit = function()
  helper.tr143_commit(config)
end

Multi_DownloadDiagnostics_.revert = function()
  helper.tr143_revert(config)
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Multi_DownloadDiagnostics_, "#ROOT", {"InternetGatewayDevice", "Device.IP.Diagnostics"})
for _, dupli in ipairs(duplicates) do
  section = getSectionName(dupli)
  local uciBinding = {
    DiagnosticsState = { config = config, sectionname = section, option = "state" },
    Interface = { config = config, sectionname = section, option = "interface" },
    DownloadURL = { config = config, sectionname = section, option = "url" },
    DSCP = { config = config, sectionname = section, option = "dscp" },
    EthernetPriority = { config = config, sectionname = section, option = "pbit" },
  }
  if dupli.objectType.name:match("^InternetGatewayDevice.") then
    dupli.objectType.parameters["DownloadTransports"] = nil
    dupli.objectType.parameters["DownloadDiagnosticMaxConnections"] = nil
    dupli.objectType.parameters["DownloadDiagnosticsMaxIncrementalResult"] = nil
    dupli.objectType.parameters["IPAddressUsed"] = nil
  end
  helper.startup(config, section, uciBinding, resolve, tokey)
  helper.clear_tr143_results(config, section)
  register(dupli)
end
