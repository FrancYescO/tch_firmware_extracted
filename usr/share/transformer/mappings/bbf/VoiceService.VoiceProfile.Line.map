local match, format, upper, lower = string.match, string.format, string.upper, string.lower
local tostring, tonumber, ipairs, pairs, setmetatable = tostring, tonumber, ipairs, pairs, setmetatable
local uci_helper = mapper("ucihelper")
local profile_helper = require("transformer.shared.profile_helper")
local conn = mapper("ubus").connect()

local binding = {}
local service_binding = { config = "mmpbx", sectionname = "service"}
local incoming_binding = { config = "mmpbx", sectionname = "incoming_map"}
local outgoing_binding = { config = "mmpbx", sectionname = "outgoing_map"}
local mt = { __index = function() return "" end }
local common_default = setmetatable({}, mt)
local numOfFxs, numOfDect
local flag = false

local InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_ = {
    objectType = {
        name = "InternetGatewayDevice.Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.",
        access = "readWrite",
        minEntries = 0,
        maxEntries = math.huge,
        numEntriesParameter = "NumberOfLines",
        enableParameter = "Enable",
        parameters = {
            Enable = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "Disabled",
                    "Quiescent",
                    "Enabled",
                },
                default = "Disabled",
            },
            DirectoryNumber = {
                access = "readWrite",
                type = "string",
                max = "32",
                default = "",
            },
            Status = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "Up",
                    "Initializing",
                    "Registering",
                    "Unregistering",
                    "Error",
                    "Testing",
                    "Quiescent",
                    "Disabled",
                },
                default = "Disabled",
            },
            CallState = {
                access = "readOnly",
                activeNotify = "canDeny",
                type = "string",
                enumeration = {
                    "Idle",
                    "Calling",
                    "Ringing",
                    "Connecting",
                    "InCall",
                    "Hold",
                    "Disconnecting",
                },
                default = "Idle",
            },
            PhyReferenceList = {
                access = "readWrite",
                list = true,
                max = "32",
                type = "string",
            },
            --      RingMuteStatus = {
            --        access = "readOnly",
            --        type = "boolean",
            --      },
            --      RingVolumeStatus = {
            --        access = "readOnly",
            --        type = "unsignedInt",
            --        range = {
            --          {
            --            min = "0",
            --            max = "100",
            --          },
            --        },
            --      },
            X_000E50_DisplayName = {
                access = "readWrite",
                type = "string",
            },
            X_000E50_UserFriendlyName = {
                access = "readWrite",
                type = "string",
            },
            X_000E50_ClientAddress = {
                access = "readOnly",
                type = "string",
            },
        }
    }
}

local CallStates = setmetatable({
    MMPBX_CALLSTATE_DIALING = "Calling",
    MMPBX_CALLSTATE_ALERTING = "Ringing",
    MMPBX_CALLSTATE_CALL_DELIVERED = "Connecting",
    MMPBX_CALLSTATE_CONNECTED = "InCall"
}, { __index = function() return "Idle" end })

local ProfileRegStatus = setmetatable({
    Registering = "Registering",
    Registered = "Up",
    Unregistering = "Unregistering"
}, { __index = function() return "Error" end })

local DevRegStatus = {
    ['0'] = "Unregistering",
    ['1'] = "Up",
}

local EnableStatus = {
    ['0'] = "Disabled",
    ['1'] = "Enabled",
    ['Enabled'] = "1",
    ['Disabled'] = "0",
}

local configfile_sip = "mmpbxrvsipnet"

local transactions = {}

local function line_commit()
    local binding = {}
    for config in pairs(transactions) do
        binding.config = config
        uci_helper.commit(binding)
    end
    transactions = {}
end

local function line_revert()
    local binding = {}
    for config in pairs(transactions) do
        binding.config = config
        uci_helper.revert(binding)
    end
    transactions = {}
end

local function getEnable(config, name)
    binding = {
        config = config,
        sectionname = name,
        option = "enabled",
        default = "0"
    }
    return EnableStatus[uci_helper.get_from_uci(binding)]
end

local line_sip_net_map = {
    value = {
        Enable = getEnable,
        CallState = function(config, name)
            local calls = conn:call("mmpbx.call", "get", {})
            if calls and type(calls) == "table" then
                for _,v in pairs(calls) do
                    if v.callState ~= nil and v.profile == name then
                        return CallStates[v.callState]
                    end
                end
            end
            return "Idle"
        end,
        Status = function(config, name)
            local profiles = conn:call("mmpbx.profile", "get", {})
            local regStatus = profiles and profiles[name] and profiles[name]["sipRegisterState"] or ""
            return ProfileRegStatus[regStatus]
        end,
	X_000E50_DisplayName = "display_name",
        DirectoryNumber = "directory_Number",
        PhyReferenceList = function(config, name)
            local tid, id = {}, ""
            uci_helper.foreach_on_uci(incoming_binding, function(s)
                if s.profile == name then
                    if type(s.device) == 'table' then
                        for _,v in ipairs(s.device) do
                            id = match(v, "(%d+)$")
                            if v:sub(1,1) == "d" then
                                id = tostring(tonumber(id) + numOfFxs)
                            end
                            if v:sub(1,1) == "s" then
                                id = tostring(tonumber(id) + numOfFxs + numOfDect)
                            end
                            tid[#tid + 1] = id
                        end
                    end
                end
            end)
            return table.concat(tid, ",")
        end,
    },
    default = common_default,
}

local registrars = {}

local gmac = ""
local macaddr = ""

local function getMacAddress(t, ip)
    if type(t) == "table" then
        for k,v in pairs(t) do
            if type(v) == "table" then
                getMacAddress(v, ip)
            else
                if k == "mac-address" then
                    gmac = v
                end
                if k == "address" and v == ip then
                    macaddr = gmac
                end
            end
        end
    end
end

local line_sip_server_map = {
    value = {
        Enable = getEnable,
        Status = function(config, name)
            local registered = registrars and registrars[name]["registered"] or ""
            return DevRegStatus[registered]
        end,
        DirectoryNumber = "directory_Number",
        X_000E50_UserFriendlyName = "user_friendly_name",
        X_000E50_ClientAddress = function(config, name)
            local addr = registrars and registrars[name]["clientAddress"] or ""
            if addr ~= "" then
                local ipaddr = addr:match("(%d+%.%d+.%d+.%d+)")
                if ipaddr then
                    local hosts = conn:call("hostmanager.device", "get", {})
                    getMacAddress(hosts, ip)
                    return macaddr
                end
            end
            return ""
        end,
    },
    default = common_default,
}

local line_maps = {
    sip_profile = line_sip_net_map,
    sip_dev = line_sip_server_map,
}

local function getInfoFromKey(key, parentkey)
    local config = parentkey:match("^(.*)|.*$")
    local name, ltype = key:match("((%w+_%w+)_%d+)$")
    return config, name, ltype
end


local uris = {}
InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.entries = function(mapping, parentkey)
    local entries = {}
    registrars = {}
    local pconfig = parentkey:match("(.*)|(.*)")

    uris[pconfig] = {}
    local uri_binding = {}
    uri_binding.config = pconfig

    binding.config = "mmpbx"
    binding.sectionname = "profile"
    uci_helper.foreach_on_uci(binding, function(s)
        if s.config == pconfig then
            entries[#entries + 1] = s['.name']

            uri_binding.sectionname = s['.name']
            uri_binding.option = "uri"
            local uri = uci_helper.get_from_uci(uri_binding)
            uris[pconfig][uri] = true
        end
    end)

    binding.sectionname = "device"
    uci_helper.foreach_on_uci(binding, function(s)
        if s.config == pconfig then
            entries[#entries + 1] = s['.name']

            uri_binding.sectionname = s['.name']
            uri_binding.option = "uri"
            local uri = uci_helper.get_from_uci(uri_binding)
            uris[pconfig][uri] = true
        end
        if not flag then
            numOfFxs = numOfFxs or 0
            numOfDect = numOfDect or 0
            if s['.name']:sub(1,1) == "f" then
                numOfFxs = numOfFxs + 1
            end
            if s['.name']:sub(1,1) == "d" then
                numOfDect = numOfDect + 1
            end
        end
    end)

    if numOfFxs and numOfDect then
        flag = true
    end

    registrars = conn:call("mmpbxrvsipdev.registrar", "list", {})
    return entries
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.getall = function(mapping, key, parentkey)
    local config, name, ltype = getInfoFromKey(key, parentkey)
    local map = line_maps[ltype]
    binding.config = config
    binding.sectionname = name
    binding.option = nil
    local object = uci_helper.getall_from_uci(binding)

    local data = {}

    for p,_ in pairs(InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.objectType.parameters) do
        if map.value[p] then
            if type(map.value[p]) == "function" then
                data[p] = map.value[p](config, name)
            else
                data[p] = object[map.value[p]]
            end
        end
        data[p] = data[p] or map.default[p]
    end
    return data
end

local function getParam(maps)
    return function(mapping, param, key, parentkey)
        local config, name, ltype = getInfoFromKey(key, parentkey)
        local map = maps[ltype]
        if map.value[param] then
            if type(map.value[param]) == "function" then
                return map.value[param](config, name)
            else
                binding.config = config
                binding.sectionname = name
                binding.option = map.value[param]
                return uci_helper.get_from_uci(binding)
            end
        else
            return map.default[param]
        end
    end
end

local function setParam(maps, set_maps)
    return function(mapping, param, value, key, parentkey)
        local config, name, ltype = getInfoFromKey(key, parentkey)
        binding.config = config
        binding.sectionname = name
        local map = maps[ltype]
        local set_map = set_maps[ltype]

        if set_map[param] then
            if type(set_map[param]) == "function" then
                binding.option = nil
                local err, msg = set_map[param](binding, value)
                if not err and msg then
                    return err, msg
                end
                transactions[binding.config] = true
                return true
            elseif type(map.value[param]) == "string" then
                binding.option = map.value[param]
                uci_helper.set_on_uci(binding, value, commitapply)
                transactions[binding.config] = true
                return true
            end
        end
        return nil, "Not supported currently"
    end
end

local function setEnable(binding, paramvalue)
    local value = "0"
    binding.option = "enabled"
    value = EnableStatus[paramvalue]
    uci_helper.set_on_uci(binding, value, commitapply)
end

local set_line_sip_net_map = {
    Enable = setEnable,
    DirectoryNumber = true,
    X_000E50_DisplayName = true,
    PhyReferenceList = function(binding, paramvalue)
        local stype = uci_helper.get_from_uci(binding)
        if stype ~= "profile" then
            return nil, "Please firstly add the profile"
        end

        local profile = binding.sectionname
        local port = 0
        local devices = {}
        local name
        for n in paramvalue:gmatch("[^,]+") do
            port = tonumber(n)
            if port then
                if port < numOfFxs then
                    devices[#devices + 1] = format("fxs_dev_%d", port)
                elseif port < (numOfFxs + numOfDect) then
                    devices[#devices + 1] = format("dect_dev_%d", port - numOfFxs)
                else
                    devices[#devices + 1] = format("sip_dev_%d", port - numOfFxs - numOfDect )
                end
            else
                return nil, "The value is invalid"
            end
        end
        profile_helper.port_set(profile, devices, transactions, commitapply)
        return true
    end
}

local set_line_sip_server_map = {
    Enable = setEnable,
    DirectoryNumber = true,
    X_000E50_UserFriendlyName = true,
}

local set_line_maps = {
    sip_profile = set_line_sip_net_map,
    sip_dev = set_line_sip_server_map,
}

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.get = getParam(line_maps)
InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.set = setParam(line_maps, set_line_maps)

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.add = function(mapping, parentkey)
    local pconfig = parentkey:match("(.*)|(.*)")
    local config = "mmpbxrvsipnet"
    if pconfig == config then
        local add_sipnet_defauls = true
        return profile_helper.profile_add(add_sipnet_defauls, transactions, commitapply)
    else
        return nil, "Not supported for add"
    end
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.delete = function(mapping, key, parentkey)
    local config, name, ltype = getInfoFromKey(key, parentkey)
    if (ltype == "sip_profile") then
        profile_helper.profile_delete(key, transactions, commitapply)
        return true
    else
        return nil, "Not supported for delete"
    end
end

local function sip_watch_cb(mapping, action, config, sectiontype, sectionname, option)
    if option == "enabled" then
        return { {key = sectionname, paramname = "Enable"} }
    end
end

local function mmpbx_profile_event(mapping, event, msg)
    if msg.sip and msg.sip.oldest and msg.sip.newest and msg.sip.oldest.registered and msg.sip.newest.registered then
        local oldest = msg.sip.oldest.registered
        local newest = msg.sip.newest.registered
        if (oldest == "Unregistered" and newest == "Registered") or
            (oldest == "Registered" and newest == "Unregistered") then
            return { { key = msg.name, paramname = "Status" } }
        end
    end
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.add_watchers = function(mapping)
    local uci_evsrc = eventsource("uci")
    uci_evsrc.watch(mapping, { set = sip_watch_cb }, configfile_sip, "profile", nil, "enabled")
    local ubus_evsrc = eventsource("ubus")
    ubus_evsrc.watch_event(mapping, mmpbx_profile_event, "mmpbx.profile.status")
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.commit = line_commit
InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_.revert = line_revert
register(InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_)

local InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_SIP_ = {
    objectType = {
        name = "InternetGatewayDevice.Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.SIP.",
        access = "readOnly",
        minEntries = 1,
        maxEntries = 1,
        parameters = {
            AuthUserName = {
                access = "readWrite",
                type = "string",
                max = "128",
                default = "",
            },
            AuthPassword = {
                access = "readWrite",
                hidden = "true",
                type = "string",
                max = "128",
                default = "",
            },
            URI = {
                access = "readWrite",
                type = "string",
                max = "389",
            },
            sip_state = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "wa",
                    "WA",
                    "nsw",
                    "NSW",
                    "act",
                    "ACT",
                    "vic",
                    "VIC",
                    "tas",
                    "TAS",
                    "qld",
                    "QLD",
                    "sa",
                    "SA",
                    "nt",
                    "NT",
                },
            },
            sip_proxy = {
                access = "readWrite",
                type = "string",
                max = "128",
                default = "",
            },
            sip_server = {
                access = "readWrite",
                type = "string",
                max = "128",
                default = "",
            },
            sip_registrar = {
                access = "readWrite",
                type = "string",
                max = "128",
                default = "",
            },
            sip_domain = {
                access = "readWrite",
                type = "string",
                max = "128",
                default = "",
            },
            -- SIPEventSubscribeNumberOfElements
            -- automatically created when InternetGatewayDevice.Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.SIP.EventSubscribe.{i}. is loaded
        }
    }
}

local sipnet_binding = { config = "mmpbxrvsipnet"}
local function state_convert(value)
    return upper(value:match("sip%.([^%.]*)%.iinet.net.au") or "")
end

local function domain_convert(value, network)
    if value == "" then
        sipnet_binding.sectionname = network
        sipnet_binding.option = "primary_registrar"
        value = uci_helper.get_from_uci(sipnet_binding)
    end
    return value
end

local function getSipnetParam(option, convert)
    return function(config, name)
        sipnet_binding.sectionname = name
        sipnet_binding.option = "network"
        local network = uci_helper.get_from_uci(sipnet_binding)
        if network ~= "" then
            sipnet_binding.sectionname = network
            sipnet_binding.option = option
            local value = uci_helper.get_from_uci(sipnet_binding)
            if type(convert) == "function" then
                value = convert(value, network)
            end
            return value
        end
        return ""
    end
end

local function setSipnetParam(option)
    return function(binding, value)
        sipnet_binding.sectionname = binding.sectionname
        sipnet_binding.option = "network"
        local network = uci_helper.get_from_uci(sipnet_binding)
        if network ~= "" then
            sipnet_binding.sectionname = network
            sipnet_binding.option = option
            return uci_helper.set_on_uci(sipnet_binding, value, commitapply)
        end
        return nil, "sip network does not exist"
    end
end

local function setSipnetState(binding, value)
    sipnet_binding.sectionname = binding.sectionname
    sipnet_binding.option = "network"
    local network = uci_helper.get_from_uci(sipnet_binding)
    if network ~= "" then
       value = format("sip.%s.iinet.net.au", lower(value))
       sipnet_binding.sectionname = network
       sipnet_binding.option = "primary_proxy"
       uci_helper.set_on_uci(sipnet_binding, value, commitapply)
       sipnet_binding.option = "primary_registrar"
       uci_helper.set_on_uci(sipnet_binding, value, commitapply)
       return true
    end
    return nil, "sip network does not exist"
end
local sip_sip_net_map = {
    value = {
        AuthUserName = "user_name",
        AuthPassword = "password",
        URI = "uri",
        sip_proxy = getSipnetParam("primary_proxy"),
        sip_server = getSipnetParam("primary_registrar"),
        sip_registrar = getSipnetParam("primary_registrar"),
        sip_domain = getSipnetParam("domain_name", domain_convert),
        sip_state = getSipnetParam("primary_proxy", state_convert),
    },
    default = common_default,
}

local sip_sip_server_map = {
    value = {
        AuthUserName = "user_name",
        AuthPassword = "password",
        URI = "uri"
    },
    default = common_default,
}

local sip_maps = {
    sip_profile = sip_sip_net_map,
    sip_dev = sip_sip_server_map,
}

local set_sip_sip_net_map = {
    AuthUserName = true,
    AuthPassword = function(binding, value)
        binding.option = "password"
        uci_helper.set_on_uci(binding, value, commitapply)
        return true
    end,
    URI = function(binding, value)
        binding.option = "uri"

        if uci_helper.get_from_uci(binding) ~= value and uris[binding.config][value] then
            return nil, "this URI has alreay existed"
        end
        uci_helper.set_on_uci(binding, value, commitapply)
        return true
    end,
    sip_proxy = setSipnetParam("primary_proxy"),
    sip_server = setSipnetParam("primary_registrar"),
    sip_registrar = setSipnetParam("primary_registrar"),
    sip_domain = setSipnetParam("domain_name"),
    sip_state = setSipnetState,
}
local set_sip_sip_server_map = {
    AuthUserName = true,
    AuthPassword = function(binding, value)
        binding.option = "password"
        uci_helper.set_on_uci(binding, value, commitapply)
    end,
    URI = function(binding, value)
        binding.option = "uri"

        if uci_helper.get_from_uci(binding) ~= value and uris[binding.config][value] then
            return nil, "this URI has alreay existed"
        end
        uci_helper.set_on_uci(binding, value, commitapply)
        return true
    end,
    sip_proxy = setSipnetParam("primary_proxy"),
    sip_server = setSipnetParam("primary_registrar"),
}

local set_sip_maps = {
    sip_profile = set_sip_sip_net_map,
    sip_dev = set_sip_sip_server_map,
}

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_SIP_.get = getParam(sip_maps)
InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_SIP_.set = setParam(sip_maps, set_sip_maps)
InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_SIP_.getall = function(mapping, key, parentkey)
    local config, name, ltype = getInfoFromKey(key, parentkey)
    local map = sip_maps[ltype]
    binding.config = config
    binding.sectionname = name
    binding.option = nil
    local v = uci_helper.getall_from_uci(binding)

    local uri = ""

    if type(map.value["URI"]) == "function" then
        uri = map.value["URI"](config, name)
    else
        uri = v[map.value["URI"]]
    end

    return {
        AuthUserName = v[map.value["AuthUserName"]] or map.default["AuthUserName"],
        AuthPassword = v[map.value["AuthPassword"]] or map.default["AuthPassword"],
        URI = uri or map.default["URI"],
    }
end

local auth_maps = {
    user_name = "AuthUserName",
    password = "AuthPassword",
    uri = "URI",
}

local function line_sip_watch_cb(mapping, action, config, sectiontype, sectionname, option)
    if auth_maps[option] then
        return { {key = sectionname, paramname = auth_maps[option]}}
    end
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_SIP_.add_watchers = function(mapping)
    local uci_evsrc = eventsource("uci")
    for k,_ in pairs(auth_maps) do
        uci_evsrc.watch(mapping, { set = line_sip_watch_cb }, configfile_sip, "profile", nil, k)
    end
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_SIP_.commit = line_commit
InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_SIP_.revert = line_revert
register(InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_SIP_)

local InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Stats_ = {
    objectType = {
        name = "InternetGatewayDevice.Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.Stats.",
        access = "readOnly",
        minEntries = 1,
        maxEntries = 1,
        parameters = {
            IncomingCallsReceived = {
                access = "readOnly",
                type = "unsignedInt",
            },
            IncomingCallsFailed = {
                access = "readOnly",
                type = "unsignedInt",
            },
            OutgoingCallsAttempted = {
                access = "readOnly",
                type = "unsignedInt",
            },
            OutgoingCallsFailed = {
                access = "readOnly",
                type = "unsignedInt",
            },
            TotalCallTime = {
                access = "readOnly",
                type = "unsignedInt",
            },
        }
    }
}

local function call2num(direction, calltype)
    return function(v)
        if v["Direction"]==direction and (calltype or (not calltype and (v["connectedTime"] or "0") == "0")) then
            return 1
        end
        return 0
    end
end
local time_t = {}
local function convert2Sec(value)
    time_t.year, time_t.month, time_t.day, time_t.hour, time_t.min, time_t.sec = value:match("(%d+)-(%d+)-(%d+)%s+(%d+):(%d+):(%d+)")
    if time_t.year then
        return os.time(time_t)
    end
    return 0
end

local function call2duration(direction, calltype)
    return function(v)
        local endTime, connectedTime = (v["endTime"] or "0"), (v["connectedTime"] or "0")
        if connectedTime ~= "0" then
            if endTime ~= "0" then
                return convert2Sec(endTime) - convert2Sec(connectedTime)
            else
                return os.time() - convert2Sec(connectedTime)
            end
        end
        return 0
    end
end

local stats_handler = {
    IncomingCallsReceived = call2num("1", true),
    IncomingCallsFailed = call2num("1", false),
    OutgoingCallsAttempted = call2num("2", true),
    OutgoingCallsFailed = call2num("2", false),
    TotalCallTime = call2duration(),
}

local list = "CALLLOG LIST"
local function stats_get(mapping, param, key, parentkey)
    local uri_get=getParam(sip_maps)
    local uri = uri_get(mapping, "URI", key, parentkey)
    if uri == "" then
        return "0"
    end
    local value = 0
    local handler = stats_handler[param]
    local calllogs = conn:call("mmdbd.calllog", "list", {} )
    if calllogs and calllogs[list] then
        for _,v in pairs (calllogs[list]) do
            if v.Localparty == uri then
                value = value + handler(v)
            end
        end
    end
    return tostring(value)
end

local function stats_getall(mapping, key, parentkey)
    local results = {
        IncomingCallsReceived = "0",
        IncomingCallsFailed = "0",
        OutgoingCallsAttempted = "0",
        OutgoingCallsFailed = "0",
        TotalCallTime = "0",
    }
    local uri_get=getParam(sip_maps)
    local uri = uri_get(mapping, "URI", key, parentkey)
    if uri == "" then
        return results
    end
    local calllogs = conn:call("mmdbd.calllog", "list", {} )
    if calllogs and calllogs[list] then
        for _,v in pairs (calllogs[list]) do
            if v["Localparty"] == uri then
                local endTime, connectedTime = (v["endTime"] or "0"), (v["connectedTime"] or "0")
                if v["Direction"]=="1" then
                    results.IncomingCallsReceived = results.IncomingCallsReceived + 1
                    if connectedTime == "0" then
                        results.IncomingCallsFailed = results.IncomingCallsFailed + 1
                    end
                else
                    results.OutgoingCallsAttempted = results.OutgoingCallsAttempted + 1
                    if connectedTime == "0" then
                        results.OutgoingCallsFailed = results.OutgoingCallsFailed + 1
                    end
                end
                local duration = 0
                if connectedTime ~= "0" then
                    if endTime ~= "0" then
                        duration = convert2Sec(endTime) - convert2Sec(connectedTime)
                    else
                        duration = os.time() - convert2Sec(connectedTime)
                    end
                end
                results.TotalCallTime = results.TotalCallTime + duration
            end
        end
    end
    for k,v in pairs(results) do
        results[k] = tostring(v)
    end
    return results
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Stats_.get = stats_get
InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Stats_.getall = stats_getall
register(InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Stats_)

local InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_CallingFeatures_ = {
    objectType = {
        name = "InternetGatewayDevice.Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.CallingFeatures.",
        access = "readOnly",
        minEntries = 1,
        maxEntries = 1,
        parameters = {
            CallerIDEnable = {
                access = "readWrite",
                type = "boolean",
            },
            CallerIDNameEnable = {
                access = "readWrite",
                type = "boolean",
            },
            CallerIDName = {
                access = "readWrite",
                type = "string",
                max = "256",
            },
            CallWaitingEnable = {
                access = "readWrite",
                type = "boolean",
            },
            --      CallWaitingStatus = {
            --        access = "readOnly",
            --        type = "string",
            --        enumeration = {
            --          "Disabled",
            --          "Idle",
            --          "SecondaryRinging",
            --          "SecondaryConnecting",
            --          "SecondaryConnected",
            --        },
            --      },
            MaxSessions = {
                access = "readWrite",
                type = "unsignedInt",
            },
            --      ConferenceCallingStatus = {
            --        access = "readOnly",
            --        type = "string",
            --        enumeration = {
            --          "Disabled",
            --          "Idle",
            --          "SecondaryCalling",
            --          "SecondaryConnecting",
            --          "SecondaryConnected",
            --          "InConferenceCall",
            --        },
            --      },
            --      ConferenceCallingSessionCount = {
            --        access = "readOnly",
            --        type = "unsignedInt",
            --        range = {
            --          {
            --            min = "0",
            --            max = "0",
            --          },
            --          {
            --            min = "1",
            --            max = "1",
            --          },
            --          {
            --            min = "1",
            --          },
            --        },
            --      },
            CallForwardUnconditionalEnable = {
                access = "readWrite",
                type = "boolean",
            },
            CallForwardUnconditionalNumber = {
                access = "readWrite",
                type = "string",
                max = "32",
            },
            CallForwardOnBusyEnable = {
                access = "readWrite",
                type = "boolean",
            },
            CallForwardOnBusyNumber = {
                access = "readWrite",
                type = "string",
                max = "32",
            },
            CallForwardOnNoAnswerEnable = {
                access = "readWrite",
                type = "boolean",
            },
            CallForwardOnNoAnswerNumber = {
                access = "readWrite",
                type = "string",
                max = "32",
            },
            --      CallForwardOnNoAnswerRingCount = {
            --        access = "readWrite",
            --        type = "unsignedInt",
            --      },
            CallTransferEnable = {
                access = "readWrite",
                type = "boolean",
            },
            --      MWIEnable = {
            --        access = "readWrite",
            --        type = "boolean",
            --      },
            --      MessageWaiting = {
            --        access = "readOnly",
            --        type = "boolean",
            --      },
            AnonymousCallBlockEnable = {
                access = "readWrite",
                type = "boolean",
            },
            AnonymousCalEnable = {
                access = "readWrite",
                type = "boolean",
            },
            --      DoNotDisturbEnable = {
            --        access = "readWrite",
            --        type = "boolean",
            --      },
            --      CallReturnEnable = {
            --        access = "readWrite",
            --        type = "boolean",
            --      },
            --      RepeatDialEnable = {
            --        access = "readWrite",
            --        type = "boolean",
            --      },
        }
    }
}

-- Get the SIP highest priority device
local function getSipDevice(name)
    local device = ""
    local priority = 65535

    uci_helper.foreach_on_uci(outgoing_binding, function(s)
        if s.profile and type(s.profile) == "table" then
            for i,v in ipairs(s.profile) do
                if (v == name) then
                    local level = tonumber(s.priority[i])
                    if (priority > level or (priority == level and s.device == "fxs_dev_0")) then
                        device = s.device
                        priority = level
                    end
                    break
                end
            end
        end
    end)
    return device, priority
end

local cvtBoolean = setmetatable({
    ['0'] = '1',
    ['1'] = '0',
}, mt)

local function Convert(value)
    return cvtBoolean[value]
end

local call_common_default = setmetatable({
    CallerIDEnable = "1",
    CallerIDNameEnable = "1",
    AnonymousCalEnable = "0",
    CallForwardUnconditionalEnable = "0",
    CallForwardOnBusyEnable = "0",
    CallForwardOnNoAnswerEnable = "0",
    AnonymousCallBlockEnable = "0",
    CallWaitingEnable = "1",
    CallTransferEnable = "1",
    MaxSessions = "2",
}, mt)

local call_sip_net_map = {
    value = {
        CallerIDEnable = {"CLIR", "provisioned", nil, Convert},
        CallerIDNameEnable = {"CLIR", "provisioned", nil, Convert},
        CallerIDName = "display_name",
        CallWaitingEnable = {"CALL_WAITING", "provisioned", true, getSipDevice},
        CallForwardUnconditionalEnable = {"CFU", "provisioned"},
        CallForwardUnconditionalNumber = {"CFU", "destination"},
        CallForwardOnBusyEnable = {"CFBS", "provisioned"},
        CallForwardOnBusyNumber = {"CFBS", "destination"},
        CallForwardOnNoAnswerEnable = {"CFNR", "provisioned"},
        CallForwardOnNoAnswerNumber = {"CFNR", "destination"},
        CallTransferEnable = {"TRANSFER", "provisioned", true, getSipDevice},
        AnonymousCallBlockEnable = {"ACR", "provisioned"},
        AnonymousCalEnable = {"CLIR", "provisioned"},
    },
    default = call_common_default,
}

local call_sip_server_map = {
    value = {
    },
    default = call_common_default,
}

local call_maps = {
    sip_profile = call_sip_net_map,
    sip_dev = call_sip_server_map,
}


local set_call_sip_net_map = {
    -- The value means has destination or not in the service section
    CallerIDEnable = false,
    CallerIDNameEnable = false,
    CallerIDName = false,
    CallWaitingEnable = false,
    CallForwardUnconditionalEnable = true,
    CallForwardUnconditionalNumber = false,
    CallForwardOnBusyEnable = true,
    CallForwardOnBusyNumber = false,
    CallForwardOnNoAnswerEnable = true,
    CallForwardOnNoAnswerNumber = false,
    CallTransferEnable = false,
    AnonymousCallBlockEnable = false,
    AnonymousCalEnable = false,
}
local set_call_sip_server_map = {}

local set_call_maps = {
    sip_profile = set_call_sip_net_map,
    sip_dev = set_call_sip_server_map,
}

local function getCallValue(map, s, param, hasprofile, name)
    local res = nil
    if type(map.value[param]) == "table" then
        local stype = map.value[param][1]
        local option = map.value[param][2]
        local isdevice = map.value[param][3]
        local cb = map.value[param][4]
        if stype == s["type"] then
            res = map.default[param]
            if not isdevice then
                if hasprofile then
                    res = option and s[option] or map.default[param]
                end
                if cb then
                    res = cb(res)
                end
            else
                local device = cb(name)
                if s.device and table.concat(s.device, " "):match(device) then
                    res = s[option]
                end
            end
        end
    end
    return res
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_CallingFeatures_.getall = function(mapping, key, parentkey)
    local config, name, ltype = getInfoFromKey(key, parentkey)
    local map = call_maps[ltype]
    local data = {}
    uci_helper.foreach_on_uci(service_binding, function(s)
        local hasprofile = s.profile and table.concat(s.profile, " "):match(name)
        for p,v in pairs(map.value) do
            if type(v) == "table" then
                data[p] = data[p] or getCallValue(map, s, p, hasprofile)
            end
        end
    end)
    for p,_ in pairs(InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_CallingFeatures_.objectType.parameters) do
        if type(map.value[p]) == "string" then
            binding.config = config
            binding.sectionname = name
            binding.option = map.value[p]
            data[p] = uci_helper.get_from_uci(binding)
        end
        data[p] = data[p] or map.default[p]
    end
    return data
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_CallingFeatures_.get = function(mapping, param, key, parentkey)
    local config, name, ltype = getInfoFromKey(key, parentkey)
    local map = call_maps[ltype]
    local res = map.default[param]
    if type(map.value[param]) == "table" then
        local stype = map.value[param][1]
        local option = map.value[param][2]
        local isdevice = map.value[param][3]
        local cb = map.value[param][4]
        uci_helper.foreach_on_uci(service_binding, function(s)
            if stype == s["type"] then
                if not isdevice then
                    if s.profile and table.concat(s.profile, " "):match(name) then
                        res = option and s[option] or map.default[param]
                    end
                    if cb then
                        res = cb(res)
                    end
                else
                    local device = cb(name)
                    if s.device and table.concat(s.device, " "):match(device) then
                        res = s[option]
                    end
                end
                return false
            end
        end)
    elseif type(map.value[param]) == "string" then
        binding.config = config
        binding.sectionname = name
        binding.option = map.value[param]
        res = uci_helper.get_from_uci(binding)
    end
    return res
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_CallingFeatures_.set = function(mapping, param, value, key, parentkey)
    local config, name, ltype = getInfoFromKey(key, parentkey)
    local map = call_maps[ltype]
    local set_map = set_call_maps[ltype]

    if set_map[param] ~= nil then
        local hasdest = set_map[param]
        if type(map.value[param]) == "string" then
            binding.config = config
            binding.sectionname = name
            binding.option = map.value[param]
            uci_helper.set_on_uci(binding, value, commitapply)
            transactions[binding.config] = true
            return true
        elseif type(map.value[param]) == "table" then
            local stype = map.value[param][1]
            local option = map.value[param][2]
            local isdevice = map.value[param][3]
            local cb = map.value[param][4]

            binding.config = "mmpbx"
            uci_helper.foreach_on_uci(service_binding, function(s)
                binding.sectionname = s['.name']
                if (s["type"] == stype) then
                    binding.option = option
                    if option == "provisioned" then
                        if not isdevice then
                            if s.profile and table.concat(s.profile, " "):match(name) then
                                if cb then
                                    value = cb(value)
                                end
                                uci_helper.set_on_uci(binding, value, commitapply)
                                if hasdest then
                                    if (s["destination"] or s["destination"] == "") then
                                        value = "0"
                                    end
                                end
                                binding.option = "activated"
                                uci_helper.set_on_uci(binding, value, commitapply)
                                transactions[binding.config] = true
                                return false
                            end
                        else
                            local device = cb(name)
                            if s.device and table.concat(s.device, " "):match(device) then
                                uci_helper.set_on_uci(binding, value, commitapply)
                                binding.option = "activated"
                                uci_helper.set_on_uci(binding, value, commitapply)
                                transactions[binding.config] = true
                                return false
                            end
                        end
                    elseif option == "destination" then
                        if s.profile and table.concat(s.profile, " "):match(name) then
                            uci_helper.set_on_uci(binding, value, commitapply)
                            transactions[binding.config] = true
                            return false
                        end
                    end
                end
            end)
        end
        return true
    end
    return nil, "Not supported currently"
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_CallingFeatures_.commit = line_commit
InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_CallingFeatures_.revert = line_revert
register(InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_CallingFeatures_)

local InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_ = {
    objectType = {
        name = "InternetGatewayDevice.Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.Codec.",
        access = "readOnly",
        minEntries = 1,
        maxEntries = 1,
        parameters = {
            --      TransmitCodec = {
            --        access = "readOnly",
            --        type = "string",
            --        max = "64",
            --        enumeration = {
            --          "G.711MuLaw",
            --          "G.711ALaw",
            --          "G.726",
            --          "G.729",
            --          "G.729a",
            --          "G.729e",
            --          "G.728",
            --          "G.723.1",
            --          "G.722",
            --          "G.722.1",
            --          "G.722.2",
            --          "GSM-FR",
            --          "GSM-HR",
            --          "GSM-EFR",
            --          "iLBC",
            --        },
            --      },
            --      ReceiveCodec = {
            --        access = "readOnly",
            --        type = "string",
            --        enumeration = {
            --          "G.711MuLaw",
            --          "G.711ALaw",
            --          "G.726",
            --          "G.729",
            --          "G.729a",
            --          "G.729e",
            --          "G.728",
            --          "G.723.1",
            --          "G.722",
            --          "G.722.1",
            --          "G.722.2",
            --          "GSM-FR",
            --          "GSM-HR",
            --          "GSM-EFR",
            --          "iLBC",
            --        },
            --        max = "64",
            --      },
            --      TransmitBitRate = {
            --        access = "readOnly",
            --        type = "unsignedInt",
            --      },
            --      ReceiveBitRate = {
            --        access = "readOnly",
            --        type = "unsignedInt",
            --      },
            --      TransmitSilenceSuppression = {
            --        access = "readOnly",
            --        type = "boolean",
            --      },
            --      ReceiveSilenceSuppression = {
            --        access = "readOnly",
            --        type = "boolean",
            --      },
            --      TransmitPacketizationPeriod = {
            --        access = "readOnly",
            --        type = "unsignedInt",
            --      },
        }
    }
}

register(InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_)

local InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_List_i_ = {
    objectType = {
        name = "InternetGatewayDevice.Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.Codec.List.{i}.",
        access = "readOnly",
        minEntries = 0,
        maxEntries = math.huge,
        parameters = {
            EntryID = {
                access = "readOnly",
                type = "unsignedInt",
                range = {
                    {
                        min = "1",
                    },
                },
            },
            Codec = {
                access = "readOnly",
                type = "string",
                max = "64",
            },
            BitRate = {
                access = "readOnly",
                type = "unsignedInt",
            },
            --      PacketizationPeriod = {
            --        access = "readWrite",
            --        list = true,
            --        type = "string",
            --        max = "64",
            --      },
            SilenceSuppression = {
                access = "readWrite",
                type = "boolean",
            },
            Enable = {
                access = "readWrite",
                type = "boolean",
                default = "true",
            },
            Priority = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "1",
                    },
                },
                default = "1",
            },
        }
    }
}

local codec_rates = setmetatable({
    PCMU = "64000",
    PCMA = "64000",
    G722 = "64000",
    ["G726-16"] = "16000",
    ["G726-24"] = "24000",
    ["G726-32"] = "32000",
    ["G726-40"] = "40000",
    G729 = "8000",
    G723 = "6300"
}, mt)

local codec_binding = {config = "mmpbx", sectionname = "codec_filter"}
local content_codec = {}

local function getCodecSection(key)
    key = match(key, "^([^_]+)_")
    return content_codec[key] or {}
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_List_i_.entries = function(mapping, parentkey, grandkey)
    local entries = {}
    if grandkey:match("mmpbxrvsipdev") then
        return entries
    end
    local binding = { config = "mmpbx" }
    local flag_codec = false
    local res = uci_helper.foreach_on_uci(codec_binding, function(s)
        -- We need to be backwards compatible: key generation has been updated
        -- to store entryID as _key but the new code has to be able to deal with
        -- the old _key and _entryID fields.
        -- First check if there's a _entryID field and if so assume the old
        -- way of working.
        local entryID = s._entryID or s._key
        if not entryID then
            binding.sectionname = s[".name"]
            entryID = uci_helper.generate_key_on_uci(binding)
            flag_codec = 1
            s._key = entryID
            entries[#entries + 1] = format("%s_%s", entryID, parentkey)
            content_codec[entryID] = s
        else
            entries[#entries + 1] = format("%s_%s", s._key, parentkey)
            content_codec[s._key] = s
        end
    end)
    if flag_codec then
        uci_helper.commit_keys(binding)
    end
    return entries
end


local codec_map = {
    EntryID = function(s)
        return s._entryID or s._key  -- backwards compatibility; see entries()
    end,
    Codec = "name",
    BitRate = function(s)
        return codec_rates[s.name]
    end,
    SilenceSuppression = function(s)
        return cvtBoolean[s.remove_silence_suppression]
    end,
    Enable = "allow",
    Priority = "priority",
}

local set_codec_map = {
    SilenceSuppression = function(binding, value)
        binding.option = "remove_silence_suppression"
        value = cvtBoolean[value]
        uci_helper.set_on_uci(binding, value, commitapply)
    end,
    Enable = true,
    Priority = true,
}

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_List_i_.getall = function(mapping, key)
    local data = {}
    local s = getCodecSection(key)

    for p,_ in pairs(InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_List_i_.objectType.parameters) do
        if codec_map[p] then
            if type(codec_map[p]) == "function" then
                data[p] = codec_map[p](s) or ""
            else
                data[p] = s[codec_map[p]] or ""
            end
        end
    end
    return data
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_List_i_.get = function(mapping, param, key)
    local s = getCodecSection(key)
    if codec_map[param] then
        if type(codec_map[param]) == "function" then
            return codec_map[param](s)
        else
            return s[codec_map[param]]
        end
    end
    return ""
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_List_i_.set = function(mapping, param, value, key)
    local s = getCodecSection(key)
    binding.config = "mmpbx"
    binding.sectionname = s['.name']
    if set_codec_map[param] then
        if type(set_codec_map[param]) == "function" then
            set_codec_map[param](binding, value)
            transactions[binding.config] = true
            return true
        elseif type(codec_map[param]) == "string" then
            binding.option = codec_map[param]
            uci_helper.set_on_uci(binding, value, commitapply)
            transactions[binding.config] = true
            return true
        end
    else
        return nil, "Invalid parameter"
    end
end

InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_List_i_.commit = line_commit
InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_List_i_.revert = line_revert
register(InternetGatewayDevice_Services_VoiceService_i_VoiceProfile_i_Line_i_Codec_List_i_)
