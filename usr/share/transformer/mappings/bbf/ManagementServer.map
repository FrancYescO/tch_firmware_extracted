-- Automatically generated from InternetGatewayDevice:1.14 and Device:2.10
-- using generator version 2.3
local Multi_ManagementServer_ = {
  objectType = {
    name = "#ROOT.ManagementServer.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      EnableCWMP = {
        access = "readWrite",
        type = "boolean",
        default = "true",
      },
      URL = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      Username = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      Password = {
        access = "readWrite",
        hidden = "true",
        type = "string",
        max = "256",
      },
      PeriodicInformEnable = {
        access = "readWrite",
        type = "boolean",
      },
      PeriodicInformInterval = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
          },
        },
      },
      PeriodicInformTime = {
        access = "readWrite",
        type = "dateTime",
      },
      ParameterKey = {
        access = "readOnly",
        activeNotify = "canDeny",
        forcedInform = "true",
        type = "string",
        max = "32",
      },
      ConnectionRequestURL = {
        access = "readOnly",
        activeNotify = "forceDefaultEnabled",
        forcedInform = "true",
        type = "string",
        max = "256",
      },
      ConnectionRequestUsername = {
        access = "readWrite",
        type = "string",
        max = "256",
      },
      ConnectionRequestPassword = {
        access = "readWrite",
        hidden = "true",
        type = "string",
        max = "256",
      },
      AliasBasedAddressing = {
        access = "readOnly",
        forcedInform = "true",
        type = "boolean",
      },
      DefaultActiveNotificationThrottle = {
        access = "readWrite",
        type = "unsignedInt",
      },
      UpgradesManaged = {
        access = "readWrite",
        type = "boolean",
      },
      SupportedConnReqMethods = {
        access = "readOnly",
        list = true,
        type = "string",
        enumeration = {
          "HTTP",
          "STUN",
          "XMPP",
        },
      },
      ConnReqXMPPConnection = {
        access = "readWrite",
        type = "string",
        pathRef = true,
        targetParent = "Device.XMPP.Connection.{i}.",
      },
      ConnReqAllowedJabberIDs = {
        access = "readWrite",
        list = true,
        maxItems = "32",
        type = "string",
        max = "256",
      },
      ConnReqJabberID = {
        access = "readOnly",
        activeNotify = "forceDefaultEnabled",
        type = "string",
      },
      X_000E50_DelayUpgrade = {
        access = "readWrite",
        type = "boolean",
        description = "If true no automatic switchover is done when a new firmware is installed; an explicit trigger needs to be given."
      },
      X_000E50_Interface = {
        access = "readWrite",
        type = "string",
        pathRef = true,
        targetParent = "Device.IP.Interface.{i}.",
        description = "Allows to configure the network interface to be used for cwmp."
      },
      ManageableDeviceNotificationLimit = {
        access = "readWrite",
        type = "unsignedInt",
      },
      CWMPRetryIntervalMultiplier = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1000",
            max = "65535",
          },
        },
      },

      CWMPRetryMinimumWaitInterval = {
        access = "readWrite",
        type = "unsignedInt",
        range = {
          {
            min = "1",
            max = "65535",
          },
        },
      },
      X_000E50_LastConnectionTime = {
        access = "readOnly",
        type = "string",
        description = "The last time an attempt was made to setup a TR-069 session in format, Wed Jan 25 14:05:53 2017."
      },
    }
  }
}

local cwmpOption = {
  ["EnableCWMP"] = "state",
  ["URL"] = "acs_url",
  ["Username"] = "acs_user",
  ["Password"] = "acs_pass",
  ["PeriodicInformEnable"] = "periodicinform_enable",
  ["PeriodicInformInterval"] = "periodicinform_interval",
  ["PeriodicInformTime"] = "periodicinform_time",
  ["ParameterKey"] = "parameter_key",
  ["DefaultActiveNotificationThrottle"] = "activenotification_throttle",
  ["UpgradesManaged"] = "upgradesmanaged",
  ["ConnectionRequestURL"] = "connectionrequest_url",
  ["ConnectionRequestUsername"] = "connectionrequest_username",
  ["ConnectionRequestPassword"] = "connectionrequest_password",
  ["ConnReqJabberID"] = "xmpp_jabberid",
  ["ConnReqAllowedJabberIDs"] = "xmpp_acs_jabberids",
  ["X_000E50_DelayUpgrade"] = "upgrade_switchovertype",
  ["ManageableDeviceNotificationLimit"] = "manageabledevice_notification_limit",
  ["CWMPRetryIntervalMultiplier"] = "backoff_multiplier",
  ["CWMPRetryMinimumWaitInterval"] = "backoff_minwait",
  ["X_000E50_Interface"] = "interface",
  ["X_000E50_ConnectionRequestAllowedIPs"] = "connectionrequest_allowedips",
}

local mapper = mapper
local os = os
local tonumber = tonumber
local pairs = pairs
local next = next
local uciHelper = mapper("ucihelper")
local getFromUci = uciHelper.get_from_uci
local cwmpBinding = {config = "cwmpd", sectionname = "cwmpd_config"}
local transactions = {}
local uci = require("uci")
local find, sub, gmatch = string.find, string.sub, string.gmatch
local inet = require("tch.inet")
local crypto = require("tch.simplecrypto")
local posix = require("tch.posix")
local clock_gettime = posix.clock_gettime
local CLOCK_MONOTONIC = posix.CLOCK_MONOTONIC

local function getManageableDeviceNotificationLimit(param)
  cwmpBinding.option = cwmpOption[param]
  local value = getFromUci(cwmpBinding)
  return value ~= "" and value or "0"
end

local function getInterface(param)
  cwmpBinding.option = cwmpOption[param]
  local intf = getFromUci(cwmpBinding)
  local result = resolve('Device.IP.Interface.{i}.', intf)
  if not result then
    local mobileIface = intf:match("(.*)_4$")
    if mobileIface then
      result = resolve('Device.IP.Interface.{i}.', mobileIface)
    end
  end
  return result or ""
end

local function removeFromState(option)
  local cursor = uci.cursor(nil,"/var/state") -- Can not use ucihelper, because it does not contain this kind of cursor.
  cursor:revert("cwmpd", "cwmpd_config", option)
  cursor:close()
end

local function getLastConnectionTime(param)
  local last_connection_time
  cwmpBinding.option = cwmpOption[param]
  local last_session_try_time = tonumber(getFromUci(cwmpBinding))

  if last_session_try_time then
    local current_mono_time = clock_gettime(CLOCK_MONOTONIC)
    local current_real_time = clock_gettime(posix.CLOCK_REALTIME)
    local session_try_real_time = current_real_time - (current_mono_time - last_session_try_time)
    last_connection_time = os.date("%c", session_try_real_time)
  end
  return last_connection_time or ""
end

local function getPeriodicInformTime(param)
  cwmpBinding.option = cwmpOption[param]
  local value = getFromUci(cwmpBinding)
  value = value ~= "" and tonumber(value)
  return value and os.date("!%Y-%m-%dT%H:%M:%SZ", value) or "0001-01-01T00:00:00Z"
end

-- Returns the number of seconds that must be added to local time to yield UTC
local function getUtcOffset(timestamp)
  local dateWithTZ = os.date("*t", timestamp)
  local dateUTC = os.date("!*t", timestamp)
  -- The timestamp may correspond where DST is in effect and we must compensate for this by resetting the isdst flag.
  dateWithTZ.isdst = false
  return os.difftime(os.time(dateUTC), os.time(dateWithTZ))
end

local function setPeriodicInformTime(value)
  local date = {}
  date.year, date.month, date.day, date.hour, date.min, date.sec = value:match("(%d+)%-(%d+)%-(%d+)T(%d+):(%d+):(%d+)%.?%d*Z")
  -- os.time() yields epoch corresponding to date, as if date were in local time, but we accept it in UTC.
  -- Hence, it will have an offset corresponding to the timezone the machine is configured to.
  local epochWithOffset = os.time(date)
  -- PeriodicInformTime is received and stored in UTC: apply the calculated UTC offset to compensate the offset introduced by os.time()
  return epochWithOffset - getUtcOffset(epochWithOffset)
end

Multi_ManagementServer_.get = function(mapping, param)
  if param == "PeriodicInformTime" then
    return getPeriodicInformTime(param)
  elseif param == "AliasBasedAddressing" then
    return "0"
  elseif param == "X_000E50_LastConnectionTime" then
    return getLastConnectionTime(param)
  elseif param == "X_000E50_Interface" then
    return getInterface(param)
  elseif param == "ManageableDeviceNotificationLimit" then
    return getManageableDeviceNotificationLimit(param)
  elseif param == "SupportedConnReqMethods" then
    return "HTTP,XMPP"
  elseif param == "ConnReqXMPPConnection" then
    return "Device.XMPP.Connection.1"
  elseif param == "NATDetected" then
    return "0"
  end
  local default
  if param == "X_000E50_DelayUpgrade" then
    default = "0"
  end
  cwmpBinding.option = cwmpOption[param]
  return getFromUci(cwmpBinding)
end

-- A getall implementation is not done as it will not bring any improvement

Multi_ManagementServer_.set = function(mapping, param, value)
  local errMsg
  if param == "PeriodicInformTime" then
    value, errMsg = setPeriodicInformTime(value)
    if not value then
      return nil, errMsg
    end
  end

  if param == "Password" or param == "ConnectionRequestPassword" then
    cwmpBinding.option = "encrypt_passwords"
    local encryptPasswords = getFromUci(cwmpBinding)
    if encryptPasswords == "1" then
      value, errMsg = crypto.encrypt(value, crypto.AES_256_CBC)
      if not value then
        return nil, errMsg
      end
    end
  end
 if param == "X_000E50_Interface" then
    local rc
    rc, value = pcall(tokey, value, "Device.IP.Interface.{i}.")
    if not rc then
      return nil, "Invalid value"
    end
  end
  if param == "ConnReqXMPPConnection" then
    if value == "Device.XMPP.Connection.1" then
      return;
    else
      return nil, "Invalid value"
    end
  end

  cwmpBinding.option = cwmpOption[param]
  uciHelper.set_on_uci(cwmpBinding, value, commitapply)
  transactions[cwmpBinding.option] = true
end

Multi_ManagementServer_.commit = function()
  if next(transactions) then
    for option in pairs(transactions) do
      removeFromState(option)
    end
    uciHelper.commit(cwmpBinding)
    transactions = {}
  end
end

Multi_ManagementServer_.revert = function()
  if next(transactions) then
    uciHelper.revert(cwmpBinding)
    transactions = {}
  end
end
local lastTime = 0
local function ubus_event_cb(mapping, event, data)
  local notificationLimit = getManageableDeviceNotificationLimit("ManageableDeviceNotificationLimit")
  notificationLimit = tonumber(notificationLimit)

  if not notificationLimit then
    notificationLimit = 0
  end

  local currentTime = os.time()
  if currentTime - lastTime >= notificationLimit then
    lastTime = currentTime
    return { { key = "", paramname = "ManageableDeviceNumberOfEntries" } }
  end
end

local function ubus_xmpp_cb(mapping, event, data)
  if data.jabberid then
    return { { key = "", paramname = "ConnReqJabberID" } }
  end
end

local function translate_cb(mapping, action, config, sectiontype, sectionname, option)
  return { { key = "", paramname = "PeriodicInformInterval" } }
end

Multi_ManagementServer_.add_watchers = function(mapping)
  local eventSource = eventsource
  local uciEventsrc = eventSource("uci")
  uciEventsrc.watch(mapping, { set = translate_cb }, "cwmpd", nil, "cwmpd_config", "periodicinform_interval")

  local ubusEventsrc = eventSource("ubus")
  ubusEventsrc.watch_event(mapping, ubus_event_cb, "hostmanager.devicechanged")
  ubusEventsrc.watch_event(mapping, ubus_xmpp_cb, "cwmpd.xmpp")
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Multi_ManagementServer_, "#ROOT", {"InternetGatewayDevice", "Device"})
for _, dupli in ipairs(duplicates) do
  register(dupli)
end
