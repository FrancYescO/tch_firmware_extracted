local conn = mapper("ubus").connect()
local uci_helper = mapper("ucihelper")
local gsub, sub, match, len, find = string.gsub, string.sub, string.match, string.len, string.find

local mmpbx = {
    objectType = {
        name = "rpc.mmpbx.",
        access = "readOnly",
        minEntries = 1,
        maxEntries = 1,
        parameters = {
            resetCallStats = {
                access = "readWrite",
                type = "boolean",
                default = "false",
            },
            state = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "STARTING",
                    "RUNNING",
                    "STOPPING",
                    "NA",
                },
                default = "NA",
            },
            mode = {
                access = "readOnly",
                type = "string",
                enumeration = {
                    "SIP",
                    "PSTN",
                    "Unknown",
                },
                default = "Unknown",
            },
            DigitMap = {
                access = "readWrite",
                type = "string",
                max = "2048",
                default = "",
            },
            DigitMapEnable = {
                access = "readWrite",
                type = "boolean",
                default = "false",
            },
            TelephoneEventPayloadType = {
                access = "readWrite",
                type = "unsignedInt",
                range = {
                    {
                        min = "0",
                        max = "128",
                    },
                },
            },
        },
    }
}

local voiceHelper = require("transformer.shared.voice_helper")
local digitmapHelper = require("transformer.shared.digitmap_helper")
local mmpbxBinding = { config = "mmpbx" }
local configChanged
local transactions = {}

local function getFromUci(section, option, default)
    mmpbxBinding.sectionname = section
    mmpbxBinding.option = option
    mmpbxBinding.default = default
    return uci_helper.get_from_uci(mmpbxBinding)
end

local function setOnUci(section, option, value)
    if value then
        mmpbxBinding.sectionname = section
        mmpbxBinding.option = option
        uci_helper.set_on_uci(mmpbxBinding, value, commitapply)
    else
        mmpbxBinding.sectionname = section
        mmpbxBinding.option = nil
        uci_helper.set_on_uci(mmpbxBinding, option, commitapply)
    end
    configChanged = true
end

local function set(mapping, paramname, paramvalue, key)
    if paramname == "DigitMap" then
        local digitMapState = getFromUci("dial_plan_generic", "digit_map", "0")
        if digitMapState == "1" then
            if digitmapHelper.validateDigitMapString(paramvalue) then
                if digitmapHelper.setDigitMap(paramname, paramvalue, transactions, commitapply) then
                    configChanged = true
                    return
                end
            else
                return nil, "Invalid DigitMap String"
            end
        end
        return nil, "DigitMap is not supported"
    elseif paramname == "DigitMapEnable" then
        setOnUci("dial_plan_generic", "digit_map", paramvalue)
        if paramvalue == "1" then
            setOnUci("dial_plan_generic", "no_match_action", "reject")
        else
            setOnUci("dial_plan_generic", "no_match_action", "allow")
        end
        return true
    elseif paramname == "TelephoneEventPayloadType" then
        if voiceHelper.setPayLoadType(paramvalue, transactions, commitapply) then
            configChanged = true
        end
    end
    conn:call("mmpbx.profile.stats", "reset", {})
    conn:call("mmpbx.device.stats", "reset", {})
    return nil
end

mmpbx.get = {
    resetCallStats = "false",
    state = function(mapping, paramName, key)
        return uci_helper.get_from_uci({config="mmpbx", sectionname="state"})
    end,
    mode = function(mapping, paramName, key)
        local res = "Unknown"
        local fxsrelay_state = uci_helper.get_from_uci({config="mmpbxbrcmfxsdev", sectionname="fxs_dev_0", option="relay_state"})
        local fxonet_state = uci_helper.get_from_uci({config="mmpbxbrcmfxonet", sectionname="fxo_profile", option="enabled"})
        if fxsrelay_state == "0" and fxonet_state == "1" then
            res = "PSTN"
        elseif fxsrelay_state == "1" and fxonet_state == "0" then
            res = "SIP"
        end
        return res
    end,
    DigitMap = function(mapping, paramName, key)
        local digitMapState = getFromUci("dial_plan_generic", "digit_map", "0")
        if digitMapState == "1" then
            return digitmapHelper.getDigitMap()
        else
            return ""
        end
    end,
    DigitMapEnable = function(mapping, paramName, key)
        return getFromUci("dial_plan_generic", "digit_map", "0")
    end,
    TelephoneEventPayloadType = voiceHelper.getPayLoadType
}

local function revert()
    if configChanged then
        uci_helper.revert(mmpbxBinding)
    end
    configChanged = false
end

local function commit()
    if configChanged then
        uci_helper.commit(mmpbxBinding)
    end
    configChanged = false
end

mmpbx.set = set
mmpbx.revert = revert
mmpbx.commit = commit
register(mmpbx)
