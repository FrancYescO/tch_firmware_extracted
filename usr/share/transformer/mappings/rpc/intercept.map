local intercept_ = {
    objectType = {
        name = 'rpc.intercept.',
        access = 'readOnly',
        minEntries = 1,
        maxEntries = 1,
        parameters = {
            enabled = {
                access = "readWrite",
                type = "boolean"
            },
            active = {
                access = "readOnly",
                type = "boolean"
            },
            mobiledIntercept = {
                access = "readWrite",
                type = "boolean"
            }
        }
    }
}

local conn = mapper("ubus").connect()
if not conn then
    return nil, "Failed to connect to UBUS"
end

local mobiledIntercept = "1"
local uciHelper = mapper("ucihelper")
local enableBinding = { config="intercept", sectionname="config", option="enabled" }

function intercept_.getall(mapping)
    local ubus_data = conn:call("intercept", "status", {}) or {}
    local data = { active = "0" }
    local enabled = uciHelper.get_from_uci(enableBinding)
    data.enabled = enabled ~= "" and enabled or "1"
    if ubus_data.active then
        data.active = tostring(ubus_data.active)
    end
    return data
end

function intercept_.get(mapping, paramName)
    return intercept_.getall(mapping)[paramName] or ""
end

function intercept_.set(mapping, paramName, value)
    if paramName == "enabled" then
        uciHelper.set_on_uci(enableBinding, value, commitapply)
        commitapply:newset("rpc.intercept.enabled")
    end
    if paramName == "mobiledIntercept" and value == "0" then
        conn:call("intercept", "del_reason", {reason = "mobiled_up"})
        mobiledIntercept = value
    end
end

function intercept_.commit()
    uciHelper.commit({config = "intercept"})
end

function intercept_.revert()
    uciHelper.revert({config = "intercept"})
end

register(intercept_)