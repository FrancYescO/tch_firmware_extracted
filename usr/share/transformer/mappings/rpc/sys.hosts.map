local require = require
local register = register
local table, pairs, tostring, error = table, pairs, tostring, error
local string = string
local popen = io.popen
local nwcommon = mapper("nwcommon")

-- sys.hosts
local Sys_Hosts_ = {
  objectType = {
    name = "sys.hosts.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      WirelessNumberOfEntries = {
        access = "readOnly",
        type = "unsignedInt",
      },
      EthernetNumberOfEntries = {
        access = "readOnly",
        type = "unsignedInt",
      },
      ActiveWirelessNumberOfEntries = {
        access = "readOnly",
        type = "unsignedInt",
      },
      ActiveEthernetNumberOfEntries = {
        access = "readOnly",
        type = "unsignedInt",
      },
    }
  }
}
-- Open connection to UBUS
local conn = mapper("ubus").connect()
--Returns true if the interface was found in the list of interfaces
local function isInterfaceInList(interfaces, interface)
    if (interfaces == nil) then
      error("Interfaces list is nil")
    end
    for _, intf in pairs(interfaces) do
        if interface == intf then
           return true
        end
    end
    return false
end

--These will cache the lan/wan interfaces, based on the firewall config
local lanInterfacesCache
local wanInterfacesCache

-- Uses the cached list. Make sure to update lanInterfacesCache (only) when needed
local function isLanInterface(interface)
        return isInterfaceInList(lanInterfacesCache, interface)
end

-- false for lan, true for wan, nil for unknown
-- Uses the cached lists. Make sure to update lanInterfacesCache (only) when needed
local function getInterfaceZoneType(interface)
    --Check if it's LAN
    if (isInterfaceInList(lanInterfacesCache, interface)) then
        return false
    end
    --Check if it's WAN
    if (isInterfaceInList(wanInterfacesCache, interface)) then
        return true
    end
    return nil
end

local function getExternalWifiIntfType(devices)
  local wirelessRadio = conn:call("wireless.radio", "get" , {})
  local keyValue
  local intfType=""
  local  macAddr=""
  local isRemmanAndIntegrAp = false
  if (wirelessRadio == nil) then
    return intfType, macAddr
  end
  for e, f in pairs(wirelessRadio) do
    if f["remotely_managed"] == 1 and f["integrated_ap"] == 1 then
      keyValue = e
      isRemmanAndIntegrAp = true
      break
    end
  end
  if (keyValue) then
    local ssid = conn:call("wireless.ssid", "get", {})
    if (ssid == nil) then
      return intfType, macAddr
    end
    for _,l in pairs(ssid) do
      if l["radio"] == keyValue then
        local result = ("0x" .. string.sub(l["mac_address"],(#l["mac_address"] -1)))
        local obtMacAddr = string.format("%02x",((result -1)%256))
        macAddr= string.gsub(l["mac_address"],(string.sub(l["mac_address"],(#l["mac_address"] -1))),obtMacAddr)
      end
      -- In case the ssid is remotely managed, integrated and disabled, the received macaddress via wireless.ssid  is 0,
      -- then we need to get the mac via wireless.radio.remote
      if ((macAddr == "ff:ff:ff:ff:ff:ff" ) and isRemmanAndIntegrAp ) then
        local radioremote = conn:call("wireless.radio.remote", "get", { name = keyValue })
        if radioremote then
          local _, l = next(radioremote)
          if l then
            macAddr = l["macaddr"]
          end
        end
      end
    end
    devices = devices or conn:call("hostmanager.device" ,"get", {})
    for _,w in pairs(devices) do
      if w["mac-address"] == macAddr then
        intfType= w["l2interface"]
      end
    end
  end
  return intfType, macAddr
end

local hostsCache
--Updates the host cache and LAN interface cache
local function updateLanCache()
    --Update the hosts cache from hostmanager
    hostsCache = conn:call("hostmanager.device", "get", {})
    if hostsCache == nil then
      error("retrieving hosts failed")
    end
    --Update the lan interfaces cache
    lanInterfacesCache = nwcommon.findLanWanInterfaces(false)
end

local function getWirelessNumberOfEntries(mapping)
    if (mapping) then
        updateLanCache()
    end
    local numberOfHosts = 0
    local intfType, macAddr = getExternalWifiIntfType(hostsCache)
    for _, v in pairs(hostsCache) do
      if ((v["technology"] == "wireless" and isLanInterface(v["interface"])) or
          (v["mac-address"] ~= macAddr and v["technology"] == "ethernet" and v["l2interface"] == intfType)) then
        numberOfHosts = numberOfHosts + 1
      end
    end
    return tostring(numberOfHosts)
end

local function getEthernetNumberOfEntries(mapping)
    if (mapping) then
        updateLanCache()
    end
    local numberOfHosts = 0
    local intfType, macAddr = getExternalWifiIntfType(hostsCache)
    for _, v in pairs(hostsCache) do
      if v["technology"] == "ethernet" and isLanInterface(v["interface"])  and  (v["l2interface"] ~= intfType and v["mac-address"] ~= macAddr) then
        numberOfHosts = numberOfHosts + 1
      end
    end
    return tostring(numberOfHosts)
end

local function getActiveWirelessNumberOfEntries(mapping)
    if (mapping) then
        updateLanCache()
    end
    local numberOfHosts = 0
    local intfType, macAddr = getExternalWifiIntfType(hostsCache)
    for _, v in pairs(hostsCache) do
      if v["state"] == "connected" and ((v["technology"] == "wireless" and isLanInterface(v["interface"])) or (v["mac-address"] ~= macAddr and v["technology"] == "ethernet" and v["l2interface"] == intfType)) then
        numberOfHosts = numberOfHosts + 1
      end
    end
    return tostring(numberOfHosts)
end

local function getActiveEthernetNumberOfEntries(mapping)
    if (mapping) then
        updateLanCache()
    end
    local numberOfHosts = 0
    local intfType, macAddr = getExternalWifiIntfType(hostsCache)
    for _, v in pairs(hostsCache) do
      if v["technology"] == "ethernet" and  isLanInterface(v["interface"]) and (v["l2interface"] ~= intfType and v["mac-address"] ~= macAddr) and v["state"] == "connected" then
        numberOfHosts = numberOfHosts + 1
      end
    end
    return tostring(numberOfHosts)
end

Sys_Hosts_.get = {
  WirelessNumberOfEntries = getWirelessNumberOfEntries,
  EthernetNumberOfEntries = getEthernetNumberOfEntries,
  ActiveWirelessNumberOfEntries = getActiveWirelessNumberOfEntries,
  ActiveEthernetNumberOfEntries = getActiveEthernetNumberOfEntries
}

local all_values = {}
Sys_Hosts_.getall = function()
  --Update the interfaces and hosts cache
  updateLanCache()
  all_values["WirelessNumberOfEntries"] = getWirelessNumberOfEntries()
  all_values["EthernetNumberOfEntries"] = getEthernetNumberOfEntries()
  all_values["ActiveWirelessNumberOfEntries"] = getActiveWirelessNumberOfEntries()
  all_values["ActiveEthernetNumberOfEntries"] = getActiveEthernetNumberOfEntries()
  return all_values
end

register(Sys_Hosts_)

-- sys.hosts.host.{i}
local Sys_Hosts_Host_i_ = {
  objectType = {
    name = "sys.hosts.host.{i}.",
    access = "readOnly",
    numEntriesParameter = "HostNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      IPAddress = {
        access = "readOnly",
        type = "string",
      },
      MACAddress = {
        access = "readOnly",
        type = "string",
      },
      HostName = {
        access = "readOnly",
        type = "string",
        max = "64",
      },
      InterfaceType = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "Ethernet",
          "USB",
          "802.11",
          "HomePNA",
          "HomePlug",
          "Other",
        }
      },
      FirewallZone = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "LAN",
          "WAN",
          "Unknown"
        }
      },
      ConnectedTime = {
         access = "readOnly",
         type = "string",
      },
      L2Interface = {
         access = "readOnly",
         type = "string",
      },
      L3Interface = {
         access = "readOnly",
         type = "string",
      },
      State = {
        access = "readOnly",
        type = "boolean",
      },
      Port = {
        access = "readOnly",
        type = "string",
      },
      Speed = {
         access = "readOnly",
         type = "string",
      },
      Priority = {
        access = "readWrite",
        type = "boolean",
      },
    }
  }
}

-- Convert a device key to device information
local function key2dev(key)
  local device = conn:call("hostmanager.device", "get", { ["mac-address"] = key })
  -- only one entry should be present
  for _,v in pairs(device) do
    return v
  end
end

-- Extract an IP address from the given value and add it to the list
local function extractAddress(value, addresses)
  if value["state"] == "connected" then
    if addresses == "" then
      addresses = value["address"]
    else
      addresses = addresses .. " " .. value["address"]
    end
  end
  return addresses
end

Sys_Hosts_Host_i_.entries = function(mapping)
  --Update the interfaces and hosts cache - every time someone starts iteration on the hosts
  updateLanCache()
  wanInterfacesCache = nwcommon.findLanWanInterfaces(true)
  local _, macAddr = getExternalWifiIntfType(hostsCache)
  local Hosts = {}

  for _, v in pairs(hostsCache) do
    if (v["technology"] == "wireless" or v["technology"] == "ethernet") and (v["mac-address"] ~= macAddr)  then
        Hosts[#Hosts+1] = v["mac-address"]
    end
  end
  return Hosts
end

local function extractIPAddresses(dev)
    local addresses = ""
    if dev ~= nil then
        -- Extract IPv4 addresses
        if dev["ipv4"] ~= nil then
            for _,value in pairs(dev["ipv4"]) do
                addresses = extractAddress(value, addresses)
            end
        end
        -- Extract IPv6 addresses
        if dev["ipv6"] ~= nil then
            for _,value in pairs(dev["ipv6"]) do
                addresses = extractAddress(value, addresses)
            end
        end
    end
    return addresses
end

local function extractHostName(dev)
    if dev ~= nil and dev["hostname"] ~= nil then
        return dev["hostname"]
    end
    return ""
end

local function extractInterfaceType(dev)
   local intfType, macAddr = getExternalWifiIntfType()
   if dev["mac-address"] ~= macAddr and dev["l2interface"] == intfType then
      return "wireless"
   else
        return dev["technology"]
    end
    return ""
end

local function extractFirewallZone(dev)
    local isWan = getInterfaceZoneType(dev["interface"])
    if isWan == nil then
        return "Unknown"
    end
    if ( isWan == false) then
        return "LAN"
    end
    return "WAN"
end

local function extractConnectedTime(dev)
    if dev["connected_time"] ~= nil then
        return tostring(dev["connected_time"])
    end
    return ""
end

local function extractL2Interface(dev)
   local intfType, macAddr = getExternalWifiIntfType()
   if dev["mac-address"] ~= macAddr and dev["l2interface"] == intfType then
     return "wl1"
   else
     return dev["l2interface"]
   end
    return ""
end

local function extractl3interface(dev)
    if dev["l3interface"] ~= nil then
        return dev["l3interface"]
    end
    return ""
end

local function extractState(dev)
    if dev["state"] == "connected" then
        return "1"
    end
    return "0"
end

local function extractPort(dev)
    -- [CL] Some platforms don't have l2interfaces that make sense (e.g. without switch driver)
    -- [CL] If the device in the hostmanager ubus call knows what port a device is attached to, let's trust it
    -- [CL] Hacking this into the generic sys.hosts.map file until someone can explain me how to properly customize this without
    -- [CL] copying the entire file and hence losing all future functionality/bugfixes since noone looks at our platforms anyway.
    local intfType, macAddr = getExternalWifiIntfType()
    if dev["switchport"] ~= nil then
        return tostring(dev["switchport"])
    else
        if dev["technology"] == "ethernet" and isLanInterface(dev["interface"]) and dev["l2interface"] == intfType and dev["mac-address"] ~= macAddr then
           return ""
       elseif dev["technology"] == "ethernet" and isLanInterface(dev["interface"]) and dev["l2interface"] ~= nil then
           local portNumber = string.match(dev["l2interface"],"%a*(%d+)")
           if portNumber ~= nil then
               portNumber = portNumber + 1
               return tostring(portNumber)
           end
           return ""
       end
       return ""
    end
end

local function getInterfaceState(l2interface)
    local log = popen("/usr/bin/ethctl " .. l2interface .. " media-type 2>&1")
    if log == nil then
        return ""
    end
    local speed
    local logString = log:read("*a")
    if logString then
       speed = string.match(logString, "%d+") -- Only numbers present
    end
    log:close()
    return speed or ""
end

local function extractSpeed(dev)
    if dev["technology"] == "wireless" then
        if dev["wireless"] and dev["wireless"]["tx_phy_rate"] ~= nil then
            return tostring(dev["wireless"]["tx_phy_rate"] / 1000)
        end
        return ""
    elseif dev["technology"] == "ethernet" then
        if dev["l2interface"] ~= nil and dev["l2interface"] ~= "" then
            return getInterfaceState(dev["l2interface"])
        elseif dev["l3interface"] ~= nil then
            return getInterfaceState(dev["l3interface"])
        end
        return ""
    end
    return ""
end

local uciHelper = mapper("ucihelper")
local get_from_uci = uciHelper.get_from_uci
local set_on_uci = uciHelper.set_on_uci
local foreach_on_uci = uciHelper.foreach_on_uci
local delete_on_uci = uciHelper.delete_on_uci
local commit = uciHelper.commit
local revert = uciHelper.revert

local gsub = string.gsub
local function getPriority(key)
  local qos_binding = { config = "qos"}
  qos_binding.sectionname = "host" .. gsub(key,"%W","")
  qos_binding.option = "priority"
  qos_binding.default = "0"
  return get_from_uci(qos_binding)
end

Sys_Hosts_Host_i_.getall = function(mapping, key)
    local dev = key2dev(key)
    return {
        MACAddress = key,
        IPAddress = extractIPAddresses(dev),
        HostName = extractHostName(dev),
        InterfaceType = extractInterfaceType(dev),
        FirewallZone = extractFirewallZone(dev),
        ConnectedTime = extractConnectedTime(dev),
        L2Interface = extractL2Interface(dev),
        L3Interface = extractl3interface(dev),
        State = extractState(dev),
        Port = extractPort(dev),
        Speed = extractSpeed(dev),
        Priority = getPriority(key),
    }
end

local transactions = {}

Sys_Hosts_Host_i_.set = {
  -- Set function for "Priority" param
  Priority = function(mapping, param, value, key)
    local qos_binding = {config = "qos"}
    local dhcp_binding = {config ="dhcp", sectionname = "host"}
    local mac_without_colon = gsub(key,"%W","")
    local qossectionname = "mac" .. mac_without_colon
    if value == "1" then

      -- STEP FOLLOWED IN BELOW CODE
      -- 1. Check whether "gaming" class available or not.
      -- 2. If class not available, create "gaming" class with the priority=1 and weight=52.
      -- 3. Create the host entry, set the priority to 1
      -- 4. Add the reclassify entry in the "qos" configuration with the source IP address

      -- START --
      -- Check the existing gaming class availale or not
      qos_binding.sectionname = "gamingpriority"
      local qos_gaming_class_data = get_from_uci(qos_binding)
      -- If not available, create the new class and add it to the "TO_WAN" class group.
      if qos_gaming_class_data == "" then

        qos_binding.sectionname = "gamingpriority"
        set_on_uci(qos_binding,"class",commitapply)

        qos_binding.option = "priority"
        set_on_uci(qos_binding,"1",commitapply)

        qos_binding.option = "weight"
        set_on_uci(qos_binding,"52",commitapply)

        qos_binding.sectionname = "TO_WAN"
        qos_binding.option = "classes"

        local qos_classgroup_data = get_from_uci(qos_binding)
        qos_classgroup_data = qos_classgroup_data .. " gamingpriority"
        set_on_uci(qos_binding,qos_classgroup_data,commitapply)
      end
      -- Set the "priority" to "1".
      qos_binding={ config= "qos" }
      qos_binding.sectionname = "host" .. mac_without_colon
      set_on_uci(qos_binding,"host",commitapply)

      qos_binding.option="priority"
      set_on_uci(qos_binding,value,commitapply)

      qos_binding.option="mac"
      set_on_uci(qos_binding,key,commitapply)

      local srchost
      qos_binding={ config= "qos" }
      qossectionname =  "mac" .. mac_without_colon
      qos_binding.sectionname = qossectionname
      local qos_entry = get_from_uci(qos_binding)
      -- Setting "qos" configurations
      local dev = key2dev(key)
      -- Extract first IPv4 address
      if dev["ipv4"] ~= nil then
        for _,value in pairs(dev["ipv4"]) do
          if value["state"] == "connected" then
            srchost = value["address"]
            break
          end
        end
      end
      if qos_entry == "" then
        if srchost then

          qos_binding.sectionname = qossectionname
          set_on_uci(qos_binding,"reclassify",commitapply)

          qos_binding.option="srchost"
          set_on_uci(qos_binding,srchost,commitapply)

          -- Point this "reclassify" to the "gamingpriority" class which we created.
          qos_binding.option="target"
          set_on_uci(qos_binding,"gamingpriority",commitapply)
        end
      end
      transactions[qos_binding.config] = true
      local static_lease_binding_found = false
      -- Limitation: If static lease removed by GUI, then there will be issue when the Gaming device is rebooted and got different IP address.
      foreach_on_uci(dhcp_binding,function(s)
        if s["mac"] == key and s["ip"] == srchost then  -- Not checking the owner, already user via gui or other applications might have added static lease
          static_lease_binding_found = true
        end
      end)
      if not static_lease_binding_found then
        local result, err = uciHelper.add_on_uci(dhcp_binding)
        if result then
          local dhcp_binding_set = {config = "dhcp", sectionname=result , option = "mac"}
          set_on_uci(dhcp_binding_set,key,commitapply)

          dhcp_binding_set.option = "ip"
          set_on_uci(dhcp_binding_set,srchost, commitapply)

          dhcp_binding_set.option = "owner"
          set_on_uci(dhcp_binding_set,"gamingdevice", commitapply)

          transactions[dhcp_binding.config] = true
        end
      end
      -- END --
    else
      -- Delete the entries "qos" configuration.
      -- Not deleting the "gamingpriority" class which may be used by another device.
      local qos_delete_binding={ config = "qos" }
      qos_delete_binding.sectionname="host" .. mac_without_colon
      delete_on_uci(qos_delete_binding,commitapply)
      qos_delete_binding.sectionname="mac" .. mac_without_colon
      delete_on_uci(qos_delete_binding,commitapply)
      transactions[qos_binding.config] = true
      local dhcp_delete
      foreach_on_uci(dhcp_binding, function(s)
        if s["owner"] == "gamingdevice" and s["mac"] == key then
          dhcp_delete = s[".name"]
        end
      end)
      if dhcp_delete then
        local dhcp_binding_delete = {config="dhcp", sectionname = dhcp_delete}
        delete_on_uci(dhcp_binding_delete,commitapply)
        transactions[dhcp_binding.config] = true
      end
    end
  end,
}

Sys_Hosts_Host_i_.get = {
  IPAddress = function(mapping, param, key)
    local dev = key2dev(key)
    return extractIPAddresses(dev)
  end,
  MACAddress = function(mapping, param, key)
    return key
  end,
  HostName = function(mapping, param, key)
    local dev = key2dev(key)
    return extractHostName(dev)
  end,
  InterfaceType = function(mapping, param, key)
    local dev = key2dev(key)
    return extractInterfaceType(dev)
  end,
  FirewallZone = function(mapping, param, key)
    local dev = key2dev(key)
    return extractFirewallZone(dev)
  end,
  ConnectedTime = function(mapping, param, key)
    local dev = key2dev(key)
    return extractConnectedTime(dev)
  end,
  L2Interface = function(mapping, param, key)
    local dev = key2dev(key)
    return extractL2Interface(dev)
  end,
  L3Interface = function(mapping, param, key)
    local dev = key2dev(key)
    return extractl3interface(dev)
  end,
  State = function(mapping, param, key)
    local dev = key2dev(key)
    return extractState(dev)
  end,
  Port = function(mapping, param, key)
    local dev = key2dev(key)
    return extractPort(dev)
  end,
  Speed = function(mapping, param, key)
    local dev = key2dev(key)
    return extractSpeed(dev)
  end,
  Priority = function(mapping, param, key)
    return getPriority(key)
  end
}
Sys_Hosts_Host_i_.commit = function()
  for config,_ in pairs(transactions) do
    commit({config = config})
  end
  transactions = {}
end

Sys_Hosts_Host_i_.revert = function()
  for config,_ in pairs(transactions) do
    revert({config = config})
  end
  transactions = {}
end
register(Sys_Hosts_Host_i_)
