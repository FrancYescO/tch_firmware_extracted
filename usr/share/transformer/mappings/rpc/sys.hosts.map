local register, commitapply, mapper, io = register, commitapply, mapper, io
local pairs, tostring, error = pairs, tostring, error
local uciHelper = mapper("ucihelper")
local get_from_uci = uciHelper.get_from_uci
local set_on_uci = uciHelper.set_on_uci
local forEachOnUci = uciHelper.foreach_on_uci
local string = string
local format, match, lower = string.format, string.match, string.lower
local nwcommon = mapper("nwcommon")
local network = require("transformer.shared.common.network")
local envBinding = { config = "env" }
local wirelessBinding = { config = "wireless" }
local dhcpBinding = { config = "dhcp" }
local transactions = {}
local staticLeases = {}
local hostsCache
local vpnCache
local extIntfType, extMacAddr

-- sys.hosts
local Sys_Hosts_ = {
  objectType = {
    name = "sys.hosts.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      WirelessNumberOfEntries = {
        access = "readOnly",
        type = "unsignedInt",
      },
      EthernetNumberOfEntries = {
        access = "readOnly",
        type = "unsignedInt",
      },
      ActiveWirelessNumberOfEntries = {
        access = "readOnly",
        type = "unsignedInt",
      },
      ActiveEthernetNumberOfEntries = {
        access = "readOnly",
        type = "unsignedInt",
      },
    }
  }
}

local function getFromUci(binding, section, option, default)
  binding.sectionname = section
  if option then
    binding.option = option
    binding.default = default
    return get_from_uci(binding)
  end
  return uciHelper.getall_from_uci(binding)
end

local function setOnUci(binding, section, option, value)
  binding.sectionname = section
  binding.option = option
  set_on_uci(binding, value, commitapply)
  transactions[binding.config] = true
end

-- Open connection to UBUS
local conn = mapper("ubus").connect()

--These will cache the lan/wan interfaces, based on the firewall config
local lanInterfacesCache
local wanInterfacesCache
local lxcMAC = lower(getFromUci(envBinding, "var", "local_eth_mac_lxc"))

-- Uses the cached list. Make sure to update lanInterfacesCache (only) when needed
local function isLanInterface(interface)
  return network.listContains(lanInterfacesCache, interface)
end

-- false for lan, true for wan, nil for unknown
-- Uses the cached lists. Make sure to update lanInterfacesCache (only) when needed
local function getInterfaceZoneType(interface)
    --Check if it's LAN
    if (network.listContains(lanInterfacesCache, interface)) then
        return false
    end
    --Check if it's WAN
    if (network.listContains(wanInterfacesCache, interface)) then
        return true
    end
    return nil
end

--Updates the host cache and LAN interface cache
local function updateLanCache()
    --Update the hosts cache from hostmanager
    --Request "ext_info" as well while invoking conn:call on "hostmanager.device"
    hostsCache = conn:call("hostmanager.device", "get", { ["ext-info"] = true })
    vpnCache = conn:call("vpn.device", "get", {}) or {}
    if hostsCache == nil then
      error("retrieving hosts failed")
    end
    --Update the lan interfaces cache
    lanInterfacesCache = nwcommon.findLanWanInterfaces(false)
end

local function getWirelessNumberOfEntries(mapping)
    if (mapping) then
        updateLanCache()
    end
    local numberOfHosts = 0
    local intfType, macAddr = network.getExternalWifiIntfType(hostsCache)
    for _, v in pairs(hostsCache) do
      if ((v["technology"] == "wireless" and isLanInterface(v["interface"])) or (v["mac-address"] ~= macAddr and v["technology"] == "ethernet" and (v["l2interface"] == intfType or v["l2interface"] == match(v["l2interface"], "wl%d+_%d+")))) then
        numberOfHosts = numberOfHosts + 1
      end
    end
    return tostring(numberOfHosts)
end

local function getEthernetNumberOfEntries(mapping)
    if (mapping) then
        updateLanCache()
    end
    local numberOfHosts = 0
    local intfType, macAddr = network.getExternalWifiIntfType(hostsCache)
    for _, v in pairs(hostsCache) do
      if v["technology"] == "ethernet" and isLanInterface(v["interface"])  and  (v["l2interface"] ~= intfType and v["mac-address"] ~= macAddr and v["mac-address"] ~= lxcMAC and v["l2interface"] ~= match(v["l2interface"], "wl%d+_%d+")) then
        numberOfHosts = numberOfHosts + 1
      end
      for _, vpn in pairs(vpnCache) do
        if vpn["mac-address"] == v["mac-address"] then
          numberOfHosts = numberOfHosts + 1
        end
      end
    end
    return tostring(numberOfHosts)
end

local function getActiveWirelessNumberOfEntries(mapping)
    if (mapping) then
        updateLanCache()
    end
    local numberOfHosts = 0
    local intfType, macAddr = network.getExternalWifiIntfType(hostsCache)
    for _, v in pairs(hostsCache) do
      if v["state"] == "connected" and ((v["technology"] == "wireless" and isLanInterface(v["interface"])) or (v["mac-address"] ~= macAddr and v["technology"] == "ethernet" and (v["l2interface"] == intfType or v["l2interface"] == match(v["l2interface"], "wl%d+_%d+")))) then
        numberOfHosts = numberOfHosts + 1
      end
    end
    return tostring(numberOfHosts)
end

local function getActiveEthernetNumberOfEntries(mapping)
    if (mapping) then
        updateLanCache()
    end
    local numberOfHosts = 0
    local intfType, macAddr = network.getExternalWifiIntfType(hostsCache)
    for _, v in pairs(hostsCache) do
      if v["technology"] == "ethernet" and isLanInterface(v["interface"]) and (v["l2interface"] ~= intfType and v["mac-address"] ~= macAddr and v["mac-address"] ~= lxcMAC and v["l2interface"] ~= match(v["l2interface"], "wl%d+_%d+")) and v["state"] == "connected" then
        numberOfHosts = numberOfHosts + 1
      end
      for _, vpn in pairs(vpnCache) do
        if vpn["mac-address"] == v["mac-address"] then
          numberOfHosts = numberOfHosts + 1
        end
      end
    end
    return tostring(numberOfHosts)
end

Sys_Hosts_.get = {
  WirelessNumberOfEntries = getWirelessNumberOfEntries,
  EthernetNumberOfEntries = getEthernetNumberOfEntries,
  ActiveWirelessNumberOfEntries = getActiveWirelessNumberOfEntries,
  ActiveEthernetNumberOfEntries = getActiveEthernetNumberOfEntries
}

local all_values = {}
Sys_Hosts_.getall = function()
  --Update the interfaces and hosts cache
  updateLanCache()
  all_values["WirelessNumberOfEntries"] = getWirelessNumberOfEntries()
  all_values["EthernetNumberOfEntries"] = getEthernetNumberOfEntries()
  all_values["ActiveWirelessNumberOfEntries"] = getActiveWirelessNumberOfEntries()
  all_values["ActiveEthernetNumberOfEntries"] = getActiveEthernetNumberOfEntries()
  return all_values
end

register(Sys_Hosts_)

-- sys.hosts.host.{i}
local Sys_Hosts_Host_i_ = {
  objectType = {
    name = "sys.hosts.host.{i}.",
    access = "readWrite",
    numEntriesParameter = "HostNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      IPAddress = {
        access = "readOnly",
        type = "string",
      },
      IPv4= {
        access = "readOnly",
        type = "string",
      },
      IPv6= {
        access = "readOnly",
        type = "string",
      },
      MACAddress = {
        access = "readOnly",
        type = "string",
      },
      HostName = {
        access = "readWrite",
        type = "string",
        max = "64",
      },
      HostType = {
        access = "readWrite",
        type = "string",
        max = "16",
      },
      InterfaceType = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "ethernet",
          "wireless",
        }
      },
      Radio = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "radio_2G",
          "radio_5G",
        }
      },
      FirewallZone = {
        access = "readOnly",
        type = "string",
        enumeration = {
          "LAN",
          "WAN",
          "Unknown"
        }
      },
      ConnectedTime = {
         access = "readOnly",
         type = "string",
      },
      DhcpLeaseTime = {
         access = "readOnly",
         type = "string",
      },
      L2Interface = {
         access = "readOnly",
         type = "string",
      },
      L3Interface = {
         access = "readOnly",
         type = "string",
      },
      State = {
        access = "readOnly",
        type = "boolean",
      },
      Port = {
        access = "readOnly",
        type = "string",
      },
      Speed = {
         access = "readOnly",
         type = "string",
      },
      Priority = {
        access = "readWrite",
        type = "boolean",
      },
      BytesSent = {
        access = "readOnly",
        type = "unsignedInt",
      },
      BytesReceived = {
        access = "readOnly",
        type = "unsignedInt",
      },
      PktsSent = {
        access = "readOnly",
        type = "unsignedInt",
      },
      PktsReceived = {
        access = "readOnly",
        type = "unsignedInt",
      },
      SSID = {
        access = "readOnly",
        type = "string",
      },
      FriendlyName = {
        access = "readWrite",
        type = "string",
      },
      DhcpVendorClass = {
        access = "readOnly",
        type = "string",
      },
      DhcpLeaseIP = {
         access = "readOnly",
         type = "string",
      },
      DhcpTag = {
        access = "readOnly",
        type = "string",
      },
      LeaseType = {
        access = "readOnly",
        type = "string",
      },
      Delete = {
        access = "readWrite",
        type = "boolean",
      },
      LeaseTimeRemaining = {
        access = "readOnly",
        type = "int",
        range = {
          {
            min = "-1",
          },
        },
      },
      DeviceType = {
        access = "readWrite",
        type = "string",
      },
    }
  }
}

local dhcp = require("transformer.shared.dhcp")

local function loadStaticLeases()
  staticLeases = {}
  dhcpBinding.sectionname = "host"
  forEachOnUci(dhcpBinding, function(s)
    if s.mac then
      staticLeases[s.mac] = s.ip
    end
  end)
end

local dhcpInfo
local function updateDhcpInfo()
  local key
  dhcpInfo = dhcp.getDhcpInfo() or {}
  for _, host in pairs(hostsCache) do
    key = host["mac-address"]
    dhcpInfo[key] = dhcpInfo[key] or {}
    for _, ipdata in pairs(host["ipv4"]) do
      if ipdata["dhcp"] then
         dhcpInfo[key]["DhcpTag"] = ipdata["dhcp"]["tags"] or ""
         dhcpInfo[key]["DhcpVendorClass"] = ipdata["dhcp"]["vendor-class"] or ""
         break
      end
    end
  end
end

-- Extract an IP address from the given value and add it to the list
local function extractAddress(value, addresses, connected_flag)
  for _,value in pairs(value) do
    if connected_flag then --If the board has connected IP
      if value.state == "connected" then
        if addresses == "" then
          addresses = value["address"]
        else
          addresses = addresses.." "..value["address"]
        end
      end
    else  --If the board has only stale IP
      if value.state == "stale" then
        if addresses == "" then
          addresses = value["address"]
        else
          addresses = addresses.." "..value["address"]
        end
      end
    end
  end
  return addresses
end

local function extractFriendlyName(dev)
  if dev and dev["user-friendly-name"] and dev["user-friendly-name"] ~= "" then
    return dev["user-friendly-name"]
  elseif dev["hostname"] and dev["hostname"] ~= "" then
    return dev["hostname"]
  else
    return "Unknown-" .. dev["mac-address"]
  end
end

local hostExtraInfo
local hostExtraInfoFile = "/etc/hosts_ext"
local function loadHostExtraInfo()
  if not hostExtraInfo then
    hostExtraInfo = {}
    local f = io.open(hostExtraInfoFile, 'r')
    if f then
      for ln in f:lines() do
        local mac, hostName, hostType = ln:match('([^|]*)|([^|]*)|([^|]*)')
        if mac then
          hostExtraInfo[mac] = { HostName = hostName, HostType = hostType }
        end
      end
      f:close()
    end
    return hostExtraInfo
  end
end

Sys_Hosts_Host_i_.entries = function(mapping)
  --Update the interfaces and hosts cache - every time someone starts iteration on the hosts
  updateLanCache()
  loadStaticLeases()
  updateDhcpInfo()
  wanInterfacesCache = nwcommon.findLanWanInterfaces(true)
  local Hosts = network.getHostInfo(hostsCache)
  loadHostExtraInfo()
  extIntfType, extMacAddr = network.getExternalWifiIntfType()
  return Hosts
end

-- Convert a device key to device information
local function key2dev(key)
    return hostsCache[key]
end
local function extractMacAddresses(dev)
    if dev ~= nil and dev["mac-address"] ~= nil then
        return dev["mac-address"]
    end
    return ""
end

local function extractIP(dev, address_type)
   local addresses = ""
   local address_types = address_type and { address_type } or { "ipv4", "ipv6" }
   local connected_flag = false
   if dev ~= nil then
     -- Extract IP addresses
     for _, addressType in pairs(address_types) do
       for _, value in pairs(dev[addressType]) do
         if value.state == "connected" then
           connected_flag = true
         end
       end
       addresses = extractAddress(dev[addressType], addresses, connected_flag)
     end
   end
   return addresses
end

local function extractDhcpExpirationTime(dev, address_type)
   if dev and dev[address_type] then
     for _, value in pairs(dev[address_type]) do
       if (value.state == "connected" or value.state == "stale") and value.dhcp and value.dhcp["expiration-time"] then
         return value.dhcp["expiration-time"]
       end
     end
   end
   return nil
end

-- If dev["ext-info"} is available then extract upload/download Tx/Rx statistics
local function extractStats(dev, param)
   local ParamVal = "0"

   if dev and dev["ext-info"] then
        local ext_info_val = dev["ext-info"]
        local stats_val = ext_info_val["stats"]
        if stats_val ~= nil then
            if (param == "BytesReceived") then
                local down_val = stats_val["down"]

                if down_val and down_val["bytes"] then
                   ParamVal = tostring(down_val["bytes"])
                end
            elseif (param == "PktsReceived") then
                local down_val = stats_val["down"]

                if down_val and down_val["packets"] then
                    ParamVal = tostring(down_val["packets"])
                end
            elseif (param == "BytesSent") then
                 local up_val = stats_val["up"]

                 if up_val and up_val["bytes"] then
                    ParamVal = tostring(up_val["bytes"])
                 end
            elseif (param == "PktsSent") then
                 local up_val = stats_val["up"]

                 if up_val and up_val["packets"] then
                    ParamVal = tostring(up_val["packets"])
                 end
            end
        end
   end

   return ParamVal
end

local function extractHostName(dev, extraInfo)
  local HostName = extraInfo and extraInfo["HostName"]
  if not HostName or HostName == "" then
    if dev ~= nil and dev["hostname"] ~= nil then
      return dev["hostname"]
    else
      return "Unknown-" .. dev["mac-address"]
    end
  end
  return HostName
end

local function extractInterfaceType(dev)
   if dev == nil then
       return ""
   end
   if dev["mac-address"] ~= extMacAddr and (dev["l2interface"] == extIntfType or dev["l2interface"] and match(dev["l2interface"], "wl%d+_%d+")) then
      return "wireless"
   else
        return dev["technology"]
   end
end

local function extractRadio(dev)
   if dev == nil or dev["wireless"] == nil or dev["wireless"]["radio"] == nil then
       return ""
   end
   return dev["wireless"]["radio"]
end

local function extractFirewallZone(dev)
    local isWan
    if dev ~= nil and dev["interface"] ~= nil then
       isWan = getInterfaceZoneType(dev["interface"])
    end
    if isWan == nil then
        return "Unknown"
    end
    if ( isWan == false) then
        return "LAN"
    end
    return "WAN"
end

local function extractConnectedTime(dev)
    if dev and dev["connected_time"] then
        return tostring(dev["connected_time"])
    end
    return ""
end

local function getExternalWifiL2intf()
  local externalRadio
  local ifName = ''
    wirelessBinding.sectionname = "wifi-device"
    forEachOnUci(wirelessBinding, function(s)
      if s.type == "quantenna" then
        externalRadio = s[".name"]
        return false
      end
    end)
    if externalRadio then
      wirelessBinding.sectionname = "wifi-iface"
      forEachOnUci(wirelessBinding, function(s)
        if s.device == externalRadio then
          ifName = s[".name"]
          return false
        end
      end)
    end
  return ifName
end

local function getWifiL2intf(mac)
  local stations = conn:call("wireless.accesspoint.station", "get", { macaddr = mac }) or {}
  for ap, mac_addrs in pairs(stations) do
    if mac_addrs[mac] and mac_addrs[mac]["state"] ~= "Disconnected" then
       local accesspoints = conn:call("wireless.accesspoint", "get", { name = ap }) or {}
       return accesspoints[ap] and accesspoints[ap]["ssid"] or ""
    end
  end
  return getExternalWifiL2intf()
end

local function extractl2interface(dev)
  local intfType, macAddr = network.getExternalWifiIntfType()
  if dev and dev["mac-address"] ~= macAddr and dev["l2interface"] == intfType then
    return getWifiL2intf(dev["mac-address"])
  else
    return dev["l2interface"]
  end
end

local function extractl3interface(dev)
    if dev ~= nil and dev["l3interface"] ~= nil then
        return dev["l3interface"]
    end
    return ""
end

local function getDataForRadioSSID(ssidkey)
  local data = conn:call("wireless.ssid", "get",  { name = ssidkey })
  return data and data[ssidkey] and data[ssidkey].ssid or ""
end

local function extractSSID(dev)
   local ssidkey = extractl2interface(dev)
   if dev["technology"] == "wireless" and dev["wireless"] and dev["wireless"]["ssid"] and dev["wireless"]["ssid"] ~= "" then
     ssidkey = dev["wireless"]["ssid"] or ""
   end
   return ssidkey and getDataForRadioSSID(ssidkey) or ""
end

local function extractState(dev)
    if dev ~= nil and dev["state"] == "connected" then
        return "1"
    end
    return "0"
end

local function extractPort(dev)
    -- [CL] Some platforms don't have l2interfaces that make sense (e.g. without switch driver)
    -- [CL] If the device in the hostmanager ubus call knows what port a device is attached to, let's trust it
    -- [CL] Hacking this into the generic sys.hosts.map file until someone can explain me how to properly customize this without
    -- [CL] copying the entire file and hence losing all future functionality/bugfixes since noone looks at our platforms anyway.
    if dev == nil then
        return ""
    end
    if dev["switchport"] ~= nil then
        return tostring(dev["switchport"])
    else
        if dev["technology"] == "ethernet" and isLanInterface(dev["interface"]) and dev["l2interface"] == extIntfType and dev["mac-address"] ~= extMacAddr then
           return ""
       elseif dev["technology"] == "ethernet" and isLanInterface(dev["interface"]) and dev["l2interface"] ~= nil then
           local portNumber = string.match(dev["l2interface"],"%a*(%d+)")
           if portNumber ~= nil then
               portNumber = portNumber + 1
               return tostring(portNumber)
           end
           return ""
       end
       return ""
    end
end

--function to check whether devices are connected via DHCP or as Static

local function isStatic(dev)
  local ipv4Table = dev.ipv4 or {}
  if dev.state == "connected" then
    for _, hostData in pairs(ipv4Table) do
      if hostData.state == "connected" and hostData.configuration == "static" then
        return true
      end
    end
  end
end

local function getLeaseType(dev, mac)
  local ip = extractIP(dev, "ipv4")
  if (staticLeases[mac] and staticLeases[mac] == ip) or isStatic(dev) then
    return "Static"
  elseif dhcpInfo[mac].leasetime then
    return "DHCP"
  end
  return ""
end

local function getLeaseTimeRemaining(dev)
  local leaseLeft = "0"
  local leaseExpirationTime = extractDhcpExpirationTime(dev, "ipv4")
  if leaseExpirationTime then
    leaseLeft = tonumber(leaseExpirationTime) - os.time()
  end
  return tostring(leaseLeft)
end

local function extractDeviceType(dev)
  return dev and dev["device-type"] or ""
end

local function getInterfaceState(l2interface)
    local f = io.open("/sys/class/net/" .. l2interface .. "/speed")
    if f == nil then
	return ""
    end
    local speed = f:read("*number")
    f:close()
    return tostring(speed) or ""
end

local function extractSpeed(dev)
    if dev == nil then
        return ""
    end
    if dev["technology"] == "wireless" then
        if dev["wireless"] and dev["wireless"]["tx_phy_rate"] ~= nil then
            return tostring(dev["wireless"]["tx_phy_rate"] / 1000)
        end
        return ""
    elseif dev["technology"] == "ethernet" then
        if dev["l2interface"] ~= nil and dev["l2interface"] ~= "" then
            return getInterfaceState(dev["l2interface"])
        elseif dev["l3interface"] ~= nil then
            return getInterfaceState(dev["l3interface"])
        end
        return ""
    end
    return ""
end

local delete_on_uci = uciHelper.delete_on_uci
local commit = uciHelper.commit
local revert = uciHelper.revert
local qos_binding = { config = "qos" }
local host_binding = { config = "hostmanager" }
local gsub = string.gsub

local function getQosSectionName(mac)
  local mac_without_colon = gsub(mac,"%W","")
  return "mac" .. mac_without_colon
end

local function getPriority(key)
  local priority = getFromUci(qos_binding, getQosSectionName(key), "target")
  return priority == "gamingpriority" and "1" or "0"
end

Sys_Hosts_Host_i_.getall = function(mapping, key)
  local dev = key2dev(key)
  local mac = extractMacAddresses(dev)
  local extraInfo = hostExtraInfo[mac]
  return {
    MACAddress = extractMacAddresses(dev),
    IPAddress = extractIP(dev),
    IPv4 = extractIP(dev, "ipv4"),
    IPv6 = extractIP(dev, "ipv6"),
    HostName = extractHostName(dev, extraInfo),
    HostType = extraInfo and extraInfo["HostType"] or "",
    InterfaceType = extractInterfaceType(dev) or "",
    Radio = extractRadio(dev) or "",
    SSID = extractSSID(dev) or "",
    FirewallZone = extractFirewallZone(dev),
    ConnectedTime = extractConnectedTime(dev),
    DhcpLeaseTime = dhcpInfo[mac]["leasetime"] or "",
    L2Interface = extractl2interface(dev),
    L3Interface = extractl3interface(dev),
    State = extractState(dev),
    Port = extractPort(dev),
    Speed = extractSpeed(dev),
    Priority = getPriority(mac),
    BytesSent =  extractStats(dev, "BytesSent"),
    BytesReceived = extractStats(dev, "BytesReceived"),
    PktsSent = extractStats(dev, "PktsSent"),
    PktsReceived = extractStats(dev, "PktsReceived"),
    FriendlyName = extractFriendlyName(dev),
    DhcpVendorClass = dhcpInfo[mac]["DhcpVendorClass"] or "",
    DhcpLeaseIP = dhcpInfo[mac]["ip"] or "",
    DhcpTag = dhcpInfo[mac]["DhcpTag"] or "",
    LeaseType = getLeaseType(dev, mac),
    Delete = "0",
    LeaseTimeRemaining = getLeaseTimeRemaining(dev),
    DeviceType = extractDeviceType(dev),
  }
end

local deviceExtroInfoChanged = false

local function saveHostExtraInfo()
  local f = io.open(hostExtraInfoFile, 'w')
  if f then
    for mac, extraInfo in pairs(hostExtraInfo) do
      extraInfo.HostName = extraInfo.HostName or ""
      extraInfo.HostType = extraInfo.HostType or ""
      if (extraInfo.HostName == "") and (extraInfo.HostType == "") then
        hostExtraInfo[mac] = nil
      else
        f:write(format("%s|%s|%s\n", mac, extraInfo.HostName, extraInfo.HostType))
      end
    end
    f:close()
  end
end

local function setHostExtraInfo(mapping, param, value, key)
  if match(value, "|") then
    return nil, "'|' is not allowed"
  end
  local dev = key2dev(key)
  local mac = extractMacAddresses(dev)
  hostExtraInfo[mac] = hostExtraInfo[mac] or {}
  hostExtraInfo[mac][param] = hostExtraInfo[mac][param] or ""
  if hostExtraInfo[mac][param] ~= value then
    hostExtraInfo[mac][param] = value
    deviceExtroInfoChanged = true
  end
end

local function haveStaticLease(mac)
  local static_lease = false
  -- Limitation: If static lease removed by GUI, then there will be issue when the Gaming device is rebooted and got different IP address.
  dhcpBinding.sectionname = "host"
  forEachOnUci(dhcpBinding,function(s)
    if s.mac == mac then  -- Not checking the owner, already user via gui or other applications might have added static lease
      static_lease = true
      return false
    end
  end)
  return static_lease
end

-- Add 'host' section under 'dhcp' configuration.
-- Add 'mac' and 'owner' option under 'host' section.
local function setGamingRule(mac)
  dhcpBinding.sectionname = "host"
  dhcpBinding.option = nil
  local newSectionName = uciHelper.add_on_uci(dhcpBinding)
  if newSectionName then
    setOnUci(dhcpBinding, newSectionName, "mac", mac)
    setOnUci(dhcpBinding, newSectionName, "owner", "gamingdevice")
  end
end

local function setDhcpGamingRule(mac)
  if not haveStaticLease(mac) then
    setGamingRule(mac)
  end
end

local function setQosGamingLabel()
  local gaming_label = getFromUci(qos_binding, "gamingpriority")
  local priority_id = getFromUci(host_binding, "global", "prioritytrafficid")
  -- If not available, create the new label
  if gaming_label then
    qos_binding.option = nil
    set_on_uci(qos_binding, "label", commitapply)
    setOnUci(qos_binding, "gamingpriority", "trafficid", priority_id)
  end
end

local function setQosReclassify(mac)
  local reclassifySection = getFromUci(qos_binding, getQosSectionName(mac))
  if reclassifySection then
    qos_binding.option = nil
    qos_binding.sectionname = getQosSectionName(mac)
    set_on_uci(qos_binding, "reclassify", commitapply)
    setOnUci(qos_binding, getQosSectionName(mac), "srcmac", mac)
  end
  setOnUci(qos_binding, getQosSectionName(mac), "target", "gamingpriority")
end

-- Function to Add Gaming Label Section and Reclassify Rule in QOS
-- Add Gaming Rule Section in DHCP
local function setGamingQos(mac)
  setQosGamingLabel()
  setQosReclassify(mac)
  -- Add 'host' section under 'dhcp' configuration
  setDhcpGamingRule(mac)
end

local function deleteGamingTarget(mac)
  -- Delete "target" option under reclassify section.
  setOnUci(qos_binding, getQosSectionName(mac), "target", "")
end

local function gamingDeviceSection(mac)
  local section
  forEachOnUci(dhcpBinding, function(s)
    if s["owner"] == "gamingdevice" and s["mac"] == mac then
      section = s[".name"]
      return false
    end
  end)
  return section
end

local function deleteDhcpGamingRule(mac)
  local section = gamingDeviceSection(mac)
  if section then
    dhcpBinding.sectionname = section
    dhcpBinding.option = nil
    delete_on_uci(dhcpBinding, commitapply)
    transactions[dhcpBinding.config] = true
  end
end

-- Function to delete DHCP Gaming rule section and Qos 'target' option
local function resetGamingQos(mac)
  deleteGamingTarget(mac)
  deleteDhcpGamingRule(mac)
end

local function setPriority(mapping, param, value, key)
  local dev = key2dev(key)
  local mac = extractMacAddresses(dev)
  if value == "1" then
    setGamingQos(mac)
  else
    resetGamingQos(mac)
  end
end

Sys_Hosts_Host_i_.set = {
  Delete = function(mapping, param, value, key)
    local mac = extractMacAddresses(key2dev(key))
    local ubusData = conn:call("hostmanager.device", "get", { ["mac-address"] = mac }) or {}
    if ubusData["dev0"] and ubusData["dev0"]["state"] == "connected" then
      return nil, "Cannot delete the connected devices"
    end
    if value == "1" then
      conn:call("hostmanager.device", "delete", { ["mac-address"] = mac })
    end
  end,
  DeviceType = function(mapping, param, value, key)
    local mac = extractMacAddresses(key2dev(key))
    conn:call("hostmanager.device", "set", { ["mac-address"] = mac, ["device-type"] = value })
  end,
  Priority = setPriority,
  HostName = setHostExtraInfo,
  HostType = setHostExtraInfo,
  FriendlyName = function(mapping, param, value, key)
    local mac = extractMacAddresses(key2dev(key))
    conn:call("hostmanager.device", "set", { ["mac-address"] = mac, ["user-friendly-name"] = value })
  end
}

Sys_Hosts_Host_i_.get = {
  IPAddress = function(mapping, param, key)
    local dev = key2dev(key)
    return extractIP(dev)
  end,
  IPv4 = function(mapping, param, key)
     local dev = key2dev(key)
     return extractIP(dev, "ipv4")
  end,
  IPv6 = function(mapping, param, key)
     local dev = key2dev(key)
     return extractIP(dev, "ipv6")
  end,

  MACAddress = function(mapping, param, key)
    local dev = key2dev(key)
    return extractMacAddresses(dev)
  end,
  HostName = function(mapping, param, key)
    local dev = key2dev(key)
    local mac = extractMacAddresses(dev)
    return extractHostName(dev, hostExtraInfo[mac])
  end,
  HostType = function(mapping, param, key)
    local dev = key2dev(key)
    local mac = extractMacAddresses(dev)
    return hostExtraInfo[mac] and hostExtraInfo[mac][param] or ""
  end,
  InterfaceType = function(mapping, param, key)
    local dev = key2dev(key)
    return extractInterfaceType(dev)
  end,
  Radio = function(mapping, param, key)
    local dev = key2dev(key)
    return extractRadio(dev)
  end,
  FirewallZone = function(mapping, param, key)
    local dev = key2dev(key)
    return extractFirewallZone(dev)
  end,
  ConnectedTime = function(mapping, param, key)
    local dev = key2dev(key)
    return extractConnectedTime(dev)
  end,
  DhcpLeaseTime = function(mapping, param, key)
    local mac = extractMacAddresses(key2dev(key))
    return dhcpInfo[mac]["leasetime"] or ""
  end,
  L2Interface = function(mapping, param, key)
    local dev = key2dev(key)
    return extractl2interface(dev)
  end,
  L3Interface = function(mapping, param, key)
    local dev = key2dev(key)
    return extractl3interface(dev)
  end,
  State = function(mapping, param, key)
    local dev = key2dev(key)
    return extractState(dev)
  end,
  Port = function(mapping, param, key)
    local dev = key2dev(key)
    return extractPort(dev)
  end,
  Speed = function(mapping, param, key)
    local dev = key2dev(key)
    return extractSpeed(dev)
  end,
  Priority = function(mapping, param, key)
    local dev = key2dev(key)
    local mac = extractMacAddresses(dev)
    return getPriority(mac)
  end,
  BytesSent =  function(mapping, param, key)
    local dev = key2dev(key)
    return extractStats(dev, param)
  end,
  BytesReceived = function(mapping, param, key)
    local dev = key2dev(key)
    return extractStats(dev, param)
  end,
  PktsSent = function(mapping, param, key)
    local dev = key2dev(key)
    return extractStats(dev, param)
  end,
  PktsReceived = function(mapping, param, key)
    local dev = key2dev(key)
    return extractStats(dev, param)
  end,
  SSID = function(mapping, param, key)
    local dev = key2dev(key)
    return extractSSID(dev)
  end,
  FriendlyName = function(mapping, param, key)
    return extractFriendlyName(key2dev(key))
  end,
  DhcpVendorClass = function(mapping, param, key)
    local mac = extractMacAddresses(key2dev(key))
    return dhcpInfo[mac][param] or ""
  end,
  DhcpLeaseIP = function(mapping, param, key)
    local mac = extractMacAddresses(key2dev(key))
    return dhcpInfo[mac]["ip"] or ""
  end,
  DhcpTag = function(mapping, param, key)
    local mac = extractMacAddresses(key2dev(key))
    return dhcpInfo[mac][param] or ""
  end,
  LeaseType =  function(mapping, param, key)
    local dev = key2dev(key)
    local mac = extractMacAddresses(dev)
    return getLeaseType(dev, mac)
  end,
  Delete = "0",
  LeaseTimeRemaining = function(mapping, param, key)
    local dev = key2dev(key)
    return getLeaseTimeRemaining(dev)
  end,
  DeviceType = function(mapping, param, key)
    return extractDeviceType(key2dev(key))
  end,
}
Sys_Hosts_Host_i_.commit = function()
  for config in pairs(transactions) do
    commit({config = config})
  end
  transactions = {}
  if deviceExtroInfoChanged then
    saveHostExtraInfo()
    deviceExtroInfoChanged = false
  end
end

Sys_Hosts_Host_i_.revert = function()
  for config in pairs(transactions) do
    revert({config = config})
  end
  transactions = {}
  if deviceExtroInfoChanged then
    hostExtraInfo = nil
    deviceExtroInfoChanged = false
  end
end

Sys_Hosts_Host_i_.add = function(mapping, key)
  return nil, "hostmanager device can't be added"
end

Sys_Hosts_Host_i_.delete = function(mapping, key)
  local dev = key2dev(key)
  local mac = dev["mac-address"] or ""
  return conn:call("hostmanager.device", "delete", { ["mac-address"] = mac } )
end

register(Sys_Hosts_Host_i_)
