#!/usr/bin/env lua
--A whitelist of the packages we want in our container
local package_list = {
  "base-files",
  "busybox", -- Added on top of minimal
  "curl", -- Added on top of minimal
  "flock", -- Added on top of minimal
  "jshn",
  "jsonfilter",
  "libblobmsg-json",
  "libc",
  "libcurl4", -- Added on top of minimal
  "libgcc1",
  "libjson-c4",
  "libjson-script",
  "liblua5.1.5",
  "libnl-tiny",
  "libpthread",
  "librt",
  "libssp",
  "libstdcpp6",
  "libubox20170601",
  "libubus20170705",
  "libuci20130104",
  "libuclient20160123", -- Dependency from uclient-fetch
  "lua",
  "netifd",
  "opkg",
  "odhcpc", -- Added on top of minimal
  "procd",
  "ubox",
  "ubus",
  "ubusd",
  "uclient-fetch", -- New dependency from opkg, contains wget replacement
}

local blacklist = {
  "/etc/boards", -- No custo requirements
  "/etc/board%.d", -- No need to detect the board inside the container
  "/etc/uci%-defaults", -- No firstboot needed
  "/etc/rc%.button", -- A container has no buttons
  "/init", -- Will be in the container config
  "/var", -- Will be in the container config
  "/etc/init%.d", -- Container will install its own init.d scripts
  "/etc/resolv.conf", -- Container will create its own if needed
  "/rom", -- Container doesn't have to be aware of /rom
  "/etc/wlan", -- Container doesn't have to worry about wlan
  "/etc/fstab", -- This information should be in the container config
  "/etc/localtime",
  "/etc/TZ", -- Not used by glibc
  "/lib/preinit", -- No preinit needed inside the container
  "/etc/opkg/keys", -- No opkg keys needed inside the container
  "/etc/opkg.conf", -- We will create a custom opkg configuration inside the container
  "/lib/upgrade", -- Containers will not be able to upgrade dynamically,
  "/sbin/init", -- We provide our own init
  "/etc/group", -- We don't want to share this sensitive information with the container
  "/etc/passwd", -- We don't want to share this sensitive information with the container
  "/etc/shadow", -- We don't want to share this sensitive information with the container
  "/etc/openwrt_version", -- Incorrect information (contains wrong version info)
  "/etc/openwrt_release", -- Incorrect information (contains wrong release info)
  "/usr/lib/os%-release", -- Incorrect information (contains wrong release info)
  "/etc/os%-release", -- Incorrect information (contains wrong release info)
  "/lib/brcm6xxx_tch%.sh", -- Technicolor specific
  "/etc/rdpa_init%.sh", -- Technicolor specific
  "/etc/opkg/distfeeds%.conf", -- No opkg feeds used in our container
  "/etc/opkg/customfeeds%.conf", -- No opkg feeds used in our container
  "/bin/passwd", -- Currently we don't allow to change user passwords inside the container
  "/etc/jffs2_options", -- Not mandatory file and doesn't exist in some platforms e.g. gbnt-2
  "/lib64",
  "/usr/lib64",
  "/etc/bosa", -- Not mandatory file and doesn't exist in some platforms
}

local alt_root = ""
local opkg_info_dir = "/usr/lib/opkg/info/"
local opkg_status_dir = "/usr/lib/opkg/"

local function execute_cmd(full_cmd)
  local f = io.popen(full_cmd)
  local res = {}
  if f then
    for line in f:lines() do
      res[#res + 1] = line
    end
    f:close()
  end
  return res
end

local function mkdir(dir)
  local cmd = "/bin/sh -c \"mkdir -p "..dir.." 2> /dev/null && echo 'success'\""
  return execute_cmd(cmd)[1]
end

local function file_allowed(file_path)
  for _, pattern in ipairs(blacklist) do
    if file_path:match("^"..pattern) then
      return false
    end
  end
  return true
end

local filelist

local function generate_filelist()
  if filelist then
    return filelist
  end
  filelist = {}
  -- Translate the package list to a file list
  for _, package in ipairs(package_list) do
    -- First verify the package is installed
    local f = io.open(alt_root..opkg_info_dir..package..".list", "r")
    if not f then
      error("Package "..package.." is not installed!")
    end
    for line in f:lines() do
      if file_allowed(line) then
        filelist[#filelist + 1] = line
      end
    end
    f:close()
  end
  return filelist
end

local function add_to_dirlist(dirlist, entry)
  local _, occur = entry:gsub("/", "")
  if occur > 1 then
    -- Add parent directories first
    add_to_dirlist(dirlist, entry:match("^(.+)/[^/]+$"))
  end
  if not dirlist[entry] then
    dirlist[#dirlist + 1] = entry
    dirlist[entry] = true
  end
end

local function create_fstree(rootfs, name)
  local filelist = generate_filelist()
  local dirlist = {}
  -- Prepopulate dirlist with some standard requirements
  add_to_dirlist(dirlist, opkg_info_dir:match("(.*)/$"))
  add_to_dirlist(dirlist, "/dev") -- TODO check if these can be auto-created by the LXC config
  add_to_dirlist(dirlist, "/etc/init.d") -- Explicitely re-add this directory as we will want to install our own init scripts
  add_to_dirlist(dirlist, "/etc/rc.d") -- Explicitely re-add this directory as we will want to install our own init scripts
  add_to_dirlist(dirlist, "/etc/config") -- Explicitely re-add this directory as we will want to support UCI config
  add_to_dirlist(dirlist, "/proc") -- TODO check if these can be auto-created by the LXC config
  add_to_dirlist(dirlist, "/sys") -- TODO check if these can be auto-created by the LXC config
  add_to_dirlist(dirlist, "/tmp") -- TODO check if these can be auto-created by the LXC config
  add_to_dirlist(dirlist, "/var/lock") -- Needed by opkg to perform an install
  add_to_dirlist(dirlist, "/tmp/lcm_"..name) -- Needed by LCM to download new packages to 
  for _, file in ipairs(filelist) do
    file = file:match("^(.+)/[^/]+$")
    add_to_dirlist(dirlist, file)
  end
  for _, dir in ipairs(dirlist) do
    local ok, errmsg = mkdir(rootfs..dir)
    if not ok then
      error(errmsg)
    end
  end
end

local function copy_list_file(rootfs, package)
  local orig_info = io.open(alt_root..opkg_info_dir..package..".list", "r")
  if not orig_info then
    error("Unable to read opkg list info for " .. package)
  end
  local lxc_info = io.open(rootfs..opkg_info_dir..package..".list", "w")
  if not lxc_info then
    orig_info:close()
    error("Unable to write opkg list info for " .. package)
  end
  for file in orig_info:lines() do
    if file_allowed(file) then
      lxc_info:write(file.."\n")
    end
  end
  lxc_info:close()
  orig_info:close()
end

local function copy_control_file(rootfs, package)
  local orig_info = io.open(alt_root..opkg_info_dir..package..".control", "r")
  if not orig_info then
    error("Unable to read opkg config info for " .. package)
  end
  local lxc_info = io.open(rootfs..opkg_info_dir..package..".control", "w")
  if not lxc_info then
    orig_info:close()
    error("Unable to write opkg config info for " .. package)
  end
  local essential_found = false
  for line in orig_info:lines() do
    if line:match("^Essential: yes$") then
      essential_found = true
    end
    lxc_info:write(line.."\n")
  end
  if not essential_found then
    lxc_info:write("Essential: yes\n")
  end
  lxc_info:close()
  orig_info:close()
end

local function populate_status_file(rootfs, package)
  local orig_info = io.open(alt_root..opkg_status_dir.."status", "r")
  if not orig_info then
    error("Unable to read status file")
  end
  local lxc_info = io.open(rootfs..opkg_status_dir.."status", "a+")
  if not lxc_info then
    orig_info:close()
    error("Unable to write opkg status file")
  end
  local package_started = false
  local essential_found = false
  for line in orig_info:lines() do
    if package_started then
      if line:match("^Essential: yes$") then
        essential_found = true
      end
      if line:match("^%s*$") then
        if not essential_found then
          lxc_info:write("Essential: yes\n")
          essential_found = false
        end
        package_started = false
      end
      lxc_info:write(line.."\n")
    else
      if line == "Package: "..package then
        package_started = true
        lxc_info:write(line.."\n")
      end
    end
  end
  lxc_info:close()
  orig_info:close()
end

local function populate_opkg_info(rootfs)
  for _, package in ipairs(package_list) do
    copy_list_file(rootfs, package)
    copy_control_file(rootfs, package)
    populate_status_file(rootfs, package)
  end
end

local function chmod(perm, file)
  os.execute("chmod " .. perm .. " " .. file)
end

local function ln_soft(target, link)
  os.remove(link)
  os.execute("ln -s "..target.." "..link)
end

local function install_lcmbase(rootfs, name)
  create_fstree(rootfs, name)
  chmod("755", rootfs)
  populate_opkg_info(rootfs)

  -- Define a root user
  local f = io.open(rootfs.."/etc/passwd", "w")
  if not f then
    error("Could not create /etc/passwd")
  end
  f:write("root:x:0:0:root:/root:/bin/sh\n")
  f:close()

  -- Define a root group
  f = io.open(rootfs.."/etc/group", "w")
  if not f then
    error("Could not create /etc/group")
  end
  f:write("root:x:0:root\n")
  f:close()

  -- Create a startup script
  f = io.open(rootfs.."/etc/init.d/rcS", "w")
  if not f then
    error("Could not create /etc/init.d/rcS")
  end
  f:write([[
#!/bin/sh

run_scripts() {
        for i in /etc/rc.d/$1*; do
                [ -x $i ] && $i $2 2>&1
        done
}

run_scripts "$1" "$2" &
]])
  f:close()
  chmod("744", rootfs.."/etc/init.d/rcS")

  -- Create an init script
  f = io.open(rootfs.."/sbin/init", "w")
  if not f then
    error("Could not create /sbin/init")
  end
  f:write([[
#!/bin/sh

# Install packages before booting
for ipk in $(ls -1 /etc/ipks/*.ipk); do
  opkg install --force-depends --force-reinstall ${ipk} && rm ${ipk}
done
ls /etc/custo/config/* &>/dev/null && mv /etc/custo/config/* /etc/config

# Check if preinstalled packages need to be enabled or disabled. These files
# are generated based on the enabled state of the packages on the previous SW
# build and will be removed afterwards.
force_enabled="/etc/force_enabled"
force_disabled="/etc/force_disabled"

if [ -f ${force_disabled} ]; then
  while read app; do
    if [ -f /etc/init.d/${app} ]; then
      /etc/init.d/${app} stop
      /etc/init.d/${app} disable
    fi
  done < ${force_disabled}
  rm -f "${force_disabled}"
fi

if [ -f ${force_enabled} ]; then
  while read app; do
    if [ -f /etc/init.d/${app} ]; then
      /etc/init.d/${app} enable
    fi
  done < ${force_enabled}
  rm -f "${force_enabled}"
fi

. /etc/init.d/rcS S boot

trap "{ run_scripts K shutdown; exit; }" SIGTERM SIGPWR

while true; do
  # Doing nothing
  sleep 10
done
]])
  f:close()
  chmod("755", rootfs.."/sbin/init")

  -- Create 2 scripts that handle signaling of the init completion to the outside world.
  -- The signaling is done through the creation of the '/etc/.booted' file at the end of the
  -- container startup. The first script is ran at the start of the container and removes the
  -- sentinel file if it exists, the second script runs at the end of the startup and creates
  -- the sentinel file.
  f = io.open(rootfs.."/etc/init.d/lxc_start", "w")
  if not f then
    error("Could not create /etc/init.d/lxc_start")
  end
  f:write([[
#!/bin/sh /etc/rc.common

START=01

boot() {
  rm -f /etc/.booted
}
]])
  f:close()
  chmod("755", rootfs.."/etc/init.d/lxc_start")
  ln_soft("../init.d/lxc_start", rootfs.."/etc/rc.d/S01lxc_start")


  f = io.open(rootfs.."/etc/init.d/zend", "w")
  if not f then
    error("Could not create /etc/init.d/zend")
  end
  f:write([[
#!/bin/sh /etc/rc.common

START=99
STOP=01

# This is tze end, my only friend, z end.
boot() {
  touch /etc/.booted
}

stop() {
  rm -f /etc/.booted
}
]])
  f:close()
  chmod("755", rootfs.."/etc/init.d/zend")
  ln_soft("../init.d/zend", rootfs.."/etc/rc.d/S99zend")
  ln_soft("../init.d/zend", rootfs.."/etc/rc.d/K01zend")

  -- Create an opkg configuration file
  f = io.open(rootfs.."/etc/opkg.conf", "w")
  if not f then
    error("Could not create /etc/opkg.conf")
  end
  f:write([[
dest root /
]])
  f:close()

  return true
end

local function export_config(path)
  local f = io.open(path.."/lcm.config", "w")
  if not f then
    error("Unable to open config file "..path)
  end
  local filelist = generate_filelist()
  table.sort(filelist)
  for _, file in ipairs(filelist) do
    f:write("lxc.mount.entry = "..file.." "..file:match("^/(.*)").." none ro,bind,create=file 0 0\n")
  end
  f:close()
  return true
end

local function create_configuration(path, rootfs, name, builddir)
  local f = io.open(path.."/config", "w")
  if not f then
    error("Unable to create config file for "..path)
  end
  local includepath=path
  if builddir then
    rootfs = rootfs:sub(#builddir+1) or rootfs
    includepath = includepath:sub(#builddir+1) or includepath
  end
  f:write("lxc.rootfs.path = \""..rootfs.."\"\n")
  f:write("lxc.include = \""..includepath.."/lcm.config\"\n")
  f:write("lxc.mount.entry = tmpfs tmp tmpfs rw,nosuid,nodev,noatime 0 0\n")
  f:write("lxc.signal.halt = SIGPWR\n")
  f:write("lxc.signal.reboot = SIGTERM\n")
  f:write("lxc.uts.name = \""..name.."\"\n")
  f:write("lxc.cap.drop = sys_module mac_admin mac_override sys_time\n")
  f:write("lxc.mount.auto = cgroup:mixed proc:mixed sys:mixed\n")
  f:close()
  os.execute("cp "..path.."/config "..path.."/config.template")
  return true
end

local package_status_line = "Status: install user installed\n"

local function create_opkg_info(package_dir)
  mkdir(alt_root..opkg_info_dir)
  local fd_status = io.open(alt_root..opkg_status_dir.."status", "w")
  if not fd_status then
    error("Unable to open temp status file")
  end
  local installed_time_line = "Installed-Time: "..execute_cmd("date +%s")[1].."\n"
  for _,package in ipairs(package_list) do
    local ipk_file = execute_cmd("find "..package_dir.." -iname '"..package.."_*\.ipk'")[1]
    if not ipk_file then
      error("Can't find ipk file for "..package)
    end
    -- Create the .list file
    local files = execute_cmd("tar -xzOf "..ipk_file.." ./data.tar.gz | tar -tzf - | grep -v '/$' | cut -d'.' -f 2-")
    local fd = io.open(alt_root..opkg_info_dir..package..".list", "w")
    if not fd then
      error("Unable to open temp list file")
    end
    for _, file in ipairs(files) do
      fd:write(file.."\n")
    end
    fd:close()
    -- Create the .control file
    local control = execute_cmd("tar -xzOf "..ipk_file.." ./control.tar.gz | tar -xzOf - ./control")
    local fd_control = io.open(alt_root..opkg_info_dir..package..".control", "w")
    if not fd_control then
      error("Unable to open temp control file")
    end
    local alternatives, architecture, conflicts, depends, package_line, provides, version
    for _, line in ipairs(control) do
      line = line .. "\n"
      fd_control:write(line)
      if line:match("^Alternatives") then
        alternatives = line
      elseif line:match("^Architecture") then
        architecture = line
      elseif line:match("^Conflicts") then
        conflicts = line
      elseif line:match("^Depends") then
        depends = line
      elseif line:match("^Package") then
        package_line = line
      elseif line:match("^Provides") then
        provides = line
      elseif line:match("^Version") then
        version = line
      end
    end
    fd_control:close()
    -- Append to the status file
    if not package_line or not architecture or not version then
      error("Missing mandatory status information")
    end
    fd_status:write(package_line)
    fd_status:write(version)
    if depends then
      fd_status:write(depends)
    end
    if provides then
      fd_status:write(provides)
    end
    if conflicts then
      fd_status:write(conflicts)
    end
    fd_status:write(package_status_line)
    fd_status:write(architecture)
    fd_status:write(installed_time_line)
    if alternatives then
      fd_status:write(alternatives)
    end
    fd_status:write("\n")
  end
  fd_status:close()
end

local function find_package(package, package_dir)
  if not package_dir then
    return package
  end
  local ipk_files = execute_cmd("find "..package_dir.." -iname '"..package.."_*\.ipk'")
  if #ipk_files==1 then
    return package
  end
  -- No exact match found, try extended
  ipk_files = execute_cmd("find "..package_dir.." -iname '"..package.."*_*\.ipk'")
  for _, file in ipairs(ipk_files) do
    local provides = execute_cmd("tar -xzOf "..file.." ./control.tar.gz | tar -xzOf - ./control | grep 'Provides'")
    if #provides==1 and package == provides[1]:match("^Provides: (.*)$") then
      file = file:match("([^/]+)\.ipk")
      file = file:match("^([^_]+)")
      return file
    end
  end
  -- Still no match found, try all packages
  ipk_files = execute_cmd("find "..package_dir.." -iname '*_*\.ipk'")
  for _, file in ipairs(ipk_files) do
    local provides = execute_cmd("tar -xzOf "..file.." ./control.tar.gz | tar -xzOf - ./control | grep 'Provides'")
    if #provides==1 and package == provides[1]:match("^Provides: (.*)$") then
      file = file:match("([^/]+)\.ipk")
      file = file:match("^([^_]+)")
      return file
    end
  end
end

local function parse_package_list(packagelist, packagedir)
  local result = {}
  for package in packagelist:gmatch("[^%s]+") do
    if package:match("^[+@]") then
      package = package:sub(2)
    end
    local matching_package = find_package(package, packagedir)
    if not matching_package then
      error("Unable to find ipk for "..package)
    end
    result[#result+1] = matching_package
  end
  return result
end

local function print_usage()
  print([[
LXC LCM openwrt image builder

Special arguments:
[ -h | --help ]: Print this help message and exit.

LXC internal arguments (do not pass manually!):
[ -n=<name> | --name=<name> ]: The container name
[ -p=<path> | --path=<path> ]: The path to the container
[ --rootfs=<rootfs> ]: The path to the container's rootfs
[ --packagedir=<packagedir> ]: If this script is run during compilation, it needs to know the directory that contains the ipks.
[ --builddir=<builddir> ]: If this script is run during compilation, it needs to know the build directory.
[ --packagelist=<packages> ]: Optionally override the built-in package list that needs to be mounted.
[ --blacklist=<files> ]: Optionally extend the built-in blacklist.
]])
end

local function run(args)
  local path, rootfs, name, packagedir, builddir, packagelist, extended_blacklist
  for k,v in ipairs(args) do
    if v:match("%-h") or v:match("%-%-help") then
      print_usage()
      return
    elseif v:match("%-p=") then
      path=v:match("%-p=(.+)")
    elseif v:match("%-%-path=") then
      path=v:match("%-%-path=(.+)")
    elseif v:match("%-n=") then
      name=v:match("%-n=(.+)")
    elseif v:match("%-%-name=") then
      name=v:match("%-%-name=(.+)")
    elseif v:match("%-%-rootfs=") then
      rootfs=v:match("%-%-rootfs=(.+)")
    elseif v:match("%-%-packagedir=") then
      packagedir=v:match("%-%-packagedir=(.+)")
    elseif v:match("%-%-builddir=") then
      builddir=v:match("%-%-builddir=(.+)")
    elseif v:match("%-%-packagelist=") then
      packagelist=v:match("%-%-packagelist=(.+)")
    elseif v:match("%-%-blacklist=") then
      extended_blacklist=v:match("%-%-blacklist=(.+)")
    end
  end
  -- Check that we have all variables we need
  if not name or not path or not rootfs then
    error("Please pass the name, path, and rootfs for the container")
  end
  if packagelist then
    package_list = parse_package_list(packagelist, packagedir)
  end
  if extended_blacklist then
    for pattern in extended_blacklist:gmatch("[^%s]+") do
      blacklist[#blacklist + 1] = pattern
    end
  end
  if packagedir then
    alt_root=execute_cmd("mktemp -d")[1]
    create_opkg_info(packagedir)
  end
  if not install_lcmbase(rootfs, name) then
    error("Failed to install rootfs")
  end
  if not export_config(path) then
    error("Unable to export shared config")
  end
  if not create_configuration(path, rootfs, name, builddir) then
    error("Failed to write config file")
  end
  if alt_root ~= "" then
    -- Script cleanup
    execute_cmd("rm -rf "..alt_root)
  end
end

run({...})
