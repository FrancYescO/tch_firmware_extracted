--[[
Copyright (c) 2016 Technicolor Delivery Technologies, SAS

The source code form of this Transformer component is subject
to the terms of the Clear BSD license.

You can redistribute it and/or modify it under the terms of the
Clear BSD License (http://directory.fsf.org/wiki/License:ClearBSD)

See LICENSE file for more details.
]]

local setmetatable = setmetatable
local getmetatable = getmetatable
local rawget = rawget
local type = type

local M = {}

--[[
The get and set entries in a mapping can either be a function or a table.
If it is a function it is not possible to extend it with so it can handle
extra parameters, which is what we need to do when adding numEntries parameters.

So we will replace the function by a table and set the metatable such that
for every entry we did not set explicitly the function is returned.
That way everything still works as expected.

So if the UCI helper already set a function for the get, we can wrap this and
still add the numEntries.

We also added the ability to extend an existing table with a function.
This allows for the mapping off e.g. Alias parameter to be generated by the
generator and still the uci helper can set its function.
This way the mapping writer does not have to worry about the order.
(The end result will be the same)
--]]

-- metatable __index function for wrapped function
local function getset_function_wrapper(tbl, key)
    return rawget(tbl, '@@_function')
end

local function wrap_getset(mapping, getset, fn)
    local fv = mapping[getset]

    local fv_type = type(fv)
    if fv_type == 'table' then
        if type(fn)=='function' then
            local mt = getmetatable(fv)
            if mt==fv then
                -- table is its own metatable, ok
                -- does it have the correct index?
                if fv.__index ~= getset_function_wrapper then
                    return nil, "invalid get/set table (wrong __index)"
                end
            elseif mt then
                return nil, "invalid get/set table (wrong meta)"
            else
                -- table has no meta, set it
                fv.__index = getset_function_wrapper
                setmetatable(fv, fv)
            end
            if rawget(fv, '@@_function') then --avoid metatable access
                return nil, "function already set"
            end
            fv['@@_function'] = fn
        elseif fn then
            return nil, "fn must be nil or function"
        end
        return true
    elseif fv_type == 'function' then
        if fn and (fn~=fv) then
            -- trying to set another function
            return nil, "function already set"
        end
        local wrapper = {
            __index = getset_function_wrapper;
            ['@@_function'] = fv;
        }
        setmetatable(wrapper, wrapper)
        mapping[getset] = wrapper
        return true
    elseif fv_type == 'nil' then
        -- not supplied yet, just set a simple table
        if type(fn)~='function' then
            mapping[getset] = {}
        else
            local wrapper = {
                __index = getset_function_wrapper;
                ['@@_function'] = fn;
            }
            mapping[getset] = setmetatable(wrapper, wrapper)
        end
        return true;
    else
        -- invalid
        return nil, "invalid type, expected function or table"
    end
end


--- Make sure the get of the mapping is a table
-- @param mapping the mapping
-- @param fn the get function to use (optional) 
-- @return true if all OK
--         nil, errmsg if something went wrong
-- Accepts function, table and nil as valid types for the original get member
-- If the original get is already a table wrapping a function or a function, 
-- it is error to add another function.
function M.wrap_get(mapping, fn)
    return wrap_getset(mapping, 'get', fn)
end

--- Make sure the set of the mapping is a table
-- @param mapping the mapping 
-- @param fn the get function to use (optional) 
-- @return true if all OK
--         nil, errmsg if something went wrong
-- Accepts function, table and nil as valid types for the original set member
-- If the original set is already a table wrapping a function or a function,
-- it is error to add another function.
function M.wrap_set(mapping, fn)
    return wrap_getset(mapping, 'set', fn)
end

return M