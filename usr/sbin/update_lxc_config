#!/usr/bin/env lua
local require = require
local pairs = pairs
local open = io.open

local uci = require 'uci'
local lfs = require 'lfs'
local process = require 'tch.process'

local cursor = uci.cursor()

local lxc_path = "/srv/lxc/"

local known_options = {
  ["lxc_rootfs_path"] = false,
  ["lxc_cgroup_cpuset_cpus"] = false,
  ["lxc_cgroup_cpu_cfs_quota_us"] = 3,
  ["lxc_cgroup_memory_limit_in_bytes"] = 3,
  ["lxc_net_%d+_type"]= false,
  ["lxc_net_%d+_flags"] = false,
  ["lxc_net_%d+_link"] = false,
  ["lxc_net_%d+_ipv4_address"] = false,
  ["lxc_net_%d+_ipv4_gateway"] = false,
  ["lxc_net_%d+_ipv6_address"] = false,
  ["lxc_net_%d+_ipv6_gateway"] = false,
  ["lxc_net_%d+_hwaddr"] = false,
  ["lxc_net_%d+_name"] = false,
  ["lxc_uts_name"] = false,
}

local function is_option_known(option)
  for opt_pattern, gsub_limit in pairs(known_options) do
    if option:match(opt_pattern) then
      gsub_limit = gsub_limit or nil --translate false to nil
      return true, gsub_limit
    end
  end
end

local function update_config(lxc_name, config_options)
  local config_path = lxc_path .. lxc_name .. "/config"
  local template = io.open(config_path..".template", "r")
  if not template then
    return
  end
  local config = io.open(config_path, "w")
  if not config then
    template:close()
    return
  end
  config:write(
    "# do not make changes to this file\n",
    "# this file is autogenerated from config.template and the uci config\n"
  )
  for line in template:lines() do
    for option_to_change, value in pairs(config_options) do
      if line:match(option_to_change) then
        line = line:gsub("=.*", "= "..value)
        config_options[option_to_change] = nil
        break
      end
    end
    config:write(line.."\n")
  end
  -- Append remaining options
  for option_to_change, value in pairs(config_options) do
    option_to_change = option_to_change:gsub("%^", "", 1)
    config:write(option_to_change.." = "..value.."\n")
  end
  config:close()
  template:close()
end

local hook_script = [[
#!/bin/sh

export NET_SECTION=lxc_net_%s
exec /usr/lib/lxc/net/hook "$@"
]]

local function create_network_hook(net)
  local hookname = ("/usr/lib/lxc/net/hook_%d"):format(net)
  if lfs.attributes(hookname, "mode") ~= "file" then
    local f = open(hookname, "w")
    if not f then
      return
    end
    f:write(hook_script:format(net))
    f:close()
    process.execute("chmod", {"u+x", hookname})
  end
  return hookname
end

local function install_network_hook(net, config_to_be_written)
  local hookname = create_network_hook(net)
  if not hookname then
    return
  end
  config_to_be_written[ ("^lxc.net.%s.script.up"):format(net) ] = hookname
end

local function lxc_option_for_uci(option)
  local is_known, limit_gsub = is_option_known(option)
  if is_known then
   return "^" .. option:gsub("_", "%.", limit_gsub)
  end
end

local function configure_lxc_instance(section)
  if section["enabled"] ~= "1" then
    return
  end
  local config_to_be_written = {}
  local name = section[".name"]
  -- Iterate over all options in the section. Handle only the ones we know and allow.
  -- Underscores in option names are replaced by dots in the lxc config.
  for option_name, option_value in pairs(section) do
    local lxc_option = lxc_option_for_uci(option_name)
    if lxc_option then
      config_to_be_written[lxc_option] = option_value
      local net = option_name:match("lxc_net_(%d+)_type")
      if net then
        install_network_hook(net, config_to_be_written)
      end
    end
  end
  update_config(name, config_to_be_written)
end

cursor:foreach("lxc", "lxc_instance", configure_lxc_instance)
