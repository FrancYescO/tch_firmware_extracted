#Syslog Filtered Messages Network Forwarding
# $1: ip address of remote syslog server
# $2: tcp/udp port number of remote listening syslog server
# $3: name of file containing filtered messages to be forwarded
# $4: protocol 'udp' (default) or 'tcp'
# $5: (optional) source port number used to set up the connection to the server. Sometimes, server listening expects it to be always the same once a connection is open

err_out="/var/log/slfwd.err"
#localport=51423

#As soon as the syslog interface comes up ('wan', most of the time),
# this script is triggered indirectly through the Hotplug mechanism;
#It takes the content of the filtered messages file (takes new lines added to the end as file grows), 
# serializes it line by line with 'while read log_line;do echo ${log_line};done' 
# (because remote server is not happy if all data arrives in big UDP packets, so every line in a separate UDP message),
# and passes it to 'nc' (or 'socat') which transmits it over the network

#Measures are taken to restart it (if 'nc' exists prematurely because of network errors),
# hence the 'while true;do' and '[ $? = 0] || break'
#The latter breaks the 'while read line;do echo $line;done' if echoing a line to the 'nc' pipe fails because 'nc' died;
#As a consequence, also 'tail' or 'cat' fails (exits), clean-up is done,
# and the outer loop re-iterates, and restarts the 'tail' (or 'cat'), 'while read' and 'nc' list of commands
#Error log file (slfwd.err) is truncated if too large (keep 100 lines: first 10 and last 90)
#To avoid log filter file entries being send twice, they are deleted from the filtered log file once they are sent (in blocks of 50 lines to limit CPU load)


srv_ip=$1
port=$2
filt_file=$3
if [ "$4" = 'udp' ]; then
	nc_proto='u'
	proto='UDP'
	method='DTLS1'
else
	retry=2
	nc_proto=''
	proto='TCP'
	method='TLS1.2'
fi
lport=${5:-$localport}
certificate="$(uci get system.@system[0].log_ssl_cert)"
ca_file="$(uci get system.@system[0].log_ssl_cafile)"
[ "${ca_file}" ] || ca_path='/etc/ssl/certs/'

# verify certificates; Default on. Set to 0 to disable certificate authentication checking
#verify=1

# list of possible OpenSSL ciphers; the 'DEFAULT' list does not include 'aNULL' (no authentication); 
# the 'ALL' list does. Uncomment next line for no authentication (ie. without certificates).
#ciphers="ALL"

hostname_mac_ser_msg="$(uci get system.@system[0].hostname)[MAC=$(uci get env.rip.eth_mac | tr : -)][S/N=$(uci get env.var.serial)] Forwarding: [syslog_fwd] filtered message forwarding restarted"

### socat replacing nc
#nc_cmd="nc -v${proto} -p ${lport} $1 $2 2>>${err_out} 1>&2"
nc_cmd_params="-v${nc_proto} ${lport:+-p ${lport}} ${srv_ip} ${port} 2>>${err_out} 1>&2"

socat_cmd="socat -u STDIO"

socat_unsecure_params="${proto}:${srv_ip}:${port}\
${lport:+,sourceport=${lport}}\
${retry:+,retry=${retry}} \
2>>${err_out} 1>&2"

socat_secure_params="OPENSSL:${srv_ip}:${port}\
${lport:+,sourceport=${lport}}\
${retry:+,retry=${retry}}\
${method:+,method=${method}}\
${certificate:+,cert=${certificate}}\
${ca_file:+,cafile=${ca_file}}\
${ca_path:+,capath=${ca_path}}\
${ciphers:+,cipher=${ciphers}},\
verify=${verify:-1} \
2>>${err_out} 1>&2"

if [ "${port}" != 6514 ] ; then
   cmd="${socat_cmd} ${socat_unsecure_params}"
else
   cmd="${socat_cmd} ${socat_secure_params}"
fi
delcharset="()\`\$*;|"
cmd=$(echo ${cmd} | tr -d ${delcharset})

net_fwd() {
	#$1 : optional timeout value for nc
	#cmd="nc ${1:+-w $1} ${nc_cmd_params}"
	#cmd=$(echo ${cmd} | tr -d ${delcharset})
#	echo "Forwarding command string: ${cmd} [lport=${lport},${localport}]" 2>>${err_out} 1>&2
	eval ${cmd}
}

stop_procs () {
	tail_pid=$(ps | grep -v awk | awk -v pattn="(tail -[fF]|cat).*${filt_file}" '$0 ~ pattn {print $1}')
	nc_pid=$(ps | grep -v awk | awk "/(nc -v|socat -u STDIO).*${srv_ip}[ :]${port}/"' {print $1}')
	if [ -n "${tail_pid}" ] ; then kill -9 ${tail_pid} ; fi
	if [ -n "${nc_pid}" ] ; then kill -9 ${nc_pid} ; fi
	lines=`wc /var/log/slfwd.err|awk '{print $1}'`
	let bl=10
	let el=$lines-90
	if [ $el -gt 0 ];then sed -i "$bl,${el}d" /var/log/slfwd.err 2>/dev/null;fi
}



while true ; do
	let i=i+1
	echo "fwd_process iteration $i starting 'socat' (or 'nc'); shell_pid exit_status background_pid :  '$$' '$?' '$!'" 2>>${err_out} 1>&2
#	echo "start_fwd script begin parameters ip=${srv_ip}, port=${port}, filter file=${filt_file}, proto=${proto}, local port=${lport}" 2>>${err_out} 1>&2
#	echo "start_fwd script begin parameters ip=$1, port=$2, filter file=$3, proto=$4, local port=$5" 2>>${err_out} 1>&2
	RestartFwdMsg='<'44'>'"$(date "+%c") ${hostname_mac_ser_msg}"
#	echo $RestartFwdMsg | nc -w 1 -v${proto} -p 51423 $1 $2 2>>${err_out} 1>&2
	echo $RestartFwdMsg | net_fwd 1
	if [ -p $3 ] ; then
		cat $3 | while read log_line;do echo ${log_line};[ $? = 0 ] || { stop_procs;break ; };sleep 0;done | net_fwd
	else
		tail -F -n +1 $3 | while read log_line;do echo ${log_line};[ $? = 0 ] || { stop_procs;break ; };sleep 0;done | net_fwd
	fi
	stop_procs
	sleep 61
done
