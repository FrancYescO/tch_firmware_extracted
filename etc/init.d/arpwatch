#!/bin/sh /etc/rc.common
# (C) NETDUMA Software 2016
# Do *NOT* enable this script. We run it from hotplug when the br-lan interface
# comes up.



START=99
PROG=/usr/bin/arpwatch

# Use procd if available otherwise revert to old method
if type procd > /dev/null; then 
  USE_PROCD=1
else
  SERVICE_DAEMONIZE=1
  SERVICE_WRITE_PID=1
fi

start_service() {
  interface=$(ifstatus lan | jsonfilter -e '@.l3_device')

  #-- @depends test
  #-- @test test 1
  if [ -z "$interface" ]; then
    #-- @depends logger; arpwatch
    #-- @test which logger && which arpwatch
    logger -t arpwatch -p 3 -s "Couldn't get LAN interface name."
  fi

  #-- @depends cat
  #-- @test which cat
  ifidx=$(cat /sys/class/net/${interface}/ifindex)

  #-- @depends test
  #-- @test test 1
  if [ -z "$ifidx" ]; then
    #-- @depends logger; arpwatch
    #-- @test which logger && which arpwatch
    logger -t arpwatch -p 3 -s "Couldn't get interface number."
  fi
  
  procd_open_instance
  procd_set_param command "$PROG"
  procd_append_param command -i "$ifidx"

  # run in own process space, meaning daemon will have pid
  # unfortunately init already binds a RTNETLINK with id 1
  # so we need a unique pid, we can just use this shells id
  procd_append_param command -p "$$"

  procd_append_param command -d
  procd_set_param respawn # respawn on crash
  if [ "$(cat /dumaossystem/model)" = "R2" ];then                                                                                  
          #Set core files size to unlimited                                                                                        
        procd_set_param limits core="unlimited"  # Set ulimit core files blocks                                                    
        sysctl -w "kernel.core_pattern=/tmp/%e.%p.%s.%t.core"                                                                      
        if [ ! -e "/.init_enable_core"  ];then                                                                                     
                touch /.init_enable_core                                                                                           
                sync                                                                                                               
        fi                                                                                                                         
  fi   
  procd_set_param stdout 0 # forward stdout of the command to logd
  procd_set_param stderr 1 # same for stderr

  # jail it - notice it needs no mount points as no files read/written
  procd_add_jail arpwatch ubus log                                                   
  procd_close_instance
}


# procd not available
start() {
  #-- @depends cat
  #-- @test which cat
  ifidx=$(cat /sys/class/net/br0/ifindex)
  service_start $PROG -i $ifidx -p $$ -d
}

stop() {
  service_stop $PROG
}
