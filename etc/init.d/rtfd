#!/bin/sh

# no start needed
STOP=99

# begin empty config flags, to be set via arguments in invoke file
DRYRUN=''
FAST=''
INVOKE_SOFT=''
INVOKE_ALL=''
#end empty config flags

LOGFILE=/dev/console # console, since the file system disappears
CTRLDIR='/var/rtfd'


log_error() {
    echo "RTFD: error:" $@ > $LOGFILE
    return 1
}


log_debug() {
    echo "RTFD: debug " $@ > $LOGFILE
    return 0
}


# receives one or more mtd volume names as argument(s)
mtd_erase() {
    sync # Flush unexpected pending writes before erasing any MTD
    local BEFORE=$(date +%s)
    local deleted_mtd_cnt=0
    for mtd in "$@" ; do
	if  grep -q $mtd /proc/mtd ; then
	    if  [ -z "${DRYRUN}" ] ; then
		log_debug "mtd erase $mtd"
		mtd erase $mtd
	    else
		log_debug "mtd erase $mtd (skipped ${DRYRUN})"
	    fi
	    deleted_mtd_cnt=$((deleted_mtd_cnt+1))
	fi
    done
    local AFTER=$(date +%s)
    log_debug "erased ${deleted_mtd_cnt} MTD(s) in $((AFTER-BEFORE))s"
    [ ${deleted_mtd_cnt} -eq 0 ] && return 1 || return 0
}


write_rtfd_mark_multi_bank() {
    local RTFD_MARK="$1"
    if [ -z "${RTFD_MARK}" ] ; then
	log_error "missing argument for write_rtfd_mark_multi_bank"
	return 1
    fi
    # Create a link to point to the configuration to be erased (done at next boot, before mounting the overlay)
    local TARGET_PATH=""
    if [ -d /overlayfs ] ; then
	TARGET_PATH="$(mount -t overlayfs | awk '/overlayfs/{print substr($1,length("overlayfs:")+1)}')"
    elif [ -d /overlay ] ; then
	TARGET_PATH="/overlay/$(cat /proc/banktable/booted)"
    fi
    if [ -n "${TARGET_PATH}" ] ; then
	if [ -z "${DRYRUN}" ] ; then
	    ln -s "${TARGET_PATH}" "${RTFD_MARK}"
	    log_debug "marked '${TARGET_PATH}' to erase"
	else
	    log_debug "marked '${TARGET_PATH}' to erase (skipped ${DRYRUN})"
	fi
	return 0
    fi
    log_error "Overlay nor Overlayfs is not present"
}


write_rtfd_mark_single_bank() {
    local RTFD_MARK="$1"
    if [ -z "${RTFD_MARK}" ] ; then
	log_error "missing argument for write_rtfd_mark_single_bank"
	return 1
    fi

    if [ -z "${DRYRUN}" ] ; then
	touch "${RTFD_MARK}"
	log_debug "wrote ${RTFD_MARK}"
    else
	log_debug "wrote ${RTFD_MARK} (skipped ${DRYRUN})"
    fi
}


write_rtfd_mark() {
    local RTFD_MARK=/overlay/remove_due_to_rtfd
    if [ -d /proc/banktable ] ; then
	write_rtfd_mark_multi_bank "${RTFD_MARK}" && return 0
    else
	write_rtfd_mark_single_bank "${RTFD_MARK}" && return 0
    fi
    log_error "problem occured when writing ${RTFD_MARK}"
    return 1
}


get_overlay_type() {
    local OVERLAY_TYPE=""
    if ( mount | grep -q 'on /overlay type jffs2') ; then
	OVERLAY_TYPE="jffs2"
    elif ( mount | grep -q '/overlay type ubifs' ) ; then
	OVERLAY_TYPE="ubifs"
    else
	echo ''    # to be received in var
	log_error "Unknown overlay type"
	return 1
    fi
    log_debug "overlay_type $OVERLAY_TYPE"
    echo "${OVERLAY_TYPE}"  # to be received in var
    return 0
}



# kill processes that have an FD opened to an overlay(fs)
# @param signal by default 15 = SIGTERM
kill_writing_processes() {
    local sig=${1:-15}
    local OVERLAY_MOUNT=''
    [ -d /overlayfs ] && OVERLAY_MOUNT='/overlayfs'
    [ -d /overlay ]   && OVERLAY_MOUNT='/overlay'
    lsof $OVERLAY_MOUNT |  awk '/ REG / { print $2} ' | uniq  | while read p ;
    do
	if [ -d "/proc/$p" ] ; then
	    local NAME=$(readlink /proc/$p/exe)
	    kill -$sig $p
	    log_debug "kill -$sig $p # $NAME (was accessing overlay)"
	fi
    done
}


# kill remaining processes, in the optimal situation all init scripts
# have a STOP value, until this happens, we can kill some more
# @param signal by default 15 = SIGTERM
kill_and_log_writing_processes() {
    local sig=${1:-15}
    # prevent respawning services instances by procd
    ubus call system upgrade

    if [ -n "${DRYRUN}" ] ; then
	STILL_RUNNING=/root/still_running_processes
	log_debug "try to write ${STILL_RUNNING} because of ${DRYRUN}"
	touch ${STILL_RUNNING} 2> /dev/null # after remount, writing became impossible
	if [ $? -eq 0 ] ; then
	    # if some process prevents erasing MTDs, we log them all to investigate
	    date >  ${STILL_RUNNING}
	    ps -w >> ${STILL_RUNNING}
	    [ -d /overlay   ] && {
		echo "lsof /overlay :" >> ${STILL_RUNNING}
		lsof /overlay >>  ${STILL_RUNNING}
	    }
	    [ -d /overlayfs ] && {
		echo "lsof /overlayfs :" >> ${STILL_RUNNING}
		lsof /overlayfs >> ${STILL_RUNNING}
	    }
	    echo "mount :" >> ${STILL_RUNNING}
	    mount >> ${STILL_RUNNING}
	    [ -n "${FAST}" ] && sync
	    log_debug "wrote $(ls -s ${STILL_RUNNING})"
	else
	    log_error "failed to write ${STILL_RUNNING} (read-only?)"
	fi
    fi

    # stop the writing processes before umounting
    kill_writing_processes ${sig}
}


# execute rtfd --all
rtfd_all() {
    log_debug "invoked rtfd_all"
    local OVERLAY_TYPE=$(get_overlay_type)
    kill_and_log_writing_processes 9
    case "${OVERLAY_TYPE}" in
	'jffs2')
	    log_debug "unmounting overlay..."
	    # Unmount the overlay seems to be not working, instead set it as read only
	    mount -type overlayfs -o ro,remount /

	    # unmount the overlay lower filesystem
	    umount -r /overlay
	    # by stopping these processes, we stop those that write-open a file just before the un/re-mounts
	    kill_writing_processes 9

	    mount | grep 'jffs2\|overlay' > /dev/console

	    if mtd_erase 'userfs' 'rootfs_data' 'data_vol' ; then
		log_debug "deleted jffs2 partition(s)"
	    else
		log_error "erase failed, use fallback mechanism"
	    fi
	    ;;
	'ubifs')
	    # TODO we need to use ubiupdatevol when possible (is it always available?)
	    [ -z "${DRYRUN}" ] && rm -rf /overlay/*
	    log_debug "deleted ubifs /overlay/*"
	    ;;
	'*')
	    log_error "unknown filesystem type"
    esac
    exit 0
}


# execute rtfd --soft
rtfd_soft() {
    log_debug "invoked rtfd_soft"
    write_rtfd_mark
    /usr/bin/rtfd_preserve
    # Copy files to be preserved into /overlay/rtfd_persistent_files
    if [ -f /etc/rtfd_persistent_filelist.conf ] ; then
	mkdir -p /overlay/rtfd_persistent_files
	cp /etc/rtfd_persistent_filelist.conf /overlay
	while read file_to_copy directory ; do
	    [ -f "${file_to_copy}" ] && cp "${file_to_copy}" /overlay/rtfd_persistent_files
	done < /etc/rtfd_persistent_filelist.conf
    fi

    exit 0
}


# execute rtfd without an argument
rtfd_default() {
    log_debug "invoked rtfd_default"
    write_rtfd_mark

    exit 0
}


# check argument config file and stores its content in DRYRUN and FAST, INVOKE_ALL, INVOKE_SOFT
argument_cfg_file() {
    local ARGUMENTFILE="${CTRLDIR}/invoke"
    local ARGS=''
    [ -s "${ARGUMENTFILE}" ] && ARGS="$(cat ${ARGUMENTFILE})"
    for arg in $ARGS ; do
	case "$arg" in
	    '--all')
		INVOKE_ALL=${arg}
		INVOKE_SOFT='' # all is stronger than soft
		;;
	    '--soft')
		INVOKE_SOFT=${arg}
		;;
	    '--fast')
		FAST=${arg}
		;;
	    '--dry-run')
		DRYRUN=${arg}
		;;
	    '*')
		log_debug "Unknown argument '${arg}' in invoke file"
		;;
	esac
    done
    log_debug "Received arguments : ${INVOKE_ALL} ${INVOKE_SOFT} ${FAST} ${DRYRUN}"
}


# invoked during the shutdown
shutdown() {
    [ ! -d "${CTRLDIR}" ] && return 0
    argument_cfg_file
    # the functions rtfd_all, rtfd_soft nor rtfd_default do return (because of exit)
    [ -n "${INVOKE_ALL}" ]  && rtfd_all
    [ -n "${INVOKE_SOFT}" ] && rtfd_soft
    rtfd_default
}

# main dispatcher
case "$1" in
    shutdown)
	shutdown
	;;
    stop|start|boot)
	;;
    '*')
	echo "$0 only expects shutdown and ignores stop start and boot"
esac