#!/bin/sh /etc/rc.common

. /lib/functions.sh

START=99
STOP=00

USE_PROCD=1

lxc_path="/srv/lxc"
lxc_name="$2"

create_overlay_upper_dir() {
  local lxc="${1}"
  local rootfs_path
  
  config_get rootfs_path "${lxc}" lxc_rootfs_path ""
  if [ -n "${rootfs_path}" ]; then
    local is_overlay=$(echo ${rootfs_path} | grep 'overlay')
    # When the rootfs is an overlay, we ensure the upper directory exists.
    if [ -n "${is_overlay}" ]; then
      local upper_dir=$(echo ${rootfs_path} | cut -d ':' -f 3)
      mkdir -p "${upper_dir}"
    fi
  fi
}

create_config_directory_mount_entry() {
  local lxc="${1}"
  local config_dir_path

  config_get config_dir_path "${lxc}" config_dir_path ""
  if [ -n "${config_dir_path}" ]; then
    mkdir -p ${config_dir_path}
    echo "lxc.mount.entry = ${config_dir_path} etc/config none rw,bind,create=dir 0 0 #config_dir_path" >> ${lxc_path}/${lxc}/config
  fi
}

create_lcm_tmp_dir() {
  local lxc="${1}"
  local lxc_tmp=tmp/lcm_$lxc
  mkdir -p /$lxc_tmp
  echo "lxc.mount.entry = /$lxc_tmp $lxc_tmp none ro,bind,create=dir 0 0" >>${lxc_path}/${lxc}/config
}

lxc_rootfs() {
  local lxc="${1}"

  grep "^lxc.rootfs.path" ${lxc_path}/${lxc}/config | tr -d " \"" | cut -d= -f2
}

lxc_add_includes() {
  local lxc="$1"
  local includes

  config_get includes "${lxc}" includes
  for inc in $includes ; do
    echo "lxc.include = $inc" >>/${lxc_path}/${lxc}/config
  done
}

lxc_ensure_user() {
  local user="${1}"
  if ! user_exists ${user} ; then
    local gid=$(group_add_next "${user}")
    user_add "${user}" "" "${gid}"
    group_add_user "${user}" "${user}"
  fi
  local home=$(grep ^${user} /etc/passwd | cut -d: -f6)
  [ -n "${home}" ] && mkdir -p "${home}"
}

start_ubus_forward() {
  local lxc="${1}"
  local ubus_proxy
  local ubus_user
  local ubus_createuser
  local rootfs

  config_get ubus_proxy "${lxc}" ubus_proxy
  config_get ubus_user "${lxc}" ubus_user
  config_get ubus_createuser "${lxc}" ubus_createuser 0

  [ -z "${ubus_proxy}" ] && return 0

  if [ "${ubus_proxy}" = "use_ipc" ]; then
    # Use a dedicated directory that will be mounted in the container
    rootfs=""
    ubus_proxy="/var/run/lcm_ipc_${lxc}/ubus.sock"
    echo "lxc.mount.entry = /var/run/lcm_ipc_${lxc} var/run/lcm_ipc_${lxc} none ro,bind,create=dir 0 0 #ubus_proxy" >> ${lxc_path}/${lxc}/config
  else
    rootfs=$(lxc_rootfs "${lxc}")
    [ -z "${rootfs}" ] && return 0
  fi
  mkdir -p ${rootfs}/$(dirname ${ubus_proxy})

  if [ ! -z ${ubus_user} ]; then
    if [ "$ubus_createuser" = "1" ]; then
      lxc_ensure_user $ubus_user
    fi
    ubus_user=",su=${ubus_user}"
  fi

  procd_open_instance "${lxc}_ubus_fwd"
  procd_set_param command socat -d -ly -lp${lxc}_ubp UNIX-LISTEN:${rootfs}/${ubus_proxy},unlink-early,fork${ubus_user} UNIX-CONNECT:/var/run/ubus.sock
  procd_close_instance
}

lxc_webservice_user() {
  local lxc="$1"
  local webuser="${lxc}_user"
  local role=$(uci get webservice.${webuser}.role 2>/dev/null)
  [ -z $role ] && return 0
  echo ${webuser}
}

enable_webservice() {
  local lxc="$1"
  local webuser=$(lxc_webservice_user "${lxc}")
  [ -z ${webuser} ] && return 0
  local webtoken_file="${lxc_path}/${lxc}/webtoken"
  cat /proc/sys/kernel/random/uuid >$webtoken_file
  echo "lxc.mount.entry = $webtoken_file etc/webtoken none ro,bind,create=file 0 0" >>${lxc_path}/${lxc}/config
  uci set webservice.${webuser}.token=$(cat $webtoken_file)
  uci commit webservice
}

disable_webservice() {
  local lxc="$1"
  local webuser=$(lxc_webservice_user "${lxc}")
  [ -z ${webuser} ] && return 0
  uci set webservice.${webuser}.token=
  uci commit webservice
}

lxc_instance_disable() {
  local lxc="$1"
  disable_webservice "${lxc}"
}

lxc_instance_start() {
  local lxc="${1}"
  local enabled

  config_get enabled "${lxc}" enabled "0"
  if [ "${enabled}" = "0" ]; then
    lxc_instance_disable "${lxc}"
    return 0
  fi

  create_lcm_tmp_dir "${lxc}"
  create_overlay_upper_dir "${lxc}"
  create_config_directory_mount_entry "${lxc}"
  start_ubus_forward "${lxc}"
  enable_webservice "${lxc}"
  lxc_add_includes "${lxc}"

  local config_file="${lxc_path}/${lxc}/config"
  procd_open_instance "${lxc}"
  procd_set_param command lxc-start -F -n "${lxc}"
  procd_set_param file "${config_file}"
  procd_close_instance
}


start_lxc_network_monitor() {
  procd_open_instance lxc_netmon
  procd_set_param command /usr/sbin/lxc_monitor.lua
  procd_close_instance
}

reload_webservice() {
  curl --silent -o /dev/null http://localhost:55555/api/reload
}

start_service() {
  local global_enabled

  config_load lxc
  config_get global_enabled global enabled "0"
  if [ "${global_enabled}" = "1" ] ; then
    start_lxc_network_monitor

    # All standard LXC config options are handled by the update_lxc_config script
    # TCH extensions are handled in lxc_instance_start (eg. ubus forwarder, config directory, ...)
    /usr/sbin/update_lxc_config
    if [ -n "${lxc_name}" ] ; then
        lxc_instance_start ${lxc_name}
    else
        config_foreach lxc_instance_start lxc_instance
    fi
  else
    if [ -n "${lxc_name}" ] ; then
        lxc_instance_disable ${lxc_name}
    else
        config_foreach lxc_instance_disable lxc_instance
    fi
  fi

  reload_webservice
}

service_triggers()
{
  procd_add_reload_trigger lxc
}
