<!--
  (C) 2016 NETDUMA Software
  Iain Fraser <iainf@netduma.com>
--> <%
require("libos")

local platform_information = os.platform_information()
%> <link rel="import" href="../polymer/polymer.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <link rel="import" href="/themes/<%= current_theme %>/duma-theme.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <link rel="import" href="/libs/d3.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <link rel="import" href="/libs/jquery.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <link rel="import" href="/libs/util.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <link rel="import" href="/libs/q.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <link rel="import" href="/libs/sprintf.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <link rel="import" href="/libs/topojson.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <link rel="import" href="/libs/vectors2.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <link rel="import" href="/libs/storage.html?v=<%= dumaos_version %>&lang=<%= lang %>&theme=<%= current_theme %>&themeVersion=<%= current_theme_version %>"> <!--
Custom property | Description | Default
----------------|-------------|----------
`--geofilter-icon-color`          |  | `--primary-text-color`
`--geofilter-icon-blocked-color`  |  | `--primary-text-color`
`--geofilter-radial-color`        |  | `--primary-color`
`--geofilter-country-color`       |  | `--map-color`
`--geofilter-country-stroke`      |  | 
--> <dom-module id="duma-map" class="zoom"> <template> <style include="duma-theme"> :host {
        display: block;
        position: absolute;
        height: calc(100% - 12px);
        width: calc(100% - 32px);
        left: 16px;
        top: 0;
        overflow: hidden;
      }

      .hidden {
        display: none !important;
        visibility: hidden;
      }

      /* country rendering */
      .country {
        fill: var(--geofilter-country-color, --map-color);
        stroke: var(--geofilter-country-stroke, #40070a);
        stroke-width: 1px;
        transition: fill 0.3s ease-out;
        -webkit-transition: fill 0.3s ease-out;
      }

      :host.home-cursor .country:hover {
        fill: var(--secondary-text-color);
      }

      #radial {
        transition: visibility 0.3s ease, opacity 0.3s ease;
        -webkit-transition: visibility 0.3s ease, opacity 0.3s ease;
        visibility: visible;
        opacity: 1;
      }

      :host.zoom-cursor #radial,
      :host.home-cursor #radial {
        visibility: hidden;
        opacity: 0;
      }

      .zoom-cursor .deadhosts rect,
      .zoom-cursor .hosts circle {
        stroke: #808080;
        fill: #808080;
      }

      .zoom-cursor .deadhosts:not(#legend) rect:hover,
      .zoom-cursor .hosts:not(#legend) circle:hover {
        stroke-opacity: 0.75;
        stroke-width: 3;
        fill-opacity: 0.15;
      }

      #worldmap-zoom,
      #worldmap-home,
      #worldmap-snap,
      #worldmap-feedback,
      #worldmap-flush {
        width: 2.75em;
      }

      #worldmap-zoom>span,
      #worldmap-home>span,
      #worldmap-snap>span,
      #worldmap-feedback>span,
      #worldmap-flush>span {
        display: inline-block;
        position: relative;
      }

      #worldmap-zoom>span:before,
      #worldmap-home>span:before,
      #worldmap-snap>span:before,
      #worldmap-feedback>span:before,
      #worldmap-flush>span:before {
        display: inline-block;
        font-family: FontAwesome;
        font-style: normal;
        font-weight: normal;
        line-height: 1;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        transition: color 0.3s ease-out;
        -webkit-transition: color 0.3s ease-out;
      }

      #worldmap-home>span:before {
        content: "\f015";
      }

      #worldmap-zoom>span:before {
        content: "\f002";
      }

      #worldmap-snap>span:before {
        content: "\f160";
      }

      #worldmap-feedback>span:before {
        content: "\f165";
      }

      #worldmap-flush>span:before {
        content: "\f021";
      }

      .zoom-cursor #worldmap-zoom>span:before,
      .home-cursor #worldmap-home>span:before {
        content: "\f00d";
      }

      .zoomed #worldmap>svg,
      .zoom-cursor #worldmap>svg {
        border-color: #212121;
      }

      /* how to render a black-listed host */
      .hostcat_black {
        fill: Indigo;
        opacity: 0.5;
        stroke-width: 2;
        stroke: aqua;
      }

      /* how to render a white-listed host */
      .hostcat_white {
        fill: white;
        opacity: 0.5;
        stroke-width: 2;
        stroke: aqua;
      }

      .whitehost {
        stroke-dasharray: 0.75, 1;
      }

      /* how to render a host blocked by distance, obsolete  */
      .hostcat_black_distance {
        fill: red;
        opacity: 0.5;
        stroke-width: 2;
        stroke: aqua;
      }

      /* how to render a host accepted by distance, obsolete */
      .hostcat_white_distance {
        fill: blue;
        opacity: 0.5;
        stroke-width: 2;
        stroke: aqua;
      }

      /* 
       * How to render hosts for a paticular connection selection. Should
       * match up with rendering the connection selection boxes. 
       */

      #worldmap {
        transition: all 0.3s ease-out;
        -webkit-transition: all 0.3s ease-out;
      }

      .deadhosts rect,
      .hosts circle {
        stroke-opacity: 0.75;
        stroke-width: 3;
        fill-opacity: 0.15;
      }

      .deadhosts:not(#legend) rect:hover,
      .hosts:not(#legend) circle:hover {
        fill-opacity: 0.22;
        stroke-opacity: 1;
        stroke-width: 4;
        transition: all 0.3s ease-out;
        -webkit-transition: all 0.3s ease-out;
      }

      .deadhosts rect {
        fill-opacity: 0.25;
        stroke-width: 1;
      }

      #legend {
        text-align: left;
        position: absolute;
        bottom: 0.5em;
        left: 0.0625em;
        background: rgba(7, 7, 7, 0.75);
        padding: 1.5em 2em;
      }

      .home-cursor #legend {
        display: none;
      }

      #legend .row {
        padding: 0;
        margin-bottom: 0;
      }

      #legend span {
        display: inline-block;
        height: 1em;
        width: 1em;
      }

      #legend svg,
      #legend img {
        width: auto;
        height: 100%;
        vertical-align: middle;
      }

      #legend label {
        padding: 0 0 0 0.5em;
        font-size: 0.875em;
      }

      #legend label.note {
        color: #808080;
        padding-left: 0;
        padding-top: 0.5em;
        font-style: italic;
      }

      #legend span.home img {
        width: 13px;
      }

      #legend rect,
      #legend circle {
        height: 100%;
        width: 100%;
      }

      /* the distance circle */
      .worldradial {
        fill: var(--geofilter-radial-color, --primary-color);
        fill-opacity: 0.1;
        stroke: var(--geofilter-radial-color, --primary-color);
        stroke-width: 2px;
      }

      /* world radial seekr line */
      .seeker {
        fill: var(--geofilter-radial-color, --primary-color);
        fill-opacity: 0.1;
        stroke: var(--geofilter-radial-color, --primary-color);
        stroke-width: 2px;
      }

      #polygons .points circle {
        fill: var(--geofilter-radial-color, --primary-color);
        stroke: var(--geofilter-radial-color, --primary-color);
      }
      #polygons .lines line {
        fill: var(--geofilter-radial-color, --primary-color);
        stroke: var(--geofilter-radial-color, --primary-color);
      }
      #polygons polygon {
        fill: var(--geofilter-radial-color, --primary-color);
        fill-opacity: 0.1;
      }
      #polygons .snap-circle {
        fill: var(--geofilter-radial-color, --primary-color);
      }
      /* .svg-border {
        fill: none;
      }
      :host[border] .svg-border {
        outline: 2px solid var(--transparent-primary-color);
        outline-offset: -15px;
      } */
      ::content g.icon-content {
        fill: var(--geofilter-icon-color, --primary-text-color);
      }
      ::content g.icon-content[type="server-blacklisted"],      
      ::content g.icon-content[type="server-blocked"],
      ::content g.icon-content[type="peer-blacklisted"],         
      ::content g.icon-content[type="peer-blocked"] {
        fill: var(--geofilter-icon-blocked-color, --primary-text-color);
      } </style> <div id="worldmap" class="svg-container" role="region" aria-label="<%= i18n.ariaMap %>"> <svg id="container" class="worldmapsvg"> <g id="zoomg" transform="rotate(0)"> <!-- <rect class="svg-border" width="100%" height="102%" y="-9px"></rect> --> <g id="countries"></g> <g id="states"></g> <g id="aus"></g> <g id="can"></g> <g id="polygons"></g> <g id="home"></g> <g id="trace"></g> <g id="points"></g> <g id="radial"></g> </g> </svg> </div> </template> <script> var _worldmap, _lowdetail;
    var world_radius = 6371;    // km

    function getdata(that, cb, lowres) {
      if (_worldmap) {
        cb.call(that, _lowdetail, _worldmap);
      } else {
        safe_getJSON_promise("/json/world-countries-low-detail.json").
          done(function (lowdetail) {
            _lowdetail = topojson.feature(lowdetail, lowdetail.objects.countries);
            cb.call(that, _lowdetail);
          });
        Q.all([
          loadCountriesJSON(),
        ]).spread(function (world) {
          _worldmap = world;
          cb.call(that, _worldmap);
        })
      }
    }

    // TODO: add mouse event
    function do_enter(selection, cat, proj) {
      var ctype = cat.ctype;
      var ctor = cat.ctor;
      var extra = cat.extra;

      var that = this;
      var enter = {
        "image": function () {
          var mx = extra.width / 2;
          var my = extra.height / 2;

          return selection
            .append("image")
            .attr("x", function (d) { return proj([d.value.lng, d.value.lat])[0] - mx; })
            .attr("y", function (d) { return proj([d.value.lng, d.value.lat])[1] - my; });
        },
        "circle": function () {
          return selection.append("circle")
            .attr("r", 1)
            .attr("fill", "red")
            .attr("cx", function (d) { return proj([d.value.lng, d.value.lat])[0]; })
            .attr("cy", function (d) { return proj([d.value.lng, d.value.lat])[1]; });
        },
        "g": function() {
          var mx = extra.width / 2;
          var my = extra.height / 2;

          return selection
            .append("g")
            .attr("x", function (d) { return proj([d.value.lng, d.value.lat])[0]; })
            .attr("y", function (d) { return proj([d.value.lng, d.value.lat])[1]; })
            .attr("transform",function(d){
              var pos = proj([d.value.lng, d.value.lat]);
              return "translate("+(pos[0])+","+(pos[1])+")";
            });
        }
      }

      var sel = enter[ctype]()
        .classed("scalable", true)
        .on("click", function (d, i) {
          $(that).trigger("hostclick", [d]);
        });

      if (is_defined(ctor))
        sel.call(ctor);
    }

    function do_dimensions() {
      var obj = this.$$("#container");
      if (is_undefined(this.width) || this.width == 0)
        this.width = $(this).width();

      var geo_aspect = 2 / 1;   // width / height 
      this.height = this.width / geo_aspect;
    }

    function is_ready() {
      return !(is_undefined(this.privdata) || !this.privdata.ready)
    }

    var STROKE_WIDTH = 3;
    var POINT_RADIUS = 2;
    var SNAP_RADIUS = POINT_RADIUS + 7;

    Polymer({
      is: "duma-map",
      behaviors: [Polymer.IronResizableBehavior],
      listeners: { "iron-resize": "onWidthChange" },
      onWidthChange: function () {
        this.privdata.ready = true;
        do_dimensions.call(this);
      },
      __getDims: function(){
        return [this.width/2,this.height * 0.61];
      },
      __makeProjection: function(){
        return d3.geo.equirectangular()
          .scale((this.width/500)*100,(this.height/500)*100)
          .translate(this.__getDims());
      },
      ready: function () {
        getdata(this, function (lowdetail, world) {
          do_dimensions.call(this);

          var that = this;
          var svg = d3.select(this.$$("#container"))
          this.scopeSubtree(this.$$("#container"), true);
          var width = this.width;
          var height = this.height;

          // svg init
          svg
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height].join(" "))
            .attr("preserveAspectRatio", "xMidYMid");

          var dims = this.__getDims();
          this.zoomx = this.zoomx || dims[0];
          this.zoomy = this.zoomy || dims[1];

          // construct groups
          var countries = svg.select("#countries")

          var states = svg.select("#states");
          var aus = svg.select("#aus");
          var can = svg.select("#can");

          var projection = this.__makeProjection();
          this._projection = projection;

          var path = d3.geo.path().projection( projection );

          // clear any world data i.e. low resolution
          countries.selectAll("path").data([]).exit().remove();

          // render world, remember map projection is 640x320 i.e. the height
          // is half the size.
          countries.selectAll("path").data(world ? world.features : lowdetail.features)
            .enter().append("path")
            .attr("d", path)
            .attr("width", width)
            .attr("height", width / 2)
            .attr("vector-effect", "non-scaling-stroke")
            .classed("hidden", function (d) {
              switch (d.id) {
                case "United States":
                case "USA":
                case "Australia":
                case "AUS":
                case "Canada":
                case "CAN":
                  return !that.islowres;
                default:
                  return false;
              }
            })
            .classed("country", true);

          // redraw overlay elements
          this._distance_change(this.distance, this.distance);

          // fire events
          var that = this;
          svg.on("mousedown.log", function () {
            var ms = d3.mouse(this);
            var vertex = that._getTranslatedSvgVertex(that._createVertex(ms[0], ms[1]));
            that.fire("mapclick", {
              "mx": vertex.x,
              "my": vertex.y,
              "projection": projection
            });
          });

        })
        this._bind_shift();
        this._bindMouseZoom(this.$.container);
        this._bindMousePan(this.$.container);
      },
      properties: {
        width: { type: Number },
        height: { type: Number },
        islowres: { type: Boolean, value: false },
        distance: { type: Number, value: 2000, observer: '_distance_change' },
        zoomfactor : { type: Number, value: 1, notify: true },
        zoomx : { type: Number, notify: true },
        zoomy : { type: Number, notify: true },
        polygonMode : {type: Boolean, observer: "_polygonModeChange"},
        host_global_scale : { type: Boolean, value: true },
        home: { 
          type: Array,
          value: function () { return [51, 0] },
          observer: '_distance_change'
        },
        privdata: { type: Object, value: { category: {}, points: {}, ready: false, max_mag: 0 } },
        preventRadialAnimation: { type: Boolean, value: false },
        // border: {type: Boolean, value: false },
        polygonCount: {type: Number, value: 0},
        polygonMax: {type: Number, value: 0},
        _shiftDown: {type: Boolean, value: false},
        zoomInfo: {type: Object, notify: true},
        _canUseLeftClickToPan: {type: Boolean, value: true}
      },
      observers: [
        "_onzoomchange(zoomfactor)"
      ],
      ST: function(val){ //Scale with thickness
        return val/(this.zoomfactor);
      },
      clampZoom: function(vertex){
        var projection = this.__makeProjection();
        var clamped = projection.invert([vertex.x, vertex.y]);
        var padding = 10
        clamped[0] = Math.min(Math.max(clamped[0],-180+padding),180-padding)
        clamped[1] = Math.min(Math.max(clamped[1],-90+padding),90-padding)
        clamped = projection(clamped);
        vertex.x = clamped[0];
        vertex.y = clamped[1];
        return vertex;
      },
      _atStartZooming: null,
      _on_end_zoom: function(){
        this._atStartZooming = null;
      },
      do_zoom: function( x, y, k, width, height, instant ){
        if(this._atStartZooming && k > 1){
          x = this._atStartZooming.x;
          y = this._atStartZooming.y;
        }
        var pos = this.clampZoom(this._createVertex(x,y));
        this.zoomx = pos.x;
        this.zoomy = pos.y;
        this.zoomfactor = k;
        var dims = this.__getDims();
        var t = svg_translate( dims[0], dims[1] ) + svg_scale( k )  + svg_translate( -pos.x, -pos.y );
        var duration = instant ? 0 : 750;
        d3.select(this.$.zoomg).transition()
            .duration(duration)
            .attr("transform",t)
            .each("end", this._on_end_zoom.bind(this));
            
            
        this.zoomInfo = {x: pos.x, y: pos.y, factor: k, transform: t, duration: duration};
        if(!instant) this._atStartZooming = this._atStartZooming || this.zoomInfo;
      },
      _zooms: [1,1.5,2.5,3.5,4.75,6.25,8,10,12.25,14.75],
      _getNextZoomFactor: function(direction){
        var i;
        for(i = 0; i < this._zooms.length; i++){
          if(this._zooms[i] === this.zoomfactor) break;
        }
        i += direction;
        return this._zooms[Math.min(Math.max(i,0),this._zooms.length-1)];
      },
      _getZoomXY: function(mousepos,elem,dims){
        var origin = this._createVertex(mousepos[0],mousepos[1]);
        origin.x = (origin.x / elem.clientWidth) * this.width;
        origin.y = (origin.y / elem.clientHeight) * this.height * 0.61;
        var vertex = this._getTranslatedSvgVertex(origin,this._atStartZooming ? this._atStartZooming : null);
        return vertex;
      },
      _bindMouseZoom: function(elem){
        var delem = d3.select(elem);
        var that = this;
        var zoomedOutScrollCount;
        delem.on("wheel",function () {
          var mouse = d3.mouse(this);
          var dims = that.__getDims();
          var zoomAmount = d3.event.deltaY * -1;
          var newZoomFactor = that._getNextZoomFactor(zoomAmount > 0 ? 1 : -1);
          if(newZoomFactor === that.zoomfactor){
            // If continually scrolling down, and already fully zoomed out, then don't prevent page from scrolling
            if(zoomedOutScrollCount < 8){
              d3.event.preventDefault();
            }
            if(newZoomFactor === that._zooms[0]){
              zoomedOutScrollCount += 1;
            }
            return;
          }
          zoomedOutScrollCount = 0;
          d3.event.preventDefault();
          var pos = that._getZoomXY(mouse,elem,dims);
          var xDo = newZoomFactor == 1 ? dims[0] : pos.x;
          var yDo = newZoomFactor == 1 ? dims[1] : pos.y;
          that.do_zoom(xDo,yDo,newZoomFactor,that.width,that.height);
        });
      },
      _bindMousePan: function(elem){
        var jelem = $(elem);
        var that = this;
        var drag = {
            x: 0,
            y: 0,
            state: false
        };
        jelem.mousedown(function(e) {
          if (!drag.state && (e.which == 2 || (e.which == 1 && that._canUseLeftClickToPan))) {
            drag.x = e.pageX;
            drag.y = e.pageY;
            drag.state = true;
          }
          return false;
        });
        $(window).mousemove(function(e) {
          if (drag.state && this.zoomfactor > 1) {
            this.zoomx -= (e.pageX - drag.x) / (this.zoomfactor/2);
            this.zoomy -= (e.pageY - drag.y) / (this.zoomfactor/2);
            this.do_zoom(this.zoomx, this.zoomy,this.zoomfactor,this.width,this.height,true);

            drag.x = e.pageX;
            drag.y = e.pageY;
          }
        }.bind(this));
        $(window).mouseup(function() {
          if (drag.state) {
            drag.state = false;
          }
        });
      },
      _getDefaultZoomInfo: function(){
        var lat = 0;
        var long = 0;
        var factor = 1; <% if platform_information.vendor == "TELSTRA" then %> //Australia
        lat = -33;
        long = 134;
        factor = 3.5; <% end %> var projection = this.__makeProjection();
        var out = projection([long,lat]);
        return {
          x: out[0],
          y: out[1],
          factor: factor
        }
      },
      saveZoom: function(rappid){
        var info = {
          factor: this.zoomfactor,
          x: this.zoomx,
          y: this.zoomy
        }
        duma.storage(rappid, "zoominfo", JSON.stringify(info) );
      },
      loadZoom: function(rappid){
        var zoominfo = duma.storage(rappid, "zoominfo" );
        zoominfo = zoominfo ? JSON.parse(zoominfo) : null;
        if(!zoominfo){
          zoominfo = this._getDefaultZoomInfo();
        }
        if( zoominfo ){
          var details = this.get_zoom_info();
          this.zoomx = zoominfo.x;
          this.zoomy = zoominfo.y;
          this.zoomfactor = zoominfo.factor;
          this.do_zoom( this.zoomx,this.zoomy, this.zoomfactor, details.width, details.height , true); 
          this.saveZoom(rappid);
        }
      },
      _onzoomchange: function(zoom){
        d3.selectAll("#polygons .lines line").transition().duration(750).style("stroke-width",this.ST(STROKE_WIDTH));
        d3.selectAll("#polygons .points circle").transition().duration(750).attr("r",this.ST(POINT_RADIUS)).style("stroke-width",this.ST(1));
      },
      _bind_shift: function() {
        $(document).keydown(function (e) {
          if (e.keyCode == 16) {
            this._shiftDown = true;
          }
        }.bind(this));
        $(document).keyup(function (e) {
          if (e.keyCode == 16) {
            this._shiftDown = false;
          }
        }.bind(this));
      },
      get_zoom_info: function () {
        var width = this.width;
        var height = this.height;
        var projection = this.__makeProjection();
        return {
          width: width,
          height: height,
          projection: projection
        }
      },
      _distance_change: function (newValue, oldValue) {
        if (!is_ready.call(this) || this.preventRadialAnimation) return;

        var that = this;
        var width = this.width;
        var height = this.height;

        // wait till all params init
        if (is_undefined(this.distance) || is_undefined(this.home))
          return;

        var distance = this.distance;
        var lat = this.home[0];
        var lng = this.home[1];
        var projection = this.__makeProjection();
        var path = d3.geo.path().projection(projection);


        // generate circle and use it to calculate end points
        var geodata = d3.geo.circle()
          .precision(0.5)
          .origin([lng, lat])
          .angle(rad_to_deg(distance / world_radius))();

        // render rotating line
        var curAngle = 180;
        var radius = rad_to_deg(this.distance / world_radius);
        var centre = [lng, lat];
        var coord = d3.geo.rotation(centre)(d3.geo.rotation([0, 0, curAngle])([radius, 0]))
        var data = {
          type: "LineString",
          coordinates: [centre, coord]
        }

        // dom selection
        var svg = d3.select(this.$$("#container"))
        var radialg = svg.select("#radial");


        // render circle
        var geodata = d3.geo.circle()
          .origin(centre)
          .angle(rad_to_deg(distance / world_radius))();
        var polygon = radialg.selectAll("path").data([geodata]);
        polygon.enter().append("path")
          .classed("worldradial", true)
          .attr("vector-effect", "non-scaling-stroke")
          .style("pointer-events", "none");
        polygon.attr("d", path);
        polygon.exit().remove();

        // render spinning line
        var line = radialg.selectAll(".seeker").data([data]);
        line.enter().append("path")
          .classed("seeker", true)
          .attr("vector-effect", "non-scaling-stroke")
          .attr("d", path);

        function tween_factory(d, i, a) {
          return function (t) {
            var len = geodata.coordinates[0].length;
            var idx = Math.floor(t * len) % len;
            var coord = geodata.coordinates[0][idx];

            data.coordinates[1] = coord;
            return path(data);
          }
        }

        function do_animation() {
          line
            .transition()
            .duration(4000)
            .ease("linear")
            .attrTween("d", tween_factory)
            .each("end", do_animation);
        }

        do_animation();
      },
      beginScene: function () {
        this.privdata.max_mag = 0;
        for (var cat in this.privdata.category) {
          this.privdata.category[cat].max_magnitude = 0;
          this.privdata.points[cat] = [];
        }
      },
      endScene: function () {
        var that = this;
        if (!is_ready.call(this)) return;

        var svg = d3.select(this.$$("#container"))
        var gpoints = svg.select("#points")
        var tick = 500;
        var width = this.width;
        var height = this.height;

        var projection = this.__makeProjection();

        for (var cat in this.privdata.category) {
          var category = this.privdata.category[cat]
          var cat_max = this.host_global_scale ?
            this.privdata.max_mag : category.max_magnitude;

          function cat_scale(d, i) {
            var m = d.value.magnitude;
            var x = cat;
            if (cat_max == 0 && m == 0) return 1;
            var ratio = m / cat_max;
            return ratio;
          }

          function host_transform(d, i) {
            var cx, cy;

            var size = 1 + (cat_scale(d, i) * 0.7);
            var inv = 1 / that.zoomfactor;
            var scale = size * inv;
            
            if (this.tagName == "circle") {
              cx = parseFloat(d3.select(this).attr("cx"));
              cy = parseFloat(d3.select(this).attr("cy"));
            } else if (this.tagName == "g") {
              cx = parseFloat(d3.select(this).attr("x"));
              cy = parseFloat(d3.select(this).attr("y"));
              return svg_translate(cx, cy) + svg_scale(scale)
             } else {
              var w = parseFloat(d3.select(this).attr("width"));
              var h = parseFloat(d3.select(this).attr("height"));
              cx = parseFloat(d3.select(this).attr("x")) + (w / 2);
              cy = parseFloat(d3.select(this).attr("y")) + (h / 2);
            }

            return svg_translate(cx, cy) + svg_scale(scale) + svg_translate(-cx, -cy);
          }


          var sel = gpoints.selectAll("." + cat).data(
            d3.entries(this.privdata.points[cat]),
            function (d, i) {
              return d.key;
            })

          /* enter */
          var g = sel.enter()
            .append("g")
            .attr("transform", function (d) {
              var trans = projection([d.value.lng, d.value.lat]);
              return svg_translate(0, 0);
            })
            .classed(cat, true)
            .call(do_enter, category, projection);

          /* update */
          sel.transition()
            .duration(tick)
            .select(".scalable")
            .attr("transform", host_transform);

          /* exit */
          sel.exit().remove();
        }
      },
      touchPoint: function (catid, id, _lat, _lng, _magnitude) {
        var pcat = this.privdata.points[catid];
        var cat = this.privdata.category[catid]

        var point = get_or_init(pcat, id, {
          lat: _lat,
          lng: _lng
        });
        point.magnitude = _magnitude,
          point.touched = timeGetTime()

        if (cat.max_magnitude < _magnitude)
          cat.max_magnitude = _magnitude;

        if (this.privdata.max_mag < _magnitude)
          this.privdata.max_mag = _magnitude;
      },
      addCategory: function (catid, aliveTime, _ctype, _ctor, _extra) {
        this.privdata.category[catid] = {
          ctype: _ctype,
          max_age: aliveTime,
          ctor: _ctor,
          extra: _extra
        };
        this.privdata.points[catid] = {};
      },
      rmCategory: function (catid) {
        delete this.privdata.category[catid];
        delete this.privdata.points[catid];
      },

      _attachMouseMoveEventToContainer: function (callback) {
        var _this = this;

        d3.select(this.$$("#container")).on("mousemove.polygon-container", function () {
          var m = d3.mouse(this);
          callback.apply(_this, [
            _this._getTranslatedSvgVertex(_this._createVertex(m[0], m[1]))
          ]);
        });
      },

      _detachMouseMoveEventFromContainer: function () {
        d3.select(this.$$("#container")).on("mousemove.polygon-container", null);
      },

      _attachMouseClickEventToContainer: function (callback) {
        var _this = this;
        this._canUseLeftClickToPan = false;

        d3.select(this.$$("#container")).on("click.polygon-container", function () {
          var m = d3.mouse(this);
          callback.apply(_this, [
            _this._getTranslatedSvgVertex(_this._createVertex(m[0], m[1]))
          ]);
        });
      },

      _detachMouseClickEventFromContainer: function () {
        this._canUseLeftClickToPan = true;
        d3.select(this.$$("#container")).on("click.polygon-container", null);
      },

      _attachMouseClickEventToPolygons: function (callback) {
        var _this = this;
        this._canUseLeftClickToPan = false;

        var polygons = d3.select(this.$$("#container"))
          .selectAll("#polygons g");
        
        polygons.on("click.polygon-container", function () {
            
            var polygon = this;

            var index;
            polygons.each(function (d, i) {
              if (this === polygon) {
                index = i;
              }
            });

            callback.apply(_this, [this, index]);
        });
      },

      _detachMouseClickEventFromPolygons: function () {
        this._canUseLeftClickToPan = true;
        d3.select(this.$$("#container")).selectAll("#polygons g").on("click.polygon-container", null);
      },

      _drawPoint: function (group, p) {
        return group.select(".points").append("circle")
          .attr("cx", p.x)
          .attr("cy", p.y)
          .attr("r", this.ST(POINT_RADIUS))
          .style("stroke-width",this.ST(1));
      },
      
      _showSnapCircle: function (group, p) {
        return group.select(".snap-circle")
          .attr("cx", p.x)
          .attr("cy", p.y)
          .attr("visibility", "visible")
          .attr("r", this.ST(SNAP_RADIUS));
      },

      _hideSnapCircle: function (group) {
        return group.select(".snap-circle")
          .attr("visibility", "hidden");
      },

      _drawLine: function (group, p, q) {
        return group.select(".lines").append("line")
          .attr("x1", p.x)
          .attr("y1", p.y)
          .attr("x2", q.x)
          .attr("y2", q.y)
          .style("stroke-width",this.ST(STROKE_WIDTH));
      },

      _verticesToPolygonPoints: function (vertices) {
        var points = [];

        for (var i = 0; i < vertices.length; i++) {
          points.push(vertices[i].x + "," + vertices[i].y);
        }

        return points.join(" ");
      },

      _showFill: function (group, vertices) {
        var points = this._verticesToPolygonPoints(vertices);

        return group.select(".fill")
          .attr("points", points)
          .attr("visibility", "visible");
      },

      _hideFill: function (group) {
        return group.select(".fill")
          .attr("visibility", "hidden");
      },

      _changeLine: function (line, p) {
        return line
          .attr("x2", p.x)
          .attr("y2", p.y);
      },

      _addVertex: function (vertices, vertex) {
        vertices.push(vertex);
      },

      _withinPointSnapRadius: function (radius, p, q) {
        var u = duma.vectors2.create(p.x, p.y);
        var v = duma.vectors2.create(q.x, q.y);

        var delta = duma.vectors2.subtract(u, v);

        return duma.vectors2.absolute(delta) <= radius;
      },

      _setLinesDashed: function (group) {
        group.selectAll(".lines line")
          .attr("stroke-dasharray", 5);
      },

      _setLinesSolid: function (group) {
        group.selectAll(".lines line")
          .attr("stroke-dasharray", 0);
      },

      _getIntersectionScalars: function (u, uDash, v, vDash) {
        var a = duma.vectors2.subtract(uDash, u);
        var b = duma.vectors2.subtract(vDash, v);

        var vToU = duma.vectors2.subtract(v, u);
        var uToV = duma.vectors2.subtract(u, v);

        var vToUCrossB = duma.vectors2.crossProduct(vToU, b);
        var uToVCrossA = duma.vectors2.crossProduct(uToV, a);

        var t = vToUCrossB / duma.vectors2.crossProduct(a, b);
        var s = uToVCrossA / duma.vectors2.crossProduct(b, a);

        return [t, s];
      },

      _doSegmentsIntersect: function (u, uDash, v, vDash) {
        var scalars = this._getIntersectionScalars(u, uDash, v, vDash);

        return scalars[0] > 0 && scalars[0] < 1 &&
               scalars[1] > 0 && scalars[1] < 1;
      },

      _doesNewLineCrossVerticies: function (vertices, p, q) {

        var u = duma.vectors2.create(p.x, p.y);
        var uDash = duma.vectors2.create(q.x,q.y);

        for (var i = 0; i < vertices.length - 2; i++) {
          var v = duma.vectors2.create(vertices[i].x, vertices[i].y);
          var vDash = duma.vectors2.create(vertices[i + 1].x, vertices[i + 1].y);

          if (this._doSegmentsIntersect(v, vDash, u, uDash)) {
            return true;
          }
        }

        if(p.x === q.x && p.y === q.y) return true;

        return false;
      },

      _getFirstItemInArray: function (a) {
        return a[0];
      },

      _getLastItemInArray: function (a) {
        return a[a.length - 1];
      },

      _setInProgressFixed: function (group) {
        group.select(".lines .in-progress")
          .classed("in-progress", false) 
          .classed("fixed", true);
      },

      _getTranslatedSvgVertex: function (vertex,zoomInfoOverride) {

        var scaleFactor = 1 / (zoomInfoOverride ? zoomInfoOverride.factor : this.zoomfactor);

        var dims = this.__getDims();

        // Make it relative to centre of SVG (not top left).
        var cx = vertex.x - dims[0];
        var cy = vertex.y - dims[1];

        // Undo scaling/zoom and get it back into SVG space.
        var sx = cx * scaleFactor;
        var sy = cy * scaleFactor;

        // Translate so centre of SVG is origin (not zoom position).
        sx += (zoomInfoOverride ? zoomInfoOverride.x : this.zoomx) || dims[0];
        sy += (zoomInfoOverride ? zoomInfoOverride.y : this.zoomy) || dims[1];

        return this._createVertex(sx, sy);
      },

      _createVertex: function (x, y) {
        return {
          x: x,
          y: y
        };
      },
      
      _createCoordinate: function (lat, lng) {
        return {
          lat: lat,
          lng: lng
        };
      },

      _convertVertexToCoordinate: function (vertex) {
        var projection = this._projection;
        var l = projection.invert([vertex.x, vertex.y]);
        return this._createCoordinate(l[0], l[1]);
      },

      _convertVertecesToCoordinates: function (vertices) {
        var coordinates = [];

        for (var i = 0; i < vertices.length; i++) {
          var vertex = vertices[i];
          var coordinate = this._convertVertexToCoordinate(vertex);
          coordinates.push(coordinate);
        }

        return coordinates;
      },

      _doesCoordinateLieWithinPolygon: function (coordinates, p) {
        var intersections = 0;

        var u = duma.vectors2.create(p.lat, p.lng);
        var uDash = duma.vectors2.create(1, 0);

        for (var i = 0; i < coordinates.length - 1; i++) {
          var v = duma.vectors2.create(coordinates[i].lat, coordinates[i].lng);
          var vDash = duma.vectors2.create(coordinates[i + 1].lat, coordinates[i + 1].lng);

          var scalars = this._getIntersectionScalars(u, uDash, v, vDash);

          if (scalars[0] > 0 && scalars[1] > 0 && scalars[1] < 1) {
            intersections++;
          }
        }

        return intersections % 2 !== 0;
      },

      /**
       * TODO
       * MOVE TRANSPARENT_YELLOW and LIGHT_TRANSPARENT_RED to var() in CSS
       */

      _createPolygonGroup: function () {
        var group = d3.select(this.$$("#container")).select("#zoomg #polygons")
          .append("g");

        group.append("circle")
          .attr("class", "snap-circle")
          .attr("r", POINT_RADIUS + 2)
          .attr("stroke-width", 0)
          .attr("visibility", "hidden");

        group.append("polygon")
          .attr("class", "fill")
          .attr("stroke-width", "0")
          .attr("visibility", "hidden");

        group.append("g").attr("class", "lines");
        group.append("g").attr("class", "points");

        return group;
      },

      _isFillShowing: function (group) {
        return group.select(".fill").attr("visibility") === "visible";
      },

      _getCurrentLine: function (group) {
        return group.select(".lines .in-progress");
      },

      startDeletingPolygons: function () {
        this._attachMouseClickEventToPolygons(function (polygonGroup, index) {
          d3.select(polygonGroup).remove();
          this.fire('polygon-remove',polygonGroup);
        }.bind(this));
      },

      stopDeletingPolygons: function () {
        this._detachMouseClickEventFromPolygons();
      },

      stopDrawingPolygons: function () {
        this._detachMouseClickEventFromContainer();
        this._detachMouseMoveEventFromContainer();
        var progress = d3.select(".in-progress");
        if(progress[0][0] !== null){
          d3.select(progress[0][0].parentNode.parentNode).remove();
          this.fire('polygon-cancel',progress);
        }
      },

      clampVertex: function(vertex){
        var projection = this.__makeProjection();
        var clamped = projection.invert([vertex.x, vertex.y]);
        clamped[0] = Math.min(Math.max(clamped[0],-180),180)
        clamped[1] = Math.min(Math.max(clamped[1],-90),90)
        clamped = projection(clamped);
        vertex.x = clamped[0];
        vertex.y = clamped[1];
        return vertex;
      },
      roundVertex: function(vertex){
        var projection = this.__makeProjection();
        var rounded = projection.invert([vertex.x, vertex.y]);
        rounded[0] = Math.round(rounded[0]);
        rounded[1] = Math.round(rounded[1]);
        rounded = projection(rounded);
        return {
          x: rounded[0],
          y: rounded[1]
        };
      },
      // min angle, max angle and func
      // 0 is left, right is 180 OR -180, up is 90, down is -90
      // func takes 4 arguments: 
      //     vertex: this vertex, previous: the previous one, angle: the angle, vertices: a list of all vertices
      _snaps: [
        // west
        {min: -30, max: 30, func: function(vertex, previous){
          vertex.y = previous.y;
        }},
        // north
        {min: 60, max: 120, func: function(vertex, previous){
          vertex.x = previous.x;
        }},
        // south
        {min: -120, max: -60, func: function(vertex, previous){
          vertex.x = previous.x;
        }},
        // east
        {min: -180, max: -150, func: function(vertex, previous){
          vertex.y = previous.y;
        }},
        // east 2
        {min: 150, max: 180, func: function(vertex, previous){
          vertex.y = previous.y;
        }},
        // north-west
        {min: 30, max: 60, func: function(vertex, previous, angle){
          var dist = Math.sqrt( Math.pow((previous.x-vertex.x), 2) + Math.pow((previous.y-vertex.y), 2) );
          vertex.x = Math.cos(-135*Math.PI/180) * dist + previous.x;
          vertex.y = Math.sin(-135*Math.PI/180) * dist + previous.y;
        }},
        // south-west
        {min: -60, max: -30, func: function(vertex, previous){
          var dist = Math.sqrt( Math.pow((previous.x-vertex.x), 2) + Math.pow((previous.y-vertex.y), 2) );
          vertex.x = Math.cos(135*Math.PI/180) * dist + previous.x;
          vertex.y = Math.sin(135*Math.PI/180) * dist + previous.y;
        }},
        // south-east
        {min: -150, max: -120, func: function(vertex, previous){
          var dist = Math.sqrt( Math.pow((previous.x-vertex.x), 2) + Math.pow((previous.y-vertex.y), 2) );
          vertex.x = Math.cos(45*Math.PI/180) * dist + previous.x;
          vertex.y = Math.sin(45*Math.PI/180) * dist + previous.y;
        }},
        // north-east
        {min: 120, max: 150, func: function(vertex, previous){
          var dist = Math.sqrt( Math.pow((previous.x-vertex.x), 2) + Math.pow((previous.y-vertex.y), 2) );
          vertex.x = Math.cos(-45*Math.PI/180) * dist + previous.x;
          vertex.y = Math.sin(-45*Math.PI/180) * dist + previous.y;
        }},
      ],
      snapVertex: function(vertex,vertices){
        var previous = this._getLastItemInArray(vertices);
        if(previous){
          var angleDeg = Math.atan2(previous.y - vertex.y, previous.x - vertex.x) * 180 / Math.PI;
          for(var i = 0; i < this._snaps.length; i ++){
            var snap = this._snaps[i];
            if(snap.min <= angleDeg && angleDeg <= snap.max){
              snap.func(vertex,previous, angleDeg,vertices);
              break;
            }
          }
        }
        return vertex;
      },

      startDrawingPolygons: function () {
        var verticesSets = [[]];
        var polygonGroup = this._createPolygonGroup();

        this._attachMouseClickEventToContainer(function (vertex) {

          var vertices = this._getLastItemInArray(verticesSets);

          var firstVertex = this._getFirstItemInArray(vertices);
          var lastVertex = this._getLastItemInArray(vertices);

          if(this._shiftDown) this.snapVertex(vertex,vertices);
          vertex = this.roundVertex(this.clampVertex(vertex));
          var crosses = vertices.length ? this._doesNewLineCrossVerticies(vertices, lastVertex, vertex) : false;
          this._changeLine(this._getCurrentLine(polygonGroup), vertex);

          if (
            firstVertex && vertices.length > 2 &&
            this._withinPointSnapRadius(
              this.ST(SNAP_RADIUS), firstVertex, vertex
            ) && !crosses
          ) {
            this._changeLine(this._getCurrentLine(polygonGroup), firstVertex);
            this._setInProgressFixed(polygonGroup);
            this._hideSnapCircle(polygonGroup);

            verticesSets.push([]);
            this.fire('polygon-complete',polygonGroup);
            polygonGroup = this._createPolygonGroup();

          } else if (!lastVertex || (lastVertex && !crosses)) {
            if(this.polygonCount >= this.polygonMax) return;
            this._setInProgressFixed(polygonGroup);
            this._addVertex(vertices, vertex)
            this._drawPoint(polygonGroup, vertex);
            this._drawLine(polygonGroup, vertex, vertex)
              .attr("class", "in-progress");
          }
          this.fire('polygon-point-click',polygonGroup);
        });
        
        this._attachMouseMoveEventToContainer(function (vertex) {
          
          var vertices = this._getLastItemInArray(verticesSets);
          
          var line = this._getCurrentLine(polygonGroup);

          if(this._shiftDown) this.snapVertex(vertex,vertices);
          vertex = this.roundVertex(this.clampVertex(vertex));

          if (!line.empty()) {

            var firstVertex = this._getFirstItemInArray(vertices);
            var lastVertex = this._getLastItemInArray(vertices);

            var calculatedX;
            var calculatedY;
            
            if (
              firstVertex && vertices.length > 2 &&
              this._withinPointSnapRadius(
                this.ST(SNAP_RADIUS), firstVertex, vertex
              ) && (
                !lastVertex || (lastVertex &&
                  !this._doesNewLineCrossVerticies(
                    vertices, lastVertex, firstVertex
                  )
                )
              )
            ) {

              calculatedX = firstVertex.x;
              calculatedY = firstVertex.y;

              if (!this._isFillShowing(polygonGroup)) {
                this._showFill(polygonGroup, vertices);
                this._showSnapCircle(polygonGroup, firstVertex);
              }

            } else {
              calculatedX = vertex.x;
              calculatedY = vertex.y;
              this._hideFill(polygonGroup);
              this._hideSnapCircle(polygonGroup);
            }

            var calculatedVertex = this._createVertex(calculatedX, calculatedY);
              
            this._changeLine(line, calculatedVertex);

            if (lastVertex && this._doesNewLineCrossVerticies(
              vertices, lastVertex, calculatedVertex
            )) {
              this._setLinesDashed(polygonGroup);
            } else {
              this._setLinesSolid(polygonGroup);
            }
          }
        });
      }
    }); </script> </dom-module> 